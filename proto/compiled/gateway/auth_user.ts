// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.5
//   protoc               v5.29.3
// source: gateway/auth_user.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  type ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  type Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";

export const protobufPackage = "auth_user.v1";

export interface UserInfo {
  userId: string;
  username: string;
  email: string;
  role: string;
  avatar: string;
}

export interface SignupRequest {
  username: string;
  firstName: string;
  lastName: string;
  email: string;
  password: string;
  country: string;
}

export interface SignupResponse {
  message: string;
}

export interface ResendOtpRequest {
  email: string;
}

export interface ResendOtpResponse {
  message: string;
}

export interface VerifyOtpRequest {
  email: string;
  otp: string;
}

export interface VerifyOtpResponse {
  message: string;
  accessToken: string;
  refreshToken: string;
  userInfo?: UserInfo | undefined;
}

export interface LoginRequest {
  email: string;
  password: string;
  role: string;
}

export interface LoginResponse {
  message: string;
  accessToken: string;
  refreshToken: string;
  userInfo?: UserInfo | undefined;
}

export interface OAuthLoginRequest {
  email: string;
  firstName: string;
  oAuthId: string;
  avatar: string;
}

export interface OAuthLoginResponse {
  message: string;
  accessToken: string;
  refreshToken: string;
  userInfo?: UserInfo | undefined;
}

export interface ForgotPasswordRequest {
  email: string;
}

export interface ForgotPasswordResponse {
  message: string;
}

export interface ResetPasswordRequest {
  email: string;
  newPassword: string;
  otp: string;
}

export interface ResetPasswordResponse {
  message: string;
}

export interface UserProfileRequest {
  userId: string;
  email: string;
}

export interface UserProfileResponse {
  userId: string;
  username: string;
  email: string;
  firstName: string;
  lastName: string;
  avatar: string;
  country: string;
  preferredLanguage: string;
  easySolved: number;
  mediumSolved: number;
  hardSolved: number;
  totalSubmission: number;
  streak: number;
  createdAt: string;
  updatedAt: string;
}

export interface RefreshTokenRequest {
  userId: string;
  email: string;
  role: string;
}

export interface RefreshTokenResponse {
  message: string;
  accessToken: string;
  userInfo?: UserInfo | undefined;
}

export interface UpdateProfileRequest {
  userId: string;
  username: string;
  firstName: string;
  lastName: string;
  country: string;
  preferredLanguage: string;
  avatar: string;
}

export interface UpdateProfileResponse {
  message: string;
}

export interface AdminProfileRequest {
  userId: string;
  email: string;
}

export interface AdminProfileResponse {
  userId: string;
  username: string;
  email: string;
  firstName: string;
  lastName: string;
  avatar: string;
  country: string;
  createdAt: string;
  updatedAt: string;
}

function createBaseUserInfo(): UserInfo {
  return { userId: "", username: "", email: "", role: "", avatar: "" };
}

export const UserInfo: MessageFns<UserInfo> = {
  encode(message: UserInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.username !== "") {
      writer.uint32(18).string(message.username);
    }
    if (message.email !== "") {
      writer.uint32(26).string(message.email);
    }
    if (message.role !== "") {
      writer.uint32(34).string(message.role);
    }
    if (message.avatar !== "") {
      writer.uint32(42).string(message.avatar);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.role = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.avatar = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserInfo {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      role: isSet(object.role) ? globalThis.String(object.role) : "",
      avatar: isSet(object.avatar) ? globalThis.String(object.avatar) : "",
    };
  },

  toJSON(message: UserInfo): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.role !== "") {
      obj.role = message.role;
    }
    if (message.avatar !== "") {
      obj.avatar = message.avatar;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserInfo>, I>>(base?: I): UserInfo {
    return UserInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserInfo>, I>>(object: I): UserInfo {
    const message = createBaseUserInfo();
    message.userId = object.userId ?? "";
    message.username = object.username ?? "";
    message.email = object.email ?? "";
    message.role = object.role ?? "";
    message.avatar = object.avatar ?? "";
    return message;
  },
};

function createBaseSignupRequest(): SignupRequest {
  return { username: "", firstName: "", lastName: "", email: "", password: "", country: "" };
}

export const SignupRequest: MessageFns<SignupRequest> = {
  encode(message: SignupRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.username !== "") {
      writer.uint32(10).string(message.username);
    }
    if (message.firstName !== "") {
      writer.uint32(18).string(message.firstName);
    }
    if (message.lastName !== "") {
      writer.uint32(26).string(message.lastName);
    }
    if (message.email !== "") {
      writer.uint32(34).string(message.email);
    }
    if (message.password !== "") {
      writer.uint32(42).string(message.password);
    }
    if (message.country !== "") {
      writer.uint32(50).string(message.country);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SignupRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignupRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.firstName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.lastName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.password = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.country = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignupRequest {
    return {
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      firstName: isSet(object.firstName) ? globalThis.String(object.firstName) : "",
      lastName: isSet(object.lastName) ? globalThis.String(object.lastName) : "",
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      password: isSet(object.password) ? globalThis.String(object.password) : "",
      country: isSet(object.country) ? globalThis.String(object.country) : "",
    };
  },

  toJSON(message: SignupRequest): unknown {
    const obj: any = {};
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.firstName !== "") {
      obj.firstName = message.firstName;
    }
    if (message.lastName !== "") {
      obj.lastName = message.lastName;
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    if (message.country !== "") {
      obj.country = message.country;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SignupRequest>, I>>(base?: I): SignupRequest {
    return SignupRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SignupRequest>, I>>(object: I): SignupRequest {
    const message = createBaseSignupRequest();
    message.username = object.username ?? "";
    message.firstName = object.firstName ?? "";
    message.lastName = object.lastName ?? "";
    message.email = object.email ?? "";
    message.password = object.password ?? "";
    message.country = object.country ?? "";
    return message;
  },
};

function createBaseSignupResponse(): SignupResponse {
  return { message: "" };
}

export const SignupResponse: MessageFns<SignupResponse> = {
  encode(message: SignupResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SignupResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignupResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignupResponse {
    return { message: isSet(object.message) ? globalThis.String(object.message) : "" };
  },

  toJSON(message: SignupResponse): unknown {
    const obj: any = {};
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SignupResponse>, I>>(base?: I): SignupResponse {
    return SignupResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SignupResponse>, I>>(object: I): SignupResponse {
    const message = createBaseSignupResponse();
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseResendOtpRequest(): ResendOtpRequest {
  return { email: "" };
}

export const ResendOtpRequest: MessageFns<ResendOtpRequest> = {
  encode(message: ResendOtpRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResendOtpRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResendOtpRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResendOtpRequest {
    return { email: isSet(object.email) ? globalThis.String(object.email) : "" };
  },

  toJSON(message: ResendOtpRequest): unknown {
    const obj: any = {};
    if (message.email !== "") {
      obj.email = message.email;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResendOtpRequest>, I>>(base?: I): ResendOtpRequest {
    return ResendOtpRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResendOtpRequest>, I>>(object: I): ResendOtpRequest {
    const message = createBaseResendOtpRequest();
    message.email = object.email ?? "";
    return message;
  },
};

function createBaseResendOtpResponse(): ResendOtpResponse {
  return { message: "" };
}

export const ResendOtpResponse: MessageFns<ResendOtpResponse> = {
  encode(message: ResendOtpResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResendOtpResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResendOtpResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResendOtpResponse {
    return { message: isSet(object.message) ? globalThis.String(object.message) : "" };
  },

  toJSON(message: ResendOtpResponse): unknown {
    const obj: any = {};
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResendOtpResponse>, I>>(base?: I): ResendOtpResponse {
    return ResendOtpResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResendOtpResponse>, I>>(object: I): ResendOtpResponse {
    const message = createBaseResendOtpResponse();
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseVerifyOtpRequest(): VerifyOtpRequest {
  return { email: "", otp: "" };
}

export const VerifyOtpRequest: MessageFns<VerifyOtpRequest> = {
  encode(message: VerifyOtpRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    if (message.otp !== "") {
      writer.uint32(18).string(message.otp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VerifyOtpRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVerifyOtpRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.otp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VerifyOtpRequest {
    return {
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      otp: isSet(object.otp) ? globalThis.String(object.otp) : "",
    };
  },

  toJSON(message: VerifyOtpRequest): unknown {
    const obj: any = {};
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.otp !== "") {
      obj.otp = message.otp;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VerifyOtpRequest>, I>>(base?: I): VerifyOtpRequest {
    return VerifyOtpRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VerifyOtpRequest>, I>>(object: I): VerifyOtpRequest {
    const message = createBaseVerifyOtpRequest();
    message.email = object.email ?? "";
    message.otp = object.otp ?? "";
    return message;
  },
};

function createBaseVerifyOtpResponse(): VerifyOtpResponse {
  return { message: "", accessToken: "", refreshToken: "", userInfo: undefined };
}

export const VerifyOtpResponse: MessageFns<VerifyOtpResponse> = {
  encode(message: VerifyOtpResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    if (message.accessToken !== "") {
      writer.uint32(18).string(message.accessToken);
    }
    if (message.refreshToken !== "") {
      writer.uint32(26).string(message.refreshToken);
    }
    if (message.userInfo !== undefined) {
      UserInfo.encode(message.userInfo, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VerifyOtpResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVerifyOtpResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.refreshToken = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.userInfo = UserInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VerifyOtpResponse {
    return {
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      accessToken: isSet(object.accessToken) ? globalThis.String(object.accessToken) : "",
      refreshToken: isSet(object.refreshToken) ? globalThis.String(object.refreshToken) : "",
      userInfo: isSet(object.userInfo) ? UserInfo.fromJSON(object.userInfo) : undefined,
    };
  },

  toJSON(message: VerifyOtpResponse): unknown {
    const obj: any = {};
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.accessToken !== "") {
      obj.accessToken = message.accessToken;
    }
    if (message.refreshToken !== "") {
      obj.refreshToken = message.refreshToken;
    }
    if (message.userInfo !== undefined) {
      obj.userInfo = UserInfo.toJSON(message.userInfo);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VerifyOtpResponse>, I>>(base?: I): VerifyOtpResponse {
    return VerifyOtpResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VerifyOtpResponse>, I>>(object: I): VerifyOtpResponse {
    const message = createBaseVerifyOtpResponse();
    message.message = object.message ?? "";
    message.accessToken = object.accessToken ?? "";
    message.refreshToken = object.refreshToken ?? "";
    message.userInfo = (object.userInfo !== undefined && object.userInfo !== null)
      ? UserInfo.fromPartial(object.userInfo)
      : undefined;
    return message;
  },
};

function createBaseLoginRequest(): LoginRequest {
  return { email: "", password: "", role: "" };
}

export const LoginRequest: MessageFns<LoginRequest> = {
  encode(message: LoginRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    if (message.password !== "") {
      writer.uint32(18).string(message.password);
    }
    if (message.role !== "") {
      writer.uint32(26).string(message.role);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoginRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoginRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.password = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.role = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoginRequest {
    return {
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      password: isSet(object.password) ? globalThis.String(object.password) : "",
      role: isSet(object.role) ? globalThis.String(object.role) : "",
    };
  },

  toJSON(message: LoginRequest): unknown {
    const obj: any = {};
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    if (message.role !== "") {
      obj.role = message.role;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LoginRequest>, I>>(base?: I): LoginRequest {
    return LoginRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoginRequest>, I>>(object: I): LoginRequest {
    const message = createBaseLoginRequest();
    message.email = object.email ?? "";
    message.password = object.password ?? "";
    message.role = object.role ?? "";
    return message;
  },
};

function createBaseLoginResponse(): LoginResponse {
  return { message: "", accessToken: "", refreshToken: "", userInfo: undefined };
}

export const LoginResponse: MessageFns<LoginResponse> = {
  encode(message: LoginResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    if (message.accessToken !== "") {
      writer.uint32(18).string(message.accessToken);
    }
    if (message.refreshToken !== "") {
      writer.uint32(26).string(message.refreshToken);
    }
    if (message.userInfo !== undefined) {
      UserInfo.encode(message.userInfo, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoginResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoginResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.refreshToken = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.userInfo = UserInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoginResponse {
    return {
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      accessToken: isSet(object.accessToken) ? globalThis.String(object.accessToken) : "",
      refreshToken: isSet(object.refreshToken) ? globalThis.String(object.refreshToken) : "",
      userInfo: isSet(object.userInfo) ? UserInfo.fromJSON(object.userInfo) : undefined,
    };
  },

  toJSON(message: LoginResponse): unknown {
    const obj: any = {};
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.accessToken !== "") {
      obj.accessToken = message.accessToken;
    }
    if (message.refreshToken !== "") {
      obj.refreshToken = message.refreshToken;
    }
    if (message.userInfo !== undefined) {
      obj.userInfo = UserInfo.toJSON(message.userInfo);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LoginResponse>, I>>(base?: I): LoginResponse {
    return LoginResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoginResponse>, I>>(object: I): LoginResponse {
    const message = createBaseLoginResponse();
    message.message = object.message ?? "";
    message.accessToken = object.accessToken ?? "";
    message.refreshToken = object.refreshToken ?? "";
    message.userInfo = (object.userInfo !== undefined && object.userInfo !== null)
      ? UserInfo.fromPartial(object.userInfo)
      : undefined;
    return message;
  },
};

function createBaseOAuthLoginRequest(): OAuthLoginRequest {
  return { email: "", firstName: "", oAuthId: "", avatar: "" };
}

export const OAuthLoginRequest: MessageFns<OAuthLoginRequest> = {
  encode(message: OAuthLoginRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    if (message.firstName !== "") {
      writer.uint32(18).string(message.firstName);
    }
    if (message.oAuthId !== "") {
      writer.uint32(26).string(message.oAuthId);
    }
    if (message.avatar !== "") {
      writer.uint32(42).string(message.avatar);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OAuthLoginRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOAuthLoginRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.firstName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.oAuthId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.avatar = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OAuthLoginRequest {
    return {
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      firstName: isSet(object.firstName) ? globalThis.String(object.firstName) : "",
      oAuthId: isSet(object.oAuthId) ? globalThis.String(object.oAuthId) : "",
      avatar: isSet(object.avatar) ? globalThis.String(object.avatar) : "",
    };
  },

  toJSON(message: OAuthLoginRequest): unknown {
    const obj: any = {};
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.firstName !== "") {
      obj.firstName = message.firstName;
    }
    if (message.oAuthId !== "") {
      obj.oAuthId = message.oAuthId;
    }
    if (message.avatar !== "") {
      obj.avatar = message.avatar;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OAuthLoginRequest>, I>>(base?: I): OAuthLoginRequest {
    return OAuthLoginRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OAuthLoginRequest>, I>>(object: I): OAuthLoginRequest {
    const message = createBaseOAuthLoginRequest();
    message.email = object.email ?? "";
    message.firstName = object.firstName ?? "";
    message.oAuthId = object.oAuthId ?? "";
    message.avatar = object.avatar ?? "";
    return message;
  },
};

function createBaseOAuthLoginResponse(): OAuthLoginResponse {
  return { message: "", accessToken: "", refreshToken: "", userInfo: undefined };
}

export const OAuthLoginResponse: MessageFns<OAuthLoginResponse> = {
  encode(message: OAuthLoginResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    if (message.accessToken !== "") {
      writer.uint32(18).string(message.accessToken);
    }
    if (message.refreshToken !== "") {
      writer.uint32(26).string(message.refreshToken);
    }
    if (message.userInfo !== undefined) {
      UserInfo.encode(message.userInfo, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OAuthLoginResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOAuthLoginResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.refreshToken = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.userInfo = UserInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OAuthLoginResponse {
    return {
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      accessToken: isSet(object.accessToken) ? globalThis.String(object.accessToken) : "",
      refreshToken: isSet(object.refreshToken) ? globalThis.String(object.refreshToken) : "",
      userInfo: isSet(object.userInfo) ? UserInfo.fromJSON(object.userInfo) : undefined,
    };
  },

  toJSON(message: OAuthLoginResponse): unknown {
    const obj: any = {};
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.accessToken !== "") {
      obj.accessToken = message.accessToken;
    }
    if (message.refreshToken !== "") {
      obj.refreshToken = message.refreshToken;
    }
    if (message.userInfo !== undefined) {
      obj.userInfo = UserInfo.toJSON(message.userInfo);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OAuthLoginResponse>, I>>(base?: I): OAuthLoginResponse {
    return OAuthLoginResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OAuthLoginResponse>, I>>(object: I): OAuthLoginResponse {
    const message = createBaseOAuthLoginResponse();
    message.message = object.message ?? "";
    message.accessToken = object.accessToken ?? "";
    message.refreshToken = object.refreshToken ?? "";
    message.userInfo = (object.userInfo !== undefined && object.userInfo !== null)
      ? UserInfo.fromPartial(object.userInfo)
      : undefined;
    return message;
  },
};

function createBaseForgotPasswordRequest(): ForgotPasswordRequest {
  return { email: "" };
}

export const ForgotPasswordRequest: MessageFns<ForgotPasswordRequest> = {
  encode(message: ForgotPasswordRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ForgotPasswordRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseForgotPasswordRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ForgotPasswordRequest {
    return { email: isSet(object.email) ? globalThis.String(object.email) : "" };
  },

  toJSON(message: ForgotPasswordRequest): unknown {
    const obj: any = {};
    if (message.email !== "") {
      obj.email = message.email;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ForgotPasswordRequest>, I>>(base?: I): ForgotPasswordRequest {
    return ForgotPasswordRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ForgotPasswordRequest>, I>>(object: I): ForgotPasswordRequest {
    const message = createBaseForgotPasswordRequest();
    message.email = object.email ?? "";
    return message;
  },
};

function createBaseForgotPasswordResponse(): ForgotPasswordResponse {
  return { message: "" };
}

export const ForgotPasswordResponse: MessageFns<ForgotPasswordResponse> = {
  encode(message: ForgotPasswordResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ForgotPasswordResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseForgotPasswordResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ForgotPasswordResponse {
    return { message: isSet(object.message) ? globalThis.String(object.message) : "" };
  },

  toJSON(message: ForgotPasswordResponse): unknown {
    const obj: any = {};
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ForgotPasswordResponse>, I>>(base?: I): ForgotPasswordResponse {
    return ForgotPasswordResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ForgotPasswordResponse>, I>>(object: I): ForgotPasswordResponse {
    const message = createBaseForgotPasswordResponse();
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseResetPasswordRequest(): ResetPasswordRequest {
  return { email: "", newPassword: "", otp: "" };
}

export const ResetPasswordRequest: MessageFns<ResetPasswordRequest> = {
  encode(message: ResetPasswordRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    if (message.newPassword !== "") {
      writer.uint32(18).string(message.newPassword);
    }
    if (message.otp !== "") {
      writer.uint32(26).string(message.otp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResetPasswordRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResetPasswordRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.newPassword = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.otp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResetPasswordRequest {
    return {
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      newPassword: isSet(object.newPassword) ? globalThis.String(object.newPassword) : "",
      otp: isSet(object.otp) ? globalThis.String(object.otp) : "",
    };
  },

  toJSON(message: ResetPasswordRequest): unknown {
    const obj: any = {};
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.newPassword !== "") {
      obj.newPassword = message.newPassword;
    }
    if (message.otp !== "") {
      obj.otp = message.otp;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResetPasswordRequest>, I>>(base?: I): ResetPasswordRequest {
    return ResetPasswordRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResetPasswordRequest>, I>>(object: I): ResetPasswordRequest {
    const message = createBaseResetPasswordRequest();
    message.email = object.email ?? "";
    message.newPassword = object.newPassword ?? "";
    message.otp = object.otp ?? "";
    return message;
  },
};

function createBaseResetPasswordResponse(): ResetPasswordResponse {
  return { message: "" };
}

export const ResetPasswordResponse: MessageFns<ResetPasswordResponse> = {
  encode(message: ResetPasswordResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResetPasswordResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResetPasswordResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResetPasswordResponse {
    return { message: isSet(object.message) ? globalThis.String(object.message) : "" };
  },

  toJSON(message: ResetPasswordResponse): unknown {
    const obj: any = {};
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResetPasswordResponse>, I>>(base?: I): ResetPasswordResponse {
    return ResetPasswordResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResetPasswordResponse>, I>>(object: I): ResetPasswordResponse {
    const message = createBaseResetPasswordResponse();
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseUserProfileRequest(): UserProfileRequest {
  return { userId: "", email: "" };
}

export const UserProfileRequest: MessageFns<UserProfileRequest> = {
  encode(message: UserProfileRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.email !== "") {
      writer.uint32(18).string(message.email);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserProfileRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserProfileRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.email = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserProfileRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      email: isSet(object.email) ? globalThis.String(object.email) : "",
    };
  },

  toJSON(message: UserProfileRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserProfileRequest>, I>>(base?: I): UserProfileRequest {
    return UserProfileRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserProfileRequest>, I>>(object: I): UserProfileRequest {
    const message = createBaseUserProfileRequest();
    message.userId = object.userId ?? "";
    message.email = object.email ?? "";
    return message;
  },
};

function createBaseUserProfileResponse(): UserProfileResponse {
  return {
    userId: "",
    username: "",
    email: "",
    firstName: "",
    lastName: "",
    avatar: "",
    country: "",
    preferredLanguage: "",
    easySolved: 0,
    mediumSolved: 0,
    hardSolved: 0,
    totalSubmission: 0,
    streak: 0,
    createdAt: "",
    updatedAt: "",
  };
}

export const UserProfileResponse: MessageFns<UserProfileResponse> = {
  encode(message: UserProfileResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.username !== "") {
      writer.uint32(18).string(message.username);
    }
    if (message.email !== "") {
      writer.uint32(26).string(message.email);
    }
    if (message.firstName !== "") {
      writer.uint32(34).string(message.firstName);
    }
    if (message.lastName !== "") {
      writer.uint32(42).string(message.lastName);
    }
    if (message.avatar !== "") {
      writer.uint32(50).string(message.avatar);
    }
    if (message.country !== "") {
      writer.uint32(58).string(message.country);
    }
    if (message.preferredLanguage !== "") {
      writer.uint32(66).string(message.preferredLanguage);
    }
    if (message.easySolved !== 0) {
      writer.uint32(72).int32(message.easySolved);
    }
    if (message.mediumSolved !== 0) {
      writer.uint32(80).int32(message.mediumSolved);
    }
    if (message.hardSolved !== 0) {
      writer.uint32(88).int32(message.hardSolved);
    }
    if (message.totalSubmission !== 0) {
      writer.uint32(96).int32(message.totalSubmission);
    }
    if (message.streak !== 0) {
      writer.uint32(104).int32(message.streak);
    }
    if (message.createdAt !== "") {
      writer.uint32(114).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(122).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserProfileResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserProfileResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.firstName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.lastName = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.avatar = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.country = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.preferredLanguage = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.easySolved = reader.int32();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.mediumSolved = reader.int32();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.hardSolved = reader.int32();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.totalSubmission = reader.int32();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.streak = reader.int32();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserProfileResponse {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      firstName: isSet(object.firstName) ? globalThis.String(object.firstName) : "",
      lastName: isSet(object.lastName) ? globalThis.String(object.lastName) : "",
      avatar: isSet(object.avatar) ? globalThis.String(object.avatar) : "",
      country: isSet(object.country) ? globalThis.String(object.country) : "",
      preferredLanguage: isSet(object.preferredLanguage) ? globalThis.String(object.preferredLanguage) : "",
      easySolved: isSet(object.easySolved) ? globalThis.Number(object.easySolved) : 0,
      mediumSolved: isSet(object.mediumSolved) ? globalThis.Number(object.mediumSolved) : 0,
      hardSolved: isSet(object.hardSolved) ? globalThis.Number(object.hardSolved) : 0,
      totalSubmission: isSet(object.totalSubmission) ? globalThis.Number(object.totalSubmission) : 0,
      streak: isSet(object.streak) ? globalThis.Number(object.streak) : 0,
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
      updatedAt: isSet(object.updatedAt) ? globalThis.String(object.updatedAt) : "",
    };
  },

  toJSON(message: UserProfileResponse): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.firstName !== "") {
      obj.firstName = message.firstName;
    }
    if (message.lastName !== "") {
      obj.lastName = message.lastName;
    }
    if (message.avatar !== "") {
      obj.avatar = message.avatar;
    }
    if (message.country !== "") {
      obj.country = message.country;
    }
    if (message.preferredLanguage !== "") {
      obj.preferredLanguage = message.preferredLanguage;
    }
    if (message.easySolved !== 0) {
      obj.easySolved = Math.round(message.easySolved);
    }
    if (message.mediumSolved !== 0) {
      obj.mediumSolved = Math.round(message.mediumSolved);
    }
    if (message.hardSolved !== 0) {
      obj.hardSolved = Math.round(message.hardSolved);
    }
    if (message.totalSubmission !== 0) {
      obj.totalSubmission = Math.round(message.totalSubmission);
    }
    if (message.streak !== 0) {
      obj.streak = Math.round(message.streak);
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserProfileResponse>, I>>(base?: I): UserProfileResponse {
    return UserProfileResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserProfileResponse>, I>>(object: I): UserProfileResponse {
    const message = createBaseUserProfileResponse();
    message.userId = object.userId ?? "";
    message.username = object.username ?? "";
    message.email = object.email ?? "";
    message.firstName = object.firstName ?? "";
    message.lastName = object.lastName ?? "";
    message.avatar = object.avatar ?? "";
    message.country = object.country ?? "";
    message.preferredLanguage = object.preferredLanguage ?? "";
    message.easySolved = object.easySolved ?? 0;
    message.mediumSolved = object.mediumSolved ?? 0;
    message.hardSolved = object.hardSolved ?? 0;
    message.totalSubmission = object.totalSubmission ?? 0;
    message.streak = object.streak ?? 0;
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? "";
    return message;
  },
};

function createBaseRefreshTokenRequest(): RefreshTokenRequest {
  return { userId: "", email: "", role: "" };
}

export const RefreshTokenRequest: MessageFns<RefreshTokenRequest> = {
  encode(message: RefreshTokenRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.email !== "") {
      writer.uint32(18).string(message.email);
    }
    if (message.role !== "") {
      writer.uint32(26).string(message.role);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RefreshTokenRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRefreshTokenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.role = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RefreshTokenRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      role: isSet(object.role) ? globalThis.String(object.role) : "",
    };
  },

  toJSON(message: RefreshTokenRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.role !== "") {
      obj.role = message.role;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RefreshTokenRequest>, I>>(base?: I): RefreshTokenRequest {
    return RefreshTokenRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RefreshTokenRequest>, I>>(object: I): RefreshTokenRequest {
    const message = createBaseRefreshTokenRequest();
    message.userId = object.userId ?? "";
    message.email = object.email ?? "";
    message.role = object.role ?? "";
    return message;
  },
};

function createBaseRefreshTokenResponse(): RefreshTokenResponse {
  return { message: "", accessToken: "", userInfo: undefined };
}

export const RefreshTokenResponse: MessageFns<RefreshTokenResponse> = {
  encode(message: RefreshTokenResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    if (message.accessToken !== "") {
      writer.uint32(18).string(message.accessToken);
    }
    if (message.userInfo !== undefined) {
      UserInfo.encode(message.userInfo, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RefreshTokenResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRefreshTokenResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.userInfo = UserInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RefreshTokenResponse {
    return {
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      accessToken: isSet(object.accessToken) ? globalThis.String(object.accessToken) : "",
      userInfo: isSet(object.userInfo) ? UserInfo.fromJSON(object.userInfo) : undefined,
    };
  },

  toJSON(message: RefreshTokenResponse): unknown {
    const obj: any = {};
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.accessToken !== "") {
      obj.accessToken = message.accessToken;
    }
    if (message.userInfo !== undefined) {
      obj.userInfo = UserInfo.toJSON(message.userInfo);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RefreshTokenResponse>, I>>(base?: I): RefreshTokenResponse {
    return RefreshTokenResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RefreshTokenResponse>, I>>(object: I): RefreshTokenResponse {
    const message = createBaseRefreshTokenResponse();
    message.message = object.message ?? "";
    message.accessToken = object.accessToken ?? "";
    message.userInfo = (object.userInfo !== undefined && object.userInfo !== null)
      ? UserInfo.fromPartial(object.userInfo)
      : undefined;
    return message;
  },
};

function createBaseUpdateProfileRequest(): UpdateProfileRequest {
  return { userId: "", username: "", firstName: "", lastName: "", country: "", preferredLanguage: "", avatar: "" };
}

export const UpdateProfileRequest: MessageFns<UpdateProfileRequest> = {
  encode(message: UpdateProfileRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.username !== "") {
      writer.uint32(18).string(message.username);
    }
    if (message.firstName !== "") {
      writer.uint32(26).string(message.firstName);
    }
    if (message.lastName !== "") {
      writer.uint32(34).string(message.lastName);
    }
    if (message.country !== "") {
      writer.uint32(42).string(message.country);
    }
    if (message.preferredLanguage !== "") {
      writer.uint32(50).string(message.preferredLanguage);
    }
    if (message.avatar !== "") {
      writer.uint32(58).string(message.avatar);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateProfileRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateProfileRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.firstName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.lastName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.country = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.preferredLanguage = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.avatar = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateProfileRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      firstName: isSet(object.firstName) ? globalThis.String(object.firstName) : "",
      lastName: isSet(object.lastName) ? globalThis.String(object.lastName) : "",
      country: isSet(object.country) ? globalThis.String(object.country) : "",
      preferredLanguage: isSet(object.preferredLanguage) ? globalThis.String(object.preferredLanguage) : "",
      avatar: isSet(object.avatar) ? globalThis.String(object.avatar) : "",
    };
  },

  toJSON(message: UpdateProfileRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.firstName !== "") {
      obj.firstName = message.firstName;
    }
    if (message.lastName !== "") {
      obj.lastName = message.lastName;
    }
    if (message.country !== "") {
      obj.country = message.country;
    }
    if (message.preferredLanguage !== "") {
      obj.preferredLanguage = message.preferredLanguage;
    }
    if (message.avatar !== "") {
      obj.avatar = message.avatar;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateProfileRequest>, I>>(base?: I): UpdateProfileRequest {
    return UpdateProfileRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateProfileRequest>, I>>(object: I): UpdateProfileRequest {
    const message = createBaseUpdateProfileRequest();
    message.userId = object.userId ?? "";
    message.username = object.username ?? "";
    message.firstName = object.firstName ?? "";
    message.lastName = object.lastName ?? "";
    message.country = object.country ?? "";
    message.preferredLanguage = object.preferredLanguage ?? "";
    message.avatar = object.avatar ?? "";
    return message;
  },
};

function createBaseUpdateProfileResponse(): UpdateProfileResponse {
  return { message: "" };
}

export const UpdateProfileResponse: MessageFns<UpdateProfileResponse> = {
  encode(message: UpdateProfileResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateProfileResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateProfileResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateProfileResponse {
    return { message: isSet(object.message) ? globalThis.String(object.message) : "" };
  },

  toJSON(message: UpdateProfileResponse): unknown {
    const obj: any = {};
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateProfileResponse>, I>>(base?: I): UpdateProfileResponse {
    return UpdateProfileResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateProfileResponse>, I>>(object: I): UpdateProfileResponse {
    const message = createBaseUpdateProfileResponse();
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseAdminProfileRequest(): AdminProfileRequest {
  return { userId: "", email: "" };
}

export const AdminProfileRequest: MessageFns<AdminProfileRequest> = {
  encode(message: AdminProfileRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.email !== "") {
      writer.uint32(18).string(message.email);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AdminProfileRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAdminProfileRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.email = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AdminProfileRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      email: isSet(object.email) ? globalThis.String(object.email) : "",
    };
  },

  toJSON(message: AdminProfileRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AdminProfileRequest>, I>>(base?: I): AdminProfileRequest {
    return AdminProfileRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AdminProfileRequest>, I>>(object: I): AdminProfileRequest {
    const message = createBaseAdminProfileRequest();
    message.userId = object.userId ?? "";
    message.email = object.email ?? "";
    return message;
  },
};

function createBaseAdminProfileResponse(): AdminProfileResponse {
  return {
    userId: "",
    username: "",
    email: "",
    firstName: "",
    lastName: "",
    avatar: "",
    country: "",
    createdAt: "",
    updatedAt: "",
  };
}

export const AdminProfileResponse: MessageFns<AdminProfileResponse> = {
  encode(message: AdminProfileResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.username !== "") {
      writer.uint32(18).string(message.username);
    }
    if (message.email !== "") {
      writer.uint32(26).string(message.email);
    }
    if (message.firstName !== "") {
      writer.uint32(34).string(message.firstName);
    }
    if (message.lastName !== "") {
      writer.uint32(42).string(message.lastName);
    }
    if (message.avatar !== "") {
      writer.uint32(50).string(message.avatar);
    }
    if (message.country !== "") {
      writer.uint32(58).string(message.country);
    }
    if (message.createdAt !== "") {
      writer.uint32(66).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(74).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AdminProfileResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAdminProfileResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.firstName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.lastName = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.avatar = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.country = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AdminProfileResponse {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      firstName: isSet(object.firstName) ? globalThis.String(object.firstName) : "",
      lastName: isSet(object.lastName) ? globalThis.String(object.lastName) : "",
      avatar: isSet(object.avatar) ? globalThis.String(object.avatar) : "",
      country: isSet(object.country) ? globalThis.String(object.country) : "",
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
      updatedAt: isSet(object.updatedAt) ? globalThis.String(object.updatedAt) : "",
    };
  },

  toJSON(message: AdminProfileResponse): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.firstName !== "") {
      obj.firstName = message.firstName;
    }
    if (message.lastName !== "") {
      obj.lastName = message.lastName;
    }
    if (message.avatar !== "") {
      obj.avatar = message.avatar;
    }
    if (message.country !== "") {
      obj.country = message.country;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AdminProfileResponse>, I>>(base?: I): AdminProfileResponse {
    return AdminProfileResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AdminProfileResponse>, I>>(object: I): AdminProfileResponse {
    const message = createBaseAdminProfileResponse();
    message.userId = object.userId ?? "";
    message.username = object.username ?? "";
    message.email = object.email ?? "";
    message.firstName = object.firstName ?? "";
    message.lastName = object.lastName ?? "";
    message.avatar = object.avatar ?? "";
    message.country = object.country ?? "";
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? "";
    return message;
  },
};

export type AuthUserServiceService = typeof AuthUserServiceService;
export const AuthUserServiceService = {
  signup: {
    path: "/auth_user.v1.AuthUserService/Signup",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SignupRequest): Buffer => Buffer.from(SignupRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): SignupRequest => SignupRequest.decode(value),
    responseSerialize: (value: SignupResponse): Buffer => Buffer.from(SignupResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SignupResponse => SignupResponse.decode(value),
  },
  resendOtp: {
    path: "/auth_user.v1.AuthUserService/ResendOtp",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ResendOtpRequest): Buffer => Buffer.from(ResendOtpRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ResendOtpRequest => ResendOtpRequest.decode(value),
    responseSerialize: (value: ResendOtpResponse): Buffer => Buffer.from(ResendOtpResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ResendOtpResponse => ResendOtpResponse.decode(value),
  },
  verifyOtp: {
    path: "/auth_user.v1.AuthUserService/VerifyOtp",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: VerifyOtpRequest): Buffer => Buffer.from(VerifyOtpRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): VerifyOtpRequest => VerifyOtpRequest.decode(value),
    responseSerialize: (value: VerifyOtpResponse): Buffer => Buffer.from(VerifyOtpResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): VerifyOtpResponse => VerifyOtpResponse.decode(value),
  },
  login: {
    path: "/auth_user.v1.AuthUserService/Login",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: LoginRequest): Buffer => Buffer.from(LoginRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): LoginRequest => LoginRequest.decode(value),
    responseSerialize: (value: LoginResponse): Buffer => Buffer.from(LoginResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): LoginResponse => LoginResponse.decode(value),
  },
  oAuthLogin: {
    path: "/auth_user.v1.AuthUserService/OAuthLogin",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: OAuthLoginRequest): Buffer => Buffer.from(OAuthLoginRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): OAuthLoginRequest => OAuthLoginRequest.decode(value),
    responseSerialize: (value: OAuthLoginResponse): Buffer => Buffer.from(OAuthLoginResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): OAuthLoginResponse => OAuthLoginResponse.decode(value),
  },
  forgotPassword: {
    path: "/auth_user.v1.AuthUserService/ForgotPassword",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ForgotPasswordRequest): Buffer =>
      Buffer.from(ForgotPasswordRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ForgotPasswordRequest => ForgotPasswordRequest.decode(value),
    responseSerialize: (value: ForgotPasswordResponse): Buffer =>
      Buffer.from(ForgotPasswordResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ForgotPasswordResponse => ForgotPasswordResponse.decode(value),
  },
  resetPassword: {
    path: "/auth_user.v1.AuthUserService/ResetPassword",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ResetPasswordRequest): Buffer => Buffer.from(ResetPasswordRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ResetPasswordRequest => ResetPasswordRequest.decode(value),
    responseSerialize: (value: ResetPasswordResponse): Buffer =>
      Buffer.from(ResetPasswordResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ResetPasswordResponse => ResetPasswordResponse.decode(value),
  },
  refreshToken: {
    path: "/auth_user.v1.AuthUserService/RefreshToken",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RefreshTokenRequest): Buffer => Buffer.from(RefreshTokenRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): RefreshTokenRequest => RefreshTokenRequest.decode(value),
    responseSerialize: (value: RefreshTokenResponse): Buffer =>
      Buffer.from(RefreshTokenResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): RefreshTokenResponse => RefreshTokenResponse.decode(value),
  },
  profile: {
    path: "/auth_user.v1.AuthUserService/Profile",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UserProfileRequest): Buffer => Buffer.from(UserProfileRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UserProfileRequest => UserProfileRequest.decode(value),
    responseSerialize: (value: UserProfileResponse): Buffer => Buffer.from(UserProfileResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): UserProfileResponse => UserProfileResponse.decode(value),
  },
  updateProfile: {
    path: "/auth_user.v1.AuthUserService/UpdateProfile",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateProfileRequest): Buffer => Buffer.from(UpdateProfileRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateProfileRequest => UpdateProfileRequest.decode(value),
    responseSerialize: (value: UpdateProfileResponse): Buffer =>
      Buffer.from(UpdateProfileResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): UpdateProfileResponse => UpdateProfileResponse.decode(value),
  },
} as const;

export interface AuthUserServiceServer extends UntypedServiceImplementation {
  signup: handleUnaryCall<SignupRequest, SignupResponse>;
  resendOtp: handleUnaryCall<ResendOtpRequest, ResendOtpResponse>;
  verifyOtp: handleUnaryCall<VerifyOtpRequest, VerifyOtpResponse>;
  login: handleUnaryCall<LoginRequest, LoginResponse>;
  oAuthLogin: handleUnaryCall<OAuthLoginRequest, OAuthLoginResponse>;
  forgotPassword: handleUnaryCall<ForgotPasswordRequest, ForgotPasswordResponse>;
  resetPassword: handleUnaryCall<ResetPasswordRequest, ResetPasswordResponse>;
  refreshToken: handleUnaryCall<RefreshTokenRequest, RefreshTokenResponse>;
  profile: handleUnaryCall<UserProfileRequest, UserProfileResponse>;
  updateProfile: handleUnaryCall<UpdateProfileRequest, UpdateProfileResponse>;
}

export interface AuthUserServiceClient extends Client {
  signup(
    request: SignupRequest,
    callback: (error: ServiceError | null, response: SignupResponse) => void,
  ): ClientUnaryCall;
  signup(
    request: SignupRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SignupResponse) => void,
  ): ClientUnaryCall;
  signup(
    request: SignupRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SignupResponse) => void,
  ): ClientUnaryCall;
  resendOtp(
    request: ResendOtpRequest,
    callback: (error: ServiceError | null, response: ResendOtpResponse) => void,
  ): ClientUnaryCall;
  resendOtp(
    request: ResendOtpRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ResendOtpResponse) => void,
  ): ClientUnaryCall;
  resendOtp(
    request: ResendOtpRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ResendOtpResponse) => void,
  ): ClientUnaryCall;
  verifyOtp(
    request: VerifyOtpRequest,
    callback: (error: ServiceError | null, response: VerifyOtpResponse) => void,
  ): ClientUnaryCall;
  verifyOtp(
    request: VerifyOtpRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: VerifyOtpResponse) => void,
  ): ClientUnaryCall;
  verifyOtp(
    request: VerifyOtpRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: VerifyOtpResponse) => void,
  ): ClientUnaryCall;
  login(
    request: LoginRequest,
    callback: (error: ServiceError | null, response: LoginResponse) => void,
  ): ClientUnaryCall;
  login(
    request: LoginRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: LoginResponse) => void,
  ): ClientUnaryCall;
  login(
    request: LoginRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: LoginResponse) => void,
  ): ClientUnaryCall;
  oAuthLogin(
    request: OAuthLoginRequest,
    callback: (error: ServiceError | null, response: OAuthLoginResponse) => void,
  ): ClientUnaryCall;
  oAuthLogin(
    request: OAuthLoginRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: OAuthLoginResponse) => void,
  ): ClientUnaryCall;
  oAuthLogin(
    request: OAuthLoginRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: OAuthLoginResponse) => void,
  ): ClientUnaryCall;
  forgotPassword(
    request: ForgotPasswordRequest,
    callback: (error: ServiceError | null, response: ForgotPasswordResponse) => void,
  ): ClientUnaryCall;
  forgotPassword(
    request: ForgotPasswordRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ForgotPasswordResponse) => void,
  ): ClientUnaryCall;
  forgotPassword(
    request: ForgotPasswordRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ForgotPasswordResponse) => void,
  ): ClientUnaryCall;
  resetPassword(
    request: ResetPasswordRequest,
    callback: (error: ServiceError | null, response: ResetPasswordResponse) => void,
  ): ClientUnaryCall;
  resetPassword(
    request: ResetPasswordRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ResetPasswordResponse) => void,
  ): ClientUnaryCall;
  resetPassword(
    request: ResetPasswordRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ResetPasswordResponse) => void,
  ): ClientUnaryCall;
  refreshToken(
    request: RefreshTokenRequest,
    callback: (error: ServiceError | null, response: RefreshTokenResponse) => void,
  ): ClientUnaryCall;
  refreshToken(
    request: RefreshTokenRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: RefreshTokenResponse) => void,
  ): ClientUnaryCall;
  refreshToken(
    request: RefreshTokenRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: RefreshTokenResponse) => void,
  ): ClientUnaryCall;
  profile(
    request: UserProfileRequest,
    callback: (error: ServiceError | null, response: UserProfileResponse) => void,
  ): ClientUnaryCall;
  profile(
    request: UserProfileRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: UserProfileResponse) => void,
  ): ClientUnaryCall;
  profile(
    request: UserProfileRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: UserProfileResponse) => void,
  ): ClientUnaryCall;
  updateProfile(
    request: UpdateProfileRequest,
    callback: (error: ServiceError | null, response: UpdateProfileResponse) => void,
  ): ClientUnaryCall;
  updateProfile(
    request: UpdateProfileRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: UpdateProfileResponse) => void,
  ): ClientUnaryCall;
  updateProfile(
    request: UpdateProfileRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: UpdateProfileResponse) => void,
  ): ClientUnaryCall;
}

export const AuthUserServiceClient = makeGenericClientConstructor(
  AuthUserServiceService,
  "auth_user.v1.AuthUserService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): AuthUserServiceClient;
  service: typeof AuthUserServiceService;
  serviceName: string;
};

export type AuthAdminServiceService = typeof AuthAdminServiceService;
export const AuthAdminServiceService = {
  login: {
    path: "/auth_user.v1.AuthAdminService/Login",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: LoginRequest): Buffer => Buffer.from(LoginRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): LoginRequest => LoginRequest.decode(value),
    responseSerialize: (value: LoginResponse): Buffer => Buffer.from(LoginResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): LoginResponse => LoginResponse.decode(value),
  },
  refreshToken: {
    path: "/auth_user.v1.AuthAdminService/RefreshToken",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RefreshTokenRequest): Buffer => Buffer.from(RefreshTokenRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): RefreshTokenRequest => RefreshTokenRequest.decode(value),
    responseSerialize: (value: RefreshTokenResponse): Buffer =>
      Buffer.from(RefreshTokenResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): RefreshTokenResponse => RefreshTokenResponse.decode(value),
  },
  profile: {
    path: "/auth_user.v1.AuthAdminService/Profile",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: AdminProfileRequest): Buffer => Buffer.from(AdminProfileRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): AdminProfileRequest => AdminProfileRequest.decode(value),
    responseSerialize: (value: AdminProfileResponse): Buffer =>
      Buffer.from(AdminProfileResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): AdminProfileResponse => AdminProfileResponse.decode(value),
  },
  updateProfile: {
    path: "/auth_user.v1.AuthAdminService/UpdateProfile",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateProfileRequest): Buffer => Buffer.from(UpdateProfileRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateProfileRequest => UpdateProfileRequest.decode(value),
    responseSerialize: (value: UpdateProfileResponse): Buffer =>
      Buffer.from(UpdateProfileResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): UpdateProfileResponse => UpdateProfileResponse.decode(value),
  },
} as const;

export interface AuthAdminServiceServer extends UntypedServiceImplementation {
  login: handleUnaryCall<LoginRequest, LoginResponse>;
  refreshToken: handleUnaryCall<RefreshTokenRequest, RefreshTokenResponse>;
  profile: handleUnaryCall<AdminProfileRequest, AdminProfileResponse>;
  updateProfile: handleUnaryCall<UpdateProfileRequest, UpdateProfileResponse>;
}

export interface AuthAdminServiceClient extends Client {
  login(
    request: LoginRequest,
    callback: (error: ServiceError | null, response: LoginResponse) => void,
  ): ClientUnaryCall;
  login(
    request: LoginRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: LoginResponse) => void,
  ): ClientUnaryCall;
  login(
    request: LoginRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: LoginResponse) => void,
  ): ClientUnaryCall;
  refreshToken(
    request: RefreshTokenRequest,
    callback: (error: ServiceError | null, response: RefreshTokenResponse) => void,
  ): ClientUnaryCall;
  refreshToken(
    request: RefreshTokenRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: RefreshTokenResponse) => void,
  ): ClientUnaryCall;
  refreshToken(
    request: RefreshTokenRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: RefreshTokenResponse) => void,
  ): ClientUnaryCall;
  profile(
    request: AdminProfileRequest,
    callback: (error: ServiceError | null, response: AdminProfileResponse) => void,
  ): ClientUnaryCall;
  profile(
    request: AdminProfileRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: AdminProfileResponse) => void,
  ): ClientUnaryCall;
  profile(
    request: AdminProfileRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: AdminProfileResponse) => void,
  ): ClientUnaryCall;
  updateProfile(
    request: UpdateProfileRequest,
    callback: (error: ServiceError | null, response: UpdateProfileResponse) => void,
  ): ClientUnaryCall;
  updateProfile(
    request: UpdateProfileRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: UpdateProfileResponse) => void,
  ): ClientUnaryCall;
  updateProfile(
    request: UpdateProfileRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: UpdateProfileResponse) => void,
  ): ClientUnaryCall;
}

export const AuthAdminServiceClient = makeGenericClientConstructor(
  AuthAdminServiceService,
  "auth_user.v1.AuthAdminService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): AuthAdminServiceClient;
  service: typeof AuthAdminServiceService;
  serviceName: string;
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}

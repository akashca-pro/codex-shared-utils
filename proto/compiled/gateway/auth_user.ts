// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.5
//   protoc               v5.29.3
// source: gateway/auth_user.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  type ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  type Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import { Empty } from "../google/protobuf/empty";

export const protobufPackage = "auth_user.v1";

export interface UserInfo {
  userId: string;
  firstName: string;
  username: string;
  email: string;
  role: string;
  avatar: string;
  country?: string | undefined;
}

export interface SignupRequest {
  username: string;
  firstName: string;
  lastName: string;
  email: string;
  password: string;
  country: string;
}

export interface SignupResponse {
  message: string;
}

export interface ResendOtpRequest {
  email: string;
  otpType: string;
}

export interface ResendOtpResponse {
  message: string;
}

export interface VerifyOtpRequest {
  email: string;
  otp: string;
}

export interface VerifyOtpResponse {
  message: string;
  accessToken: string;
  refreshToken: string;
  userInfo?: UserInfo | undefined;
}

export interface LoginRequest {
  email: string;
  password: string;
  role: string;
}

export interface LoginResponse {
  message: string;
  accessToken: string;
  refreshToken: string;
  userInfo?: UserInfo | undefined;
}

export interface OAuthLoginRequest {
  email: string;
  firstName: string;
  oAuthId: string;
  avatar: string;
}

export interface OAuthLoginResponse {
  message: string;
  accessToken: string;
  refreshToken: string;
  userInfo?: UserInfo | undefined;
}

export interface ForgotPasswordRequest {
  email: string;
}

export interface ForgotPasswordResponse {
  message: string;
}

export interface ResetPasswordRequest {
  email: string;
  newPassword: string;
  otp: string;
}

export interface ResetPasswordResponse {
  message: string;
}

export interface UserProfileRequest {
  userId: string;
  email: string;
}

export interface UserProfileResponse {
  userId: string;
  username: string;
  email: string;
  firstName: string;
  lastName: string;
  avatar: string;
  country: string;
  preferredLanguage: string;
  easySolved: number;
  mediumSolved: number;
  hardSolved: number;
  totalSubmission: number;
  streak: number;
  createdAt: string;
  updatedAt: string;
}

export interface RefreshTokenRequest {
  userId: string;
  username: string;
  email: string;
  role: string;
}

export interface RefreshTokenResponse {
  message: string;
  accessToken: string;
  userInfo?: UserInfo | undefined;
}

export interface UpdateProfileRequest {
  userId: string;
  username?: string | undefined;
  firstName?: string | undefined;
  lastName?: string | undefined;
  country?: string | undefined;
  preferredLanguage?: string | undefined;
  avatar?: string | undefined;
}

export interface UpdatedData {
  username?: string | undefined;
  firstName?: string | undefined;
  lastName?: string | undefined;
  avatar?: string | undefined;
  email?: string | undefined;
  country?: string | undefined;
  password?: string | undefined;
  isVerified?: boolean | undefined;
  isArchived?: boolean | undefined;
  isBlocked?: boolean | undefined;
  preferredLanguage?: string | undefined;
  easySolved?: number | undefined;
  mediumSolved?: number | undefined;
  hardSolved?: number | undefined;
  totalSubmission?: number | undefined;
  streak?: number | undefined;
  updatedAt?: string | undefined;
}

export interface UpdateProfileResponse {
  message: string;
  updatedData?: UpdatedData | undefined;
}

export interface ChangeEmailRequest {
  userId: string;
  newEmail: string;
  password: string;
}

export interface ChangePasswordRequest {
  userId: string;
  currPass: string;
  newPass: string;
}

export interface DeleteAccountRequest {
  userId: string;
  password: string;
}

export interface VerifyNewEmailRequest {
  userId: string;
  email: string;
  otp: string;
}

export interface AdminProfileRequest {
  userId: string;
  email: string;
}

export interface AdminProfileResponse {
  userId: string;
  username: string;
  email: string;
  firstName: string;
  lastName: string;
  avatar: string;
  country: string;
  createdAt: string;
  updatedAt: string;
}

export interface UserDetails {
  userId: string;
  username: string;
  email: string;
  firstName: string;
  lastName: string;
  avatar: string;
  country: string;
  preferredLanguage: string;
  isArchived: boolean;
  easySolved: number;
  mediumSolved: number;
  hardSolved: number;
  totalSubmission: number;
  streak: number;
  createdAt: string;
  updatedAt: string;
  isVerified: boolean;
  authProvider: string;
  isBlocked: boolean;
}

export interface ListUsersRequest {
  page: number;
  limit: number;
  search?: string | undefined;
  sort?: string | undefined;
  authProvider?: string | undefined;
  isArchived?: boolean | undefined;
  isVerified?: boolean | undefined;
  isBlocked?: boolean | undefined;
}

export interface ListUsersResponse {
  users: UserDetails[];
  totalPage: number;
  currentPage: number;
  totalItems: number;
}

export interface BlockUserRequest {
  userId: string;
  block: boolean;
}

export interface UserStatsResponse {
  totalUsers: number;
  todaysUsers: number;
}

function createBaseUserInfo(): UserInfo {
  return { userId: "", firstName: "", username: "", email: "", role: "", avatar: "", country: undefined };
}

export const UserInfo: MessageFns<UserInfo> = {
  encode(message: UserInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.firstName !== "") {
      writer.uint32(18).string(message.firstName);
    }
    if (message.username !== "") {
      writer.uint32(26).string(message.username);
    }
    if (message.email !== "") {
      writer.uint32(34).string(message.email);
    }
    if (message.role !== "") {
      writer.uint32(42).string(message.role);
    }
    if (message.avatar !== "") {
      writer.uint32(50).string(message.avatar);
    }
    if (message.country !== undefined) {
      writer.uint32(58).string(message.country);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.firstName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.role = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.avatar = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.country = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserInfo {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      firstName: isSet(object.firstName) ? globalThis.String(object.firstName) : "",
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      role: isSet(object.role) ? globalThis.String(object.role) : "",
      avatar: isSet(object.avatar) ? globalThis.String(object.avatar) : "",
      country: isSet(object.country) ? globalThis.String(object.country) : undefined,
    };
  },

  toJSON(message: UserInfo): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.firstName !== "") {
      obj.firstName = message.firstName;
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.role !== "") {
      obj.role = message.role;
    }
    if (message.avatar !== "") {
      obj.avatar = message.avatar;
    }
    if (message.country !== undefined) {
      obj.country = message.country;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserInfo>, I>>(base?: I): UserInfo {
    return UserInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserInfo>, I>>(object: I): UserInfo {
    const message = createBaseUserInfo();
    message.userId = object.userId ?? "";
    message.firstName = object.firstName ?? "";
    message.username = object.username ?? "";
    message.email = object.email ?? "";
    message.role = object.role ?? "";
    message.avatar = object.avatar ?? "";
    message.country = object.country ?? undefined;
    return message;
  },
};

function createBaseSignupRequest(): SignupRequest {
  return { username: "", firstName: "", lastName: "", email: "", password: "", country: "" };
}

export const SignupRequest: MessageFns<SignupRequest> = {
  encode(message: SignupRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.username !== "") {
      writer.uint32(10).string(message.username);
    }
    if (message.firstName !== "") {
      writer.uint32(18).string(message.firstName);
    }
    if (message.lastName !== "") {
      writer.uint32(26).string(message.lastName);
    }
    if (message.email !== "") {
      writer.uint32(34).string(message.email);
    }
    if (message.password !== "") {
      writer.uint32(42).string(message.password);
    }
    if (message.country !== "") {
      writer.uint32(50).string(message.country);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SignupRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignupRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.firstName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.lastName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.password = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.country = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignupRequest {
    return {
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      firstName: isSet(object.firstName) ? globalThis.String(object.firstName) : "",
      lastName: isSet(object.lastName) ? globalThis.String(object.lastName) : "",
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      password: isSet(object.password) ? globalThis.String(object.password) : "",
      country: isSet(object.country) ? globalThis.String(object.country) : "",
    };
  },

  toJSON(message: SignupRequest): unknown {
    const obj: any = {};
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.firstName !== "") {
      obj.firstName = message.firstName;
    }
    if (message.lastName !== "") {
      obj.lastName = message.lastName;
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    if (message.country !== "") {
      obj.country = message.country;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SignupRequest>, I>>(base?: I): SignupRequest {
    return SignupRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SignupRequest>, I>>(object: I): SignupRequest {
    const message = createBaseSignupRequest();
    message.username = object.username ?? "";
    message.firstName = object.firstName ?? "";
    message.lastName = object.lastName ?? "";
    message.email = object.email ?? "";
    message.password = object.password ?? "";
    message.country = object.country ?? "";
    return message;
  },
};

function createBaseSignupResponse(): SignupResponse {
  return { message: "" };
}

export const SignupResponse: MessageFns<SignupResponse> = {
  encode(message: SignupResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SignupResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignupResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignupResponse {
    return { message: isSet(object.message) ? globalThis.String(object.message) : "" };
  },

  toJSON(message: SignupResponse): unknown {
    const obj: any = {};
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SignupResponse>, I>>(base?: I): SignupResponse {
    return SignupResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SignupResponse>, I>>(object: I): SignupResponse {
    const message = createBaseSignupResponse();
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseResendOtpRequest(): ResendOtpRequest {
  return { email: "", otpType: "" };
}

export const ResendOtpRequest: MessageFns<ResendOtpRequest> = {
  encode(message: ResendOtpRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    if (message.otpType !== "") {
      writer.uint32(18).string(message.otpType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResendOtpRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResendOtpRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.otpType = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResendOtpRequest {
    return {
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      otpType: isSet(object.otpType) ? globalThis.String(object.otpType) : "",
    };
  },

  toJSON(message: ResendOtpRequest): unknown {
    const obj: any = {};
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.otpType !== "") {
      obj.otpType = message.otpType;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResendOtpRequest>, I>>(base?: I): ResendOtpRequest {
    return ResendOtpRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResendOtpRequest>, I>>(object: I): ResendOtpRequest {
    const message = createBaseResendOtpRequest();
    message.email = object.email ?? "";
    message.otpType = object.otpType ?? "";
    return message;
  },
};

function createBaseResendOtpResponse(): ResendOtpResponse {
  return { message: "" };
}

export const ResendOtpResponse: MessageFns<ResendOtpResponse> = {
  encode(message: ResendOtpResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResendOtpResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResendOtpResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResendOtpResponse {
    return { message: isSet(object.message) ? globalThis.String(object.message) : "" };
  },

  toJSON(message: ResendOtpResponse): unknown {
    const obj: any = {};
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResendOtpResponse>, I>>(base?: I): ResendOtpResponse {
    return ResendOtpResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResendOtpResponse>, I>>(object: I): ResendOtpResponse {
    const message = createBaseResendOtpResponse();
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseVerifyOtpRequest(): VerifyOtpRequest {
  return { email: "", otp: "" };
}

export const VerifyOtpRequest: MessageFns<VerifyOtpRequest> = {
  encode(message: VerifyOtpRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    if (message.otp !== "") {
      writer.uint32(18).string(message.otp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VerifyOtpRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVerifyOtpRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.otp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VerifyOtpRequest {
    return {
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      otp: isSet(object.otp) ? globalThis.String(object.otp) : "",
    };
  },

  toJSON(message: VerifyOtpRequest): unknown {
    const obj: any = {};
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.otp !== "") {
      obj.otp = message.otp;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VerifyOtpRequest>, I>>(base?: I): VerifyOtpRequest {
    return VerifyOtpRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VerifyOtpRequest>, I>>(object: I): VerifyOtpRequest {
    const message = createBaseVerifyOtpRequest();
    message.email = object.email ?? "";
    message.otp = object.otp ?? "";
    return message;
  },
};

function createBaseVerifyOtpResponse(): VerifyOtpResponse {
  return { message: "", accessToken: "", refreshToken: "", userInfo: undefined };
}

export const VerifyOtpResponse: MessageFns<VerifyOtpResponse> = {
  encode(message: VerifyOtpResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    if (message.accessToken !== "") {
      writer.uint32(18).string(message.accessToken);
    }
    if (message.refreshToken !== "") {
      writer.uint32(26).string(message.refreshToken);
    }
    if (message.userInfo !== undefined) {
      UserInfo.encode(message.userInfo, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VerifyOtpResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVerifyOtpResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.refreshToken = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.userInfo = UserInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VerifyOtpResponse {
    return {
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      accessToken: isSet(object.accessToken) ? globalThis.String(object.accessToken) : "",
      refreshToken: isSet(object.refreshToken) ? globalThis.String(object.refreshToken) : "",
      userInfo: isSet(object.userInfo) ? UserInfo.fromJSON(object.userInfo) : undefined,
    };
  },

  toJSON(message: VerifyOtpResponse): unknown {
    const obj: any = {};
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.accessToken !== "") {
      obj.accessToken = message.accessToken;
    }
    if (message.refreshToken !== "") {
      obj.refreshToken = message.refreshToken;
    }
    if (message.userInfo !== undefined) {
      obj.userInfo = UserInfo.toJSON(message.userInfo);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VerifyOtpResponse>, I>>(base?: I): VerifyOtpResponse {
    return VerifyOtpResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VerifyOtpResponse>, I>>(object: I): VerifyOtpResponse {
    const message = createBaseVerifyOtpResponse();
    message.message = object.message ?? "";
    message.accessToken = object.accessToken ?? "";
    message.refreshToken = object.refreshToken ?? "";
    message.userInfo = (object.userInfo !== undefined && object.userInfo !== null)
      ? UserInfo.fromPartial(object.userInfo)
      : undefined;
    return message;
  },
};

function createBaseLoginRequest(): LoginRequest {
  return { email: "", password: "", role: "" };
}

export const LoginRequest: MessageFns<LoginRequest> = {
  encode(message: LoginRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    if (message.password !== "") {
      writer.uint32(18).string(message.password);
    }
    if (message.role !== "") {
      writer.uint32(26).string(message.role);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoginRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoginRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.password = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.role = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoginRequest {
    return {
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      password: isSet(object.password) ? globalThis.String(object.password) : "",
      role: isSet(object.role) ? globalThis.String(object.role) : "",
    };
  },

  toJSON(message: LoginRequest): unknown {
    const obj: any = {};
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    if (message.role !== "") {
      obj.role = message.role;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LoginRequest>, I>>(base?: I): LoginRequest {
    return LoginRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoginRequest>, I>>(object: I): LoginRequest {
    const message = createBaseLoginRequest();
    message.email = object.email ?? "";
    message.password = object.password ?? "";
    message.role = object.role ?? "";
    return message;
  },
};

function createBaseLoginResponse(): LoginResponse {
  return { message: "", accessToken: "", refreshToken: "", userInfo: undefined };
}

export const LoginResponse: MessageFns<LoginResponse> = {
  encode(message: LoginResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    if (message.accessToken !== "") {
      writer.uint32(18).string(message.accessToken);
    }
    if (message.refreshToken !== "") {
      writer.uint32(26).string(message.refreshToken);
    }
    if (message.userInfo !== undefined) {
      UserInfo.encode(message.userInfo, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoginResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoginResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.refreshToken = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.userInfo = UserInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoginResponse {
    return {
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      accessToken: isSet(object.accessToken) ? globalThis.String(object.accessToken) : "",
      refreshToken: isSet(object.refreshToken) ? globalThis.String(object.refreshToken) : "",
      userInfo: isSet(object.userInfo) ? UserInfo.fromJSON(object.userInfo) : undefined,
    };
  },

  toJSON(message: LoginResponse): unknown {
    const obj: any = {};
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.accessToken !== "") {
      obj.accessToken = message.accessToken;
    }
    if (message.refreshToken !== "") {
      obj.refreshToken = message.refreshToken;
    }
    if (message.userInfo !== undefined) {
      obj.userInfo = UserInfo.toJSON(message.userInfo);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LoginResponse>, I>>(base?: I): LoginResponse {
    return LoginResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoginResponse>, I>>(object: I): LoginResponse {
    const message = createBaseLoginResponse();
    message.message = object.message ?? "";
    message.accessToken = object.accessToken ?? "";
    message.refreshToken = object.refreshToken ?? "";
    message.userInfo = (object.userInfo !== undefined && object.userInfo !== null)
      ? UserInfo.fromPartial(object.userInfo)
      : undefined;
    return message;
  },
};

function createBaseOAuthLoginRequest(): OAuthLoginRequest {
  return { email: "", firstName: "", oAuthId: "", avatar: "" };
}

export const OAuthLoginRequest: MessageFns<OAuthLoginRequest> = {
  encode(message: OAuthLoginRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    if (message.firstName !== "") {
      writer.uint32(18).string(message.firstName);
    }
    if (message.oAuthId !== "") {
      writer.uint32(26).string(message.oAuthId);
    }
    if (message.avatar !== "") {
      writer.uint32(42).string(message.avatar);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OAuthLoginRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOAuthLoginRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.firstName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.oAuthId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.avatar = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OAuthLoginRequest {
    return {
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      firstName: isSet(object.firstName) ? globalThis.String(object.firstName) : "",
      oAuthId: isSet(object.oAuthId) ? globalThis.String(object.oAuthId) : "",
      avatar: isSet(object.avatar) ? globalThis.String(object.avatar) : "",
    };
  },

  toJSON(message: OAuthLoginRequest): unknown {
    const obj: any = {};
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.firstName !== "") {
      obj.firstName = message.firstName;
    }
    if (message.oAuthId !== "") {
      obj.oAuthId = message.oAuthId;
    }
    if (message.avatar !== "") {
      obj.avatar = message.avatar;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OAuthLoginRequest>, I>>(base?: I): OAuthLoginRequest {
    return OAuthLoginRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OAuthLoginRequest>, I>>(object: I): OAuthLoginRequest {
    const message = createBaseOAuthLoginRequest();
    message.email = object.email ?? "";
    message.firstName = object.firstName ?? "";
    message.oAuthId = object.oAuthId ?? "";
    message.avatar = object.avatar ?? "";
    return message;
  },
};

function createBaseOAuthLoginResponse(): OAuthLoginResponse {
  return { message: "", accessToken: "", refreshToken: "", userInfo: undefined };
}

export const OAuthLoginResponse: MessageFns<OAuthLoginResponse> = {
  encode(message: OAuthLoginResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    if (message.accessToken !== "") {
      writer.uint32(18).string(message.accessToken);
    }
    if (message.refreshToken !== "") {
      writer.uint32(26).string(message.refreshToken);
    }
    if (message.userInfo !== undefined) {
      UserInfo.encode(message.userInfo, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OAuthLoginResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOAuthLoginResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.refreshToken = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.userInfo = UserInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OAuthLoginResponse {
    return {
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      accessToken: isSet(object.accessToken) ? globalThis.String(object.accessToken) : "",
      refreshToken: isSet(object.refreshToken) ? globalThis.String(object.refreshToken) : "",
      userInfo: isSet(object.userInfo) ? UserInfo.fromJSON(object.userInfo) : undefined,
    };
  },

  toJSON(message: OAuthLoginResponse): unknown {
    const obj: any = {};
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.accessToken !== "") {
      obj.accessToken = message.accessToken;
    }
    if (message.refreshToken !== "") {
      obj.refreshToken = message.refreshToken;
    }
    if (message.userInfo !== undefined) {
      obj.userInfo = UserInfo.toJSON(message.userInfo);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OAuthLoginResponse>, I>>(base?: I): OAuthLoginResponse {
    return OAuthLoginResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OAuthLoginResponse>, I>>(object: I): OAuthLoginResponse {
    const message = createBaseOAuthLoginResponse();
    message.message = object.message ?? "";
    message.accessToken = object.accessToken ?? "";
    message.refreshToken = object.refreshToken ?? "";
    message.userInfo = (object.userInfo !== undefined && object.userInfo !== null)
      ? UserInfo.fromPartial(object.userInfo)
      : undefined;
    return message;
  },
};

function createBaseForgotPasswordRequest(): ForgotPasswordRequest {
  return { email: "" };
}

export const ForgotPasswordRequest: MessageFns<ForgotPasswordRequest> = {
  encode(message: ForgotPasswordRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ForgotPasswordRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseForgotPasswordRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ForgotPasswordRequest {
    return { email: isSet(object.email) ? globalThis.String(object.email) : "" };
  },

  toJSON(message: ForgotPasswordRequest): unknown {
    const obj: any = {};
    if (message.email !== "") {
      obj.email = message.email;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ForgotPasswordRequest>, I>>(base?: I): ForgotPasswordRequest {
    return ForgotPasswordRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ForgotPasswordRequest>, I>>(object: I): ForgotPasswordRequest {
    const message = createBaseForgotPasswordRequest();
    message.email = object.email ?? "";
    return message;
  },
};

function createBaseForgotPasswordResponse(): ForgotPasswordResponse {
  return { message: "" };
}

export const ForgotPasswordResponse: MessageFns<ForgotPasswordResponse> = {
  encode(message: ForgotPasswordResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ForgotPasswordResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseForgotPasswordResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ForgotPasswordResponse {
    return { message: isSet(object.message) ? globalThis.String(object.message) : "" };
  },

  toJSON(message: ForgotPasswordResponse): unknown {
    const obj: any = {};
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ForgotPasswordResponse>, I>>(base?: I): ForgotPasswordResponse {
    return ForgotPasswordResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ForgotPasswordResponse>, I>>(object: I): ForgotPasswordResponse {
    const message = createBaseForgotPasswordResponse();
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseResetPasswordRequest(): ResetPasswordRequest {
  return { email: "", newPassword: "", otp: "" };
}

export const ResetPasswordRequest: MessageFns<ResetPasswordRequest> = {
  encode(message: ResetPasswordRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    if (message.newPassword !== "") {
      writer.uint32(18).string(message.newPassword);
    }
    if (message.otp !== "") {
      writer.uint32(26).string(message.otp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResetPasswordRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResetPasswordRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.newPassword = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.otp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResetPasswordRequest {
    return {
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      newPassword: isSet(object.newPassword) ? globalThis.String(object.newPassword) : "",
      otp: isSet(object.otp) ? globalThis.String(object.otp) : "",
    };
  },

  toJSON(message: ResetPasswordRequest): unknown {
    const obj: any = {};
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.newPassword !== "") {
      obj.newPassword = message.newPassword;
    }
    if (message.otp !== "") {
      obj.otp = message.otp;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResetPasswordRequest>, I>>(base?: I): ResetPasswordRequest {
    return ResetPasswordRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResetPasswordRequest>, I>>(object: I): ResetPasswordRequest {
    const message = createBaseResetPasswordRequest();
    message.email = object.email ?? "";
    message.newPassword = object.newPassword ?? "";
    message.otp = object.otp ?? "";
    return message;
  },
};

function createBaseResetPasswordResponse(): ResetPasswordResponse {
  return { message: "" };
}

export const ResetPasswordResponse: MessageFns<ResetPasswordResponse> = {
  encode(message: ResetPasswordResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResetPasswordResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResetPasswordResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResetPasswordResponse {
    return { message: isSet(object.message) ? globalThis.String(object.message) : "" };
  },

  toJSON(message: ResetPasswordResponse): unknown {
    const obj: any = {};
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResetPasswordResponse>, I>>(base?: I): ResetPasswordResponse {
    return ResetPasswordResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResetPasswordResponse>, I>>(object: I): ResetPasswordResponse {
    const message = createBaseResetPasswordResponse();
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseUserProfileRequest(): UserProfileRequest {
  return { userId: "", email: "" };
}

export const UserProfileRequest: MessageFns<UserProfileRequest> = {
  encode(message: UserProfileRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.email !== "") {
      writer.uint32(18).string(message.email);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserProfileRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserProfileRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.email = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserProfileRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      email: isSet(object.email) ? globalThis.String(object.email) : "",
    };
  },

  toJSON(message: UserProfileRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserProfileRequest>, I>>(base?: I): UserProfileRequest {
    return UserProfileRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserProfileRequest>, I>>(object: I): UserProfileRequest {
    const message = createBaseUserProfileRequest();
    message.userId = object.userId ?? "";
    message.email = object.email ?? "";
    return message;
  },
};

function createBaseUserProfileResponse(): UserProfileResponse {
  return {
    userId: "",
    username: "",
    email: "",
    firstName: "",
    lastName: "",
    avatar: "",
    country: "",
    preferredLanguage: "",
    easySolved: 0,
    mediumSolved: 0,
    hardSolved: 0,
    totalSubmission: 0,
    streak: 0,
    createdAt: "",
    updatedAt: "",
  };
}

export const UserProfileResponse: MessageFns<UserProfileResponse> = {
  encode(message: UserProfileResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.username !== "") {
      writer.uint32(18).string(message.username);
    }
    if (message.email !== "") {
      writer.uint32(26).string(message.email);
    }
    if (message.firstName !== "") {
      writer.uint32(34).string(message.firstName);
    }
    if (message.lastName !== "") {
      writer.uint32(42).string(message.lastName);
    }
    if (message.avatar !== "") {
      writer.uint32(50).string(message.avatar);
    }
    if (message.country !== "") {
      writer.uint32(58).string(message.country);
    }
    if (message.preferredLanguage !== "") {
      writer.uint32(66).string(message.preferredLanguage);
    }
    if (message.easySolved !== 0) {
      writer.uint32(72).int32(message.easySolved);
    }
    if (message.mediumSolved !== 0) {
      writer.uint32(80).int32(message.mediumSolved);
    }
    if (message.hardSolved !== 0) {
      writer.uint32(88).int32(message.hardSolved);
    }
    if (message.totalSubmission !== 0) {
      writer.uint32(96).int32(message.totalSubmission);
    }
    if (message.streak !== 0) {
      writer.uint32(104).int32(message.streak);
    }
    if (message.createdAt !== "") {
      writer.uint32(114).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(122).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserProfileResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserProfileResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.firstName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.lastName = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.avatar = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.country = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.preferredLanguage = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.easySolved = reader.int32();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.mediumSolved = reader.int32();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.hardSolved = reader.int32();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.totalSubmission = reader.int32();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.streak = reader.int32();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserProfileResponse {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      firstName: isSet(object.firstName) ? globalThis.String(object.firstName) : "",
      lastName: isSet(object.lastName) ? globalThis.String(object.lastName) : "",
      avatar: isSet(object.avatar) ? globalThis.String(object.avatar) : "",
      country: isSet(object.country) ? globalThis.String(object.country) : "",
      preferredLanguage: isSet(object.preferredLanguage) ? globalThis.String(object.preferredLanguage) : "",
      easySolved: isSet(object.easySolved) ? globalThis.Number(object.easySolved) : 0,
      mediumSolved: isSet(object.mediumSolved) ? globalThis.Number(object.mediumSolved) : 0,
      hardSolved: isSet(object.hardSolved) ? globalThis.Number(object.hardSolved) : 0,
      totalSubmission: isSet(object.totalSubmission) ? globalThis.Number(object.totalSubmission) : 0,
      streak: isSet(object.streak) ? globalThis.Number(object.streak) : 0,
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
      updatedAt: isSet(object.updatedAt) ? globalThis.String(object.updatedAt) : "",
    };
  },

  toJSON(message: UserProfileResponse): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.firstName !== "") {
      obj.firstName = message.firstName;
    }
    if (message.lastName !== "") {
      obj.lastName = message.lastName;
    }
    if (message.avatar !== "") {
      obj.avatar = message.avatar;
    }
    if (message.country !== "") {
      obj.country = message.country;
    }
    if (message.preferredLanguage !== "") {
      obj.preferredLanguage = message.preferredLanguage;
    }
    if (message.easySolved !== 0) {
      obj.easySolved = Math.round(message.easySolved);
    }
    if (message.mediumSolved !== 0) {
      obj.mediumSolved = Math.round(message.mediumSolved);
    }
    if (message.hardSolved !== 0) {
      obj.hardSolved = Math.round(message.hardSolved);
    }
    if (message.totalSubmission !== 0) {
      obj.totalSubmission = Math.round(message.totalSubmission);
    }
    if (message.streak !== 0) {
      obj.streak = Math.round(message.streak);
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserProfileResponse>, I>>(base?: I): UserProfileResponse {
    return UserProfileResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserProfileResponse>, I>>(object: I): UserProfileResponse {
    const message = createBaseUserProfileResponse();
    message.userId = object.userId ?? "";
    message.username = object.username ?? "";
    message.email = object.email ?? "";
    message.firstName = object.firstName ?? "";
    message.lastName = object.lastName ?? "";
    message.avatar = object.avatar ?? "";
    message.country = object.country ?? "";
    message.preferredLanguage = object.preferredLanguage ?? "";
    message.easySolved = object.easySolved ?? 0;
    message.mediumSolved = object.mediumSolved ?? 0;
    message.hardSolved = object.hardSolved ?? 0;
    message.totalSubmission = object.totalSubmission ?? 0;
    message.streak = object.streak ?? 0;
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? "";
    return message;
  },
};

function createBaseRefreshTokenRequest(): RefreshTokenRequest {
  return { userId: "", username: "", email: "", role: "" };
}

export const RefreshTokenRequest: MessageFns<RefreshTokenRequest> = {
  encode(message: RefreshTokenRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.username !== "") {
      writer.uint32(18).string(message.username);
    }
    if (message.email !== "") {
      writer.uint32(26).string(message.email);
    }
    if (message.role !== "") {
      writer.uint32(34).string(message.role);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RefreshTokenRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRefreshTokenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.role = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RefreshTokenRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      role: isSet(object.role) ? globalThis.String(object.role) : "",
    };
  },

  toJSON(message: RefreshTokenRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.role !== "") {
      obj.role = message.role;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RefreshTokenRequest>, I>>(base?: I): RefreshTokenRequest {
    return RefreshTokenRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RefreshTokenRequest>, I>>(object: I): RefreshTokenRequest {
    const message = createBaseRefreshTokenRequest();
    message.userId = object.userId ?? "";
    message.username = object.username ?? "";
    message.email = object.email ?? "";
    message.role = object.role ?? "";
    return message;
  },
};

function createBaseRefreshTokenResponse(): RefreshTokenResponse {
  return { message: "", accessToken: "", userInfo: undefined };
}

export const RefreshTokenResponse: MessageFns<RefreshTokenResponse> = {
  encode(message: RefreshTokenResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    if (message.accessToken !== "") {
      writer.uint32(18).string(message.accessToken);
    }
    if (message.userInfo !== undefined) {
      UserInfo.encode(message.userInfo, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RefreshTokenResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRefreshTokenResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.userInfo = UserInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RefreshTokenResponse {
    return {
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      accessToken: isSet(object.accessToken) ? globalThis.String(object.accessToken) : "",
      userInfo: isSet(object.userInfo) ? UserInfo.fromJSON(object.userInfo) : undefined,
    };
  },

  toJSON(message: RefreshTokenResponse): unknown {
    const obj: any = {};
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.accessToken !== "") {
      obj.accessToken = message.accessToken;
    }
    if (message.userInfo !== undefined) {
      obj.userInfo = UserInfo.toJSON(message.userInfo);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RefreshTokenResponse>, I>>(base?: I): RefreshTokenResponse {
    return RefreshTokenResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RefreshTokenResponse>, I>>(object: I): RefreshTokenResponse {
    const message = createBaseRefreshTokenResponse();
    message.message = object.message ?? "";
    message.accessToken = object.accessToken ?? "";
    message.userInfo = (object.userInfo !== undefined && object.userInfo !== null)
      ? UserInfo.fromPartial(object.userInfo)
      : undefined;
    return message;
  },
};

function createBaseUpdateProfileRequest(): UpdateProfileRequest {
  return {
    userId: "",
    username: undefined,
    firstName: undefined,
    lastName: undefined,
    country: undefined,
    preferredLanguage: undefined,
    avatar: undefined,
  };
}

export const UpdateProfileRequest: MessageFns<UpdateProfileRequest> = {
  encode(message: UpdateProfileRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.username !== undefined) {
      writer.uint32(18).string(message.username);
    }
    if (message.firstName !== undefined) {
      writer.uint32(26).string(message.firstName);
    }
    if (message.lastName !== undefined) {
      writer.uint32(34).string(message.lastName);
    }
    if (message.country !== undefined) {
      writer.uint32(42).string(message.country);
    }
    if (message.preferredLanguage !== undefined) {
      writer.uint32(50).string(message.preferredLanguage);
    }
    if (message.avatar !== undefined) {
      writer.uint32(58).string(message.avatar);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateProfileRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateProfileRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.firstName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.lastName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.country = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.preferredLanguage = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.avatar = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateProfileRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      username: isSet(object.username) ? globalThis.String(object.username) : undefined,
      firstName: isSet(object.firstName) ? globalThis.String(object.firstName) : undefined,
      lastName: isSet(object.lastName) ? globalThis.String(object.lastName) : undefined,
      country: isSet(object.country) ? globalThis.String(object.country) : undefined,
      preferredLanguage: isSet(object.preferredLanguage) ? globalThis.String(object.preferredLanguage) : undefined,
      avatar: isSet(object.avatar) ? globalThis.String(object.avatar) : undefined,
    };
  },

  toJSON(message: UpdateProfileRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.username !== undefined) {
      obj.username = message.username;
    }
    if (message.firstName !== undefined) {
      obj.firstName = message.firstName;
    }
    if (message.lastName !== undefined) {
      obj.lastName = message.lastName;
    }
    if (message.country !== undefined) {
      obj.country = message.country;
    }
    if (message.preferredLanguage !== undefined) {
      obj.preferredLanguage = message.preferredLanguage;
    }
    if (message.avatar !== undefined) {
      obj.avatar = message.avatar;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateProfileRequest>, I>>(base?: I): UpdateProfileRequest {
    return UpdateProfileRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateProfileRequest>, I>>(object: I): UpdateProfileRequest {
    const message = createBaseUpdateProfileRequest();
    message.userId = object.userId ?? "";
    message.username = object.username ?? undefined;
    message.firstName = object.firstName ?? undefined;
    message.lastName = object.lastName ?? undefined;
    message.country = object.country ?? undefined;
    message.preferredLanguage = object.preferredLanguage ?? undefined;
    message.avatar = object.avatar ?? undefined;
    return message;
  },
};

function createBaseUpdatedData(): UpdatedData {
  return {
    username: undefined,
    firstName: undefined,
    lastName: undefined,
    avatar: undefined,
    email: undefined,
    country: undefined,
    password: undefined,
    isVerified: undefined,
    isArchived: undefined,
    isBlocked: undefined,
    preferredLanguage: undefined,
    easySolved: undefined,
    mediumSolved: undefined,
    hardSolved: undefined,
    totalSubmission: undefined,
    streak: undefined,
    updatedAt: undefined,
  };
}

export const UpdatedData: MessageFns<UpdatedData> = {
  encode(message: UpdatedData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.username !== undefined) {
      writer.uint32(10).string(message.username);
    }
    if (message.firstName !== undefined) {
      writer.uint32(18).string(message.firstName);
    }
    if (message.lastName !== undefined) {
      writer.uint32(26).string(message.lastName);
    }
    if (message.avatar !== undefined) {
      writer.uint32(34).string(message.avatar);
    }
    if (message.email !== undefined) {
      writer.uint32(42).string(message.email);
    }
    if (message.country !== undefined) {
      writer.uint32(50).string(message.country);
    }
    if (message.password !== undefined) {
      writer.uint32(58).string(message.password);
    }
    if (message.isVerified !== undefined) {
      writer.uint32(64).bool(message.isVerified);
    }
    if (message.isArchived !== undefined) {
      writer.uint32(72).bool(message.isArchived);
    }
    if (message.isBlocked !== undefined) {
      writer.uint32(80).bool(message.isBlocked);
    }
    if (message.preferredLanguage !== undefined) {
      writer.uint32(90).string(message.preferredLanguage);
    }
    if (message.easySolved !== undefined) {
      writer.uint32(96).int32(message.easySolved);
    }
    if (message.mediumSolved !== undefined) {
      writer.uint32(104).int32(message.mediumSolved);
    }
    if (message.hardSolved !== undefined) {
      writer.uint32(112).int32(message.hardSolved);
    }
    if (message.totalSubmission !== undefined) {
      writer.uint32(120).int32(message.totalSubmission);
    }
    if (message.streak !== undefined) {
      writer.uint32(128).int32(message.streak);
    }
    if (message.updatedAt !== undefined) {
      writer.uint32(138).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdatedData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdatedData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.firstName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.lastName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.avatar = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.country = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.password = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.isVerified = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.isArchived = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.isBlocked = reader.bool();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.preferredLanguage = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.easySolved = reader.int32();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.mediumSolved = reader.int32();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.hardSolved = reader.int32();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.totalSubmission = reader.int32();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.streak = reader.int32();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdatedData {
    return {
      username: isSet(object.username) ? globalThis.String(object.username) : undefined,
      firstName: isSet(object.firstName) ? globalThis.String(object.firstName) : undefined,
      lastName: isSet(object.lastName) ? globalThis.String(object.lastName) : undefined,
      avatar: isSet(object.avatar) ? globalThis.String(object.avatar) : undefined,
      email: isSet(object.email) ? globalThis.String(object.email) : undefined,
      country: isSet(object.country) ? globalThis.String(object.country) : undefined,
      password: isSet(object.password) ? globalThis.String(object.password) : undefined,
      isVerified: isSet(object.isVerified) ? globalThis.Boolean(object.isVerified) : undefined,
      isArchived: isSet(object.isArchived) ? globalThis.Boolean(object.isArchived) : undefined,
      isBlocked: isSet(object.isBlocked) ? globalThis.Boolean(object.isBlocked) : undefined,
      preferredLanguage: isSet(object.preferredLanguage) ? globalThis.String(object.preferredLanguage) : undefined,
      easySolved: isSet(object.easySolved) ? globalThis.Number(object.easySolved) : undefined,
      mediumSolved: isSet(object.mediumSolved) ? globalThis.Number(object.mediumSolved) : undefined,
      hardSolved: isSet(object.hardSolved) ? globalThis.Number(object.hardSolved) : undefined,
      totalSubmission: isSet(object.totalSubmission) ? globalThis.Number(object.totalSubmission) : undefined,
      streak: isSet(object.streak) ? globalThis.Number(object.streak) : undefined,
      updatedAt: isSet(object.updatedAt) ? globalThis.String(object.updatedAt) : undefined,
    };
  },

  toJSON(message: UpdatedData): unknown {
    const obj: any = {};
    if (message.username !== undefined) {
      obj.username = message.username;
    }
    if (message.firstName !== undefined) {
      obj.firstName = message.firstName;
    }
    if (message.lastName !== undefined) {
      obj.lastName = message.lastName;
    }
    if (message.avatar !== undefined) {
      obj.avatar = message.avatar;
    }
    if (message.email !== undefined) {
      obj.email = message.email;
    }
    if (message.country !== undefined) {
      obj.country = message.country;
    }
    if (message.password !== undefined) {
      obj.password = message.password;
    }
    if (message.isVerified !== undefined) {
      obj.isVerified = message.isVerified;
    }
    if (message.isArchived !== undefined) {
      obj.isArchived = message.isArchived;
    }
    if (message.isBlocked !== undefined) {
      obj.isBlocked = message.isBlocked;
    }
    if (message.preferredLanguage !== undefined) {
      obj.preferredLanguage = message.preferredLanguage;
    }
    if (message.easySolved !== undefined) {
      obj.easySolved = Math.round(message.easySolved);
    }
    if (message.mediumSolved !== undefined) {
      obj.mediumSolved = Math.round(message.mediumSolved);
    }
    if (message.hardSolved !== undefined) {
      obj.hardSolved = Math.round(message.hardSolved);
    }
    if (message.totalSubmission !== undefined) {
      obj.totalSubmission = Math.round(message.totalSubmission);
    }
    if (message.streak !== undefined) {
      obj.streak = Math.round(message.streak);
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdatedData>, I>>(base?: I): UpdatedData {
    return UpdatedData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdatedData>, I>>(object: I): UpdatedData {
    const message = createBaseUpdatedData();
    message.username = object.username ?? undefined;
    message.firstName = object.firstName ?? undefined;
    message.lastName = object.lastName ?? undefined;
    message.avatar = object.avatar ?? undefined;
    message.email = object.email ?? undefined;
    message.country = object.country ?? undefined;
    message.password = object.password ?? undefined;
    message.isVerified = object.isVerified ?? undefined;
    message.isArchived = object.isArchived ?? undefined;
    message.isBlocked = object.isBlocked ?? undefined;
    message.preferredLanguage = object.preferredLanguage ?? undefined;
    message.easySolved = object.easySolved ?? undefined;
    message.mediumSolved = object.mediumSolved ?? undefined;
    message.hardSolved = object.hardSolved ?? undefined;
    message.totalSubmission = object.totalSubmission ?? undefined;
    message.streak = object.streak ?? undefined;
    message.updatedAt = object.updatedAt ?? undefined;
    return message;
  },
};

function createBaseUpdateProfileResponse(): UpdateProfileResponse {
  return { message: "", updatedData: undefined };
}

export const UpdateProfileResponse: MessageFns<UpdateProfileResponse> = {
  encode(message: UpdateProfileResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    if (message.updatedData !== undefined) {
      UpdatedData.encode(message.updatedData, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateProfileResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateProfileResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.updatedData = UpdatedData.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateProfileResponse {
    return {
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      updatedData: isSet(object.updatedData) ? UpdatedData.fromJSON(object.updatedData) : undefined,
    };
  },

  toJSON(message: UpdateProfileResponse): unknown {
    const obj: any = {};
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.updatedData !== undefined) {
      obj.updatedData = UpdatedData.toJSON(message.updatedData);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateProfileResponse>, I>>(base?: I): UpdateProfileResponse {
    return UpdateProfileResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateProfileResponse>, I>>(object: I): UpdateProfileResponse {
    const message = createBaseUpdateProfileResponse();
    message.message = object.message ?? "";
    message.updatedData = (object.updatedData !== undefined && object.updatedData !== null)
      ? UpdatedData.fromPartial(object.updatedData)
      : undefined;
    return message;
  },
};

function createBaseChangeEmailRequest(): ChangeEmailRequest {
  return { userId: "", newEmail: "", password: "" };
}

export const ChangeEmailRequest: MessageFns<ChangeEmailRequest> = {
  encode(message: ChangeEmailRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.newEmail !== "") {
      writer.uint32(18).string(message.newEmail);
    }
    if (message.password !== "") {
      writer.uint32(26).string(message.password);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChangeEmailRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChangeEmailRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.newEmail = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.password = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChangeEmailRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      newEmail: isSet(object.newEmail) ? globalThis.String(object.newEmail) : "",
      password: isSet(object.password) ? globalThis.String(object.password) : "",
    };
  },

  toJSON(message: ChangeEmailRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.newEmail !== "") {
      obj.newEmail = message.newEmail;
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChangeEmailRequest>, I>>(base?: I): ChangeEmailRequest {
    return ChangeEmailRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChangeEmailRequest>, I>>(object: I): ChangeEmailRequest {
    const message = createBaseChangeEmailRequest();
    message.userId = object.userId ?? "";
    message.newEmail = object.newEmail ?? "";
    message.password = object.password ?? "";
    return message;
  },
};

function createBaseChangePasswordRequest(): ChangePasswordRequest {
  return { userId: "", currPass: "", newPass: "" };
}

export const ChangePasswordRequest: MessageFns<ChangePasswordRequest> = {
  encode(message: ChangePasswordRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.currPass !== "") {
      writer.uint32(18).string(message.currPass);
    }
    if (message.newPass !== "") {
      writer.uint32(26).string(message.newPass);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChangePasswordRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChangePasswordRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.currPass = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.newPass = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChangePasswordRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      currPass: isSet(object.currPass) ? globalThis.String(object.currPass) : "",
      newPass: isSet(object.newPass) ? globalThis.String(object.newPass) : "",
    };
  },

  toJSON(message: ChangePasswordRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.currPass !== "") {
      obj.currPass = message.currPass;
    }
    if (message.newPass !== "") {
      obj.newPass = message.newPass;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChangePasswordRequest>, I>>(base?: I): ChangePasswordRequest {
    return ChangePasswordRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChangePasswordRequest>, I>>(object: I): ChangePasswordRequest {
    const message = createBaseChangePasswordRequest();
    message.userId = object.userId ?? "";
    message.currPass = object.currPass ?? "";
    message.newPass = object.newPass ?? "";
    return message;
  },
};

function createBaseDeleteAccountRequest(): DeleteAccountRequest {
  return { userId: "", password: "" };
}

export const DeleteAccountRequest: MessageFns<DeleteAccountRequest> = {
  encode(message: DeleteAccountRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.password !== "") {
      writer.uint32(18).string(message.password);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteAccountRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteAccountRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.password = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteAccountRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      password: isSet(object.password) ? globalThis.String(object.password) : "",
    };
  },

  toJSON(message: DeleteAccountRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteAccountRequest>, I>>(base?: I): DeleteAccountRequest {
    return DeleteAccountRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteAccountRequest>, I>>(object: I): DeleteAccountRequest {
    const message = createBaseDeleteAccountRequest();
    message.userId = object.userId ?? "";
    message.password = object.password ?? "";
    return message;
  },
};

function createBaseVerifyNewEmailRequest(): VerifyNewEmailRequest {
  return { userId: "", email: "", otp: "" };
}

export const VerifyNewEmailRequest: MessageFns<VerifyNewEmailRequest> = {
  encode(message: VerifyNewEmailRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.email !== "") {
      writer.uint32(18).string(message.email);
    }
    if (message.otp !== "") {
      writer.uint32(26).string(message.otp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VerifyNewEmailRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVerifyNewEmailRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.otp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VerifyNewEmailRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      otp: isSet(object.otp) ? globalThis.String(object.otp) : "",
    };
  },

  toJSON(message: VerifyNewEmailRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.otp !== "") {
      obj.otp = message.otp;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VerifyNewEmailRequest>, I>>(base?: I): VerifyNewEmailRequest {
    return VerifyNewEmailRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VerifyNewEmailRequest>, I>>(object: I): VerifyNewEmailRequest {
    const message = createBaseVerifyNewEmailRequest();
    message.userId = object.userId ?? "";
    message.email = object.email ?? "";
    message.otp = object.otp ?? "";
    return message;
  },
};

function createBaseAdminProfileRequest(): AdminProfileRequest {
  return { userId: "", email: "" };
}

export const AdminProfileRequest: MessageFns<AdminProfileRequest> = {
  encode(message: AdminProfileRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.email !== "") {
      writer.uint32(18).string(message.email);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AdminProfileRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAdminProfileRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.email = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AdminProfileRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      email: isSet(object.email) ? globalThis.String(object.email) : "",
    };
  },

  toJSON(message: AdminProfileRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AdminProfileRequest>, I>>(base?: I): AdminProfileRequest {
    return AdminProfileRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AdminProfileRequest>, I>>(object: I): AdminProfileRequest {
    const message = createBaseAdminProfileRequest();
    message.userId = object.userId ?? "";
    message.email = object.email ?? "";
    return message;
  },
};

function createBaseAdminProfileResponse(): AdminProfileResponse {
  return {
    userId: "",
    username: "",
    email: "",
    firstName: "",
    lastName: "",
    avatar: "",
    country: "",
    createdAt: "",
    updatedAt: "",
  };
}

export const AdminProfileResponse: MessageFns<AdminProfileResponse> = {
  encode(message: AdminProfileResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.username !== "") {
      writer.uint32(18).string(message.username);
    }
    if (message.email !== "") {
      writer.uint32(26).string(message.email);
    }
    if (message.firstName !== "") {
      writer.uint32(34).string(message.firstName);
    }
    if (message.lastName !== "") {
      writer.uint32(42).string(message.lastName);
    }
    if (message.avatar !== "") {
      writer.uint32(50).string(message.avatar);
    }
    if (message.country !== "") {
      writer.uint32(58).string(message.country);
    }
    if (message.createdAt !== "") {
      writer.uint32(66).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(74).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AdminProfileResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAdminProfileResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.firstName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.lastName = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.avatar = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.country = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AdminProfileResponse {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      firstName: isSet(object.firstName) ? globalThis.String(object.firstName) : "",
      lastName: isSet(object.lastName) ? globalThis.String(object.lastName) : "",
      avatar: isSet(object.avatar) ? globalThis.String(object.avatar) : "",
      country: isSet(object.country) ? globalThis.String(object.country) : "",
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
      updatedAt: isSet(object.updatedAt) ? globalThis.String(object.updatedAt) : "",
    };
  },

  toJSON(message: AdminProfileResponse): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.firstName !== "") {
      obj.firstName = message.firstName;
    }
    if (message.lastName !== "") {
      obj.lastName = message.lastName;
    }
    if (message.avatar !== "") {
      obj.avatar = message.avatar;
    }
    if (message.country !== "") {
      obj.country = message.country;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AdminProfileResponse>, I>>(base?: I): AdminProfileResponse {
    return AdminProfileResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AdminProfileResponse>, I>>(object: I): AdminProfileResponse {
    const message = createBaseAdminProfileResponse();
    message.userId = object.userId ?? "";
    message.username = object.username ?? "";
    message.email = object.email ?? "";
    message.firstName = object.firstName ?? "";
    message.lastName = object.lastName ?? "";
    message.avatar = object.avatar ?? "";
    message.country = object.country ?? "";
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? "";
    return message;
  },
};

function createBaseUserDetails(): UserDetails {
  return {
    userId: "",
    username: "",
    email: "",
    firstName: "",
    lastName: "",
    avatar: "",
    country: "",
    preferredLanguage: "",
    isArchived: false,
    easySolved: 0,
    mediumSolved: 0,
    hardSolved: 0,
    totalSubmission: 0,
    streak: 0,
    createdAt: "",
    updatedAt: "",
    isVerified: false,
    authProvider: "",
    isBlocked: false,
  };
}

export const UserDetails: MessageFns<UserDetails> = {
  encode(message: UserDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.username !== "") {
      writer.uint32(18).string(message.username);
    }
    if (message.email !== "") {
      writer.uint32(26).string(message.email);
    }
    if (message.firstName !== "") {
      writer.uint32(34).string(message.firstName);
    }
    if (message.lastName !== "") {
      writer.uint32(42).string(message.lastName);
    }
    if (message.avatar !== "") {
      writer.uint32(50).string(message.avatar);
    }
    if (message.country !== "") {
      writer.uint32(58).string(message.country);
    }
    if (message.preferredLanguage !== "") {
      writer.uint32(66).string(message.preferredLanguage);
    }
    if (message.isArchived !== false) {
      writer.uint32(72).bool(message.isArchived);
    }
    if (message.easySolved !== 0) {
      writer.uint32(80).int32(message.easySolved);
    }
    if (message.mediumSolved !== 0) {
      writer.uint32(88).int32(message.mediumSolved);
    }
    if (message.hardSolved !== 0) {
      writer.uint32(96).int32(message.hardSolved);
    }
    if (message.totalSubmission !== 0) {
      writer.uint32(104).int32(message.totalSubmission);
    }
    if (message.streak !== 0) {
      writer.uint32(112).int32(message.streak);
    }
    if (message.createdAt !== "") {
      writer.uint32(122).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(130).string(message.updatedAt);
    }
    if (message.isVerified !== false) {
      writer.uint32(136).bool(message.isVerified);
    }
    if (message.authProvider !== "") {
      writer.uint32(146).string(message.authProvider);
    }
    if (message.isBlocked !== false) {
      writer.uint32(152).bool(message.isBlocked);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.firstName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.lastName = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.avatar = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.country = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.preferredLanguage = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.isArchived = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.easySolved = reader.int32();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.mediumSolved = reader.int32();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.hardSolved = reader.int32();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.totalSubmission = reader.int32();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.streak = reader.int32();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.isVerified = reader.bool();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.authProvider = reader.string();
          continue;
        }
        case 19: {
          if (tag !== 152) {
            break;
          }

          message.isBlocked = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserDetails {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      firstName: isSet(object.firstName) ? globalThis.String(object.firstName) : "",
      lastName: isSet(object.lastName) ? globalThis.String(object.lastName) : "",
      avatar: isSet(object.avatar) ? globalThis.String(object.avatar) : "",
      country: isSet(object.country) ? globalThis.String(object.country) : "",
      preferredLanguage: isSet(object.preferredLanguage) ? globalThis.String(object.preferredLanguage) : "",
      isArchived: isSet(object.isArchived) ? globalThis.Boolean(object.isArchived) : false,
      easySolved: isSet(object.easySolved) ? globalThis.Number(object.easySolved) : 0,
      mediumSolved: isSet(object.mediumSolved) ? globalThis.Number(object.mediumSolved) : 0,
      hardSolved: isSet(object.hardSolved) ? globalThis.Number(object.hardSolved) : 0,
      totalSubmission: isSet(object.totalSubmission) ? globalThis.Number(object.totalSubmission) : 0,
      streak: isSet(object.streak) ? globalThis.Number(object.streak) : 0,
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
      updatedAt: isSet(object.updatedAt) ? globalThis.String(object.updatedAt) : "",
      isVerified: isSet(object.isVerified) ? globalThis.Boolean(object.isVerified) : false,
      authProvider: isSet(object.authProvider) ? globalThis.String(object.authProvider) : "",
      isBlocked: isSet(object.isBlocked) ? globalThis.Boolean(object.isBlocked) : false,
    };
  },

  toJSON(message: UserDetails): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.firstName !== "") {
      obj.firstName = message.firstName;
    }
    if (message.lastName !== "") {
      obj.lastName = message.lastName;
    }
    if (message.avatar !== "") {
      obj.avatar = message.avatar;
    }
    if (message.country !== "") {
      obj.country = message.country;
    }
    if (message.preferredLanguage !== "") {
      obj.preferredLanguage = message.preferredLanguage;
    }
    if (message.isArchived !== false) {
      obj.isArchived = message.isArchived;
    }
    if (message.easySolved !== 0) {
      obj.easySolved = Math.round(message.easySolved);
    }
    if (message.mediumSolved !== 0) {
      obj.mediumSolved = Math.round(message.mediumSolved);
    }
    if (message.hardSolved !== 0) {
      obj.hardSolved = Math.round(message.hardSolved);
    }
    if (message.totalSubmission !== 0) {
      obj.totalSubmission = Math.round(message.totalSubmission);
    }
    if (message.streak !== 0) {
      obj.streak = Math.round(message.streak);
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    if (message.isVerified !== false) {
      obj.isVerified = message.isVerified;
    }
    if (message.authProvider !== "") {
      obj.authProvider = message.authProvider;
    }
    if (message.isBlocked !== false) {
      obj.isBlocked = message.isBlocked;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserDetails>, I>>(base?: I): UserDetails {
    return UserDetails.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserDetails>, I>>(object: I): UserDetails {
    const message = createBaseUserDetails();
    message.userId = object.userId ?? "";
    message.username = object.username ?? "";
    message.email = object.email ?? "";
    message.firstName = object.firstName ?? "";
    message.lastName = object.lastName ?? "";
    message.avatar = object.avatar ?? "";
    message.country = object.country ?? "";
    message.preferredLanguage = object.preferredLanguage ?? "";
    message.isArchived = object.isArchived ?? false;
    message.easySolved = object.easySolved ?? 0;
    message.mediumSolved = object.mediumSolved ?? 0;
    message.hardSolved = object.hardSolved ?? 0;
    message.totalSubmission = object.totalSubmission ?? 0;
    message.streak = object.streak ?? 0;
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? "";
    message.isVerified = object.isVerified ?? false;
    message.authProvider = object.authProvider ?? "";
    message.isBlocked = object.isBlocked ?? false;
    return message;
  },
};

function createBaseListUsersRequest(): ListUsersRequest {
  return {
    page: 0,
    limit: 0,
    search: undefined,
    sort: undefined,
    authProvider: undefined,
    isArchived: undefined,
    isVerified: undefined,
    isBlocked: undefined,
  };
}

export const ListUsersRequest: MessageFns<ListUsersRequest> = {
  encode(message: ListUsersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.page !== 0) {
      writer.uint32(8).int32(message.page);
    }
    if (message.limit !== 0) {
      writer.uint32(16).int32(message.limit);
    }
    if (message.search !== undefined) {
      writer.uint32(26).string(message.search);
    }
    if (message.sort !== undefined) {
      writer.uint32(34).string(message.sort);
    }
    if (message.authProvider !== undefined) {
      writer.uint32(42).string(message.authProvider);
    }
    if (message.isArchived !== undefined) {
      writer.uint32(48).bool(message.isArchived);
    }
    if (message.isVerified !== undefined) {
      writer.uint32(56).bool(message.isVerified);
    }
    if (message.isBlocked !== undefined) {
      writer.uint32(64).bool(message.isBlocked);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListUsersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListUsersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.search = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.sort = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.authProvider = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.isArchived = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.isVerified = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.isBlocked = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListUsersRequest {
    return {
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
      search: isSet(object.search) ? globalThis.String(object.search) : undefined,
      sort: isSet(object.sort) ? globalThis.String(object.sort) : undefined,
      authProvider: isSet(object.authProvider) ? globalThis.String(object.authProvider) : undefined,
      isArchived: isSet(object.isArchived) ? globalThis.Boolean(object.isArchived) : undefined,
      isVerified: isSet(object.isVerified) ? globalThis.Boolean(object.isVerified) : undefined,
      isBlocked: isSet(object.isBlocked) ? globalThis.Boolean(object.isBlocked) : undefined,
    };
  },

  toJSON(message: ListUsersRequest): unknown {
    const obj: any = {};
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    if (message.search !== undefined) {
      obj.search = message.search;
    }
    if (message.sort !== undefined) {
      obj.sort = message.sort;
    }
    if (message.authProvider !== undefined) {
      obj.authProvider = message.authProvider;
    }
    if (message.isArchived !== undefined) {
      obj.isArchived = message.isArchived;
    }
    if (message.isVerified !== undefined) {
      obj.isVerified = message.isVerified;
    }
    if (message.isBlocked !== undefined) {
      obj.isBlocked = message.isBlocked;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListUsersRequest>, I>>(base?: I): ListUsersRequest {
    return ListUsersRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListUsersRequest>, I>>(object: I): ListUsersRequest {
    const message = createBaseListUsersRequest();
    message.page = object.page ?? 0;
    message.limit = object.limit ?? 0;
    message.search = object.search ?? undefined;
    message.sort = object.sort ?? undefined;
    message.authProvider = object.authProvider ?? undefined;
    message.isArchived = object.isArchived ?? undefined;
    message.isVerified = object.isVerified ?? undefined;
    message.isBlocked = object.isBlocked ?? undefined;
    return message;
  },
};

function createBaseListUsersResponse(): ListUsersResponse {
  return { users: [], totalPage: 0, currentPage: 0, totalItems: 0 };
}

export const ListUsersResponse: MessageFns<ListUsersResponse> = {
  encode(message: ListUsersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.users) {
      UserDetails.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.totalPage !== 0) {
      writer.uint32(16).int32(message.totalPage);
    }
    if (message.currentPage !== 0) {
      writer.uint32(24).int32(message.currentPage);
    }
    if (message.totalItems !== 0) {
      writer.uint32(32).int32(message.totalItems);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListUsersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListUsersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.users.push(UserDetails.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.totalPage = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.currentPage = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.totalItems = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListUsersResponse {
    return {
      users: globalThis.Array.isArray(object?.users) ? object.users.map((e: any) => UserDetails.fromJSON(e)) : [],
      totalPage: isSet(object.totalPage) ? globalThis.Number(object.totalPage) : 0,
      currentPage: isSet(object.currentPage) ? globalThis.Number(object.currentPage) : 0,
      totalItems: isSet(object.totalItems) ? globalThis.Number(object.totalItems) : 0,
    };
  },

  toJSON(message: ListUsersResponse): unknown {
    const obj: any = {};
    if (message.users?.length) {
      obj.users = message.users.map((e) => UserDetails.toJSON(e));
    }
    if (message.totalPage !== 0) {
      obj.totalPage = Math.round(message.totalPage);
    }
    if (message.currentPage !== 0) {
      obj.currentPage = Math.round(message.currentPage);
    }
    if (message.totalItems !== 0) {
      obj.totalItems = Math.round(message.totalItems);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListUsersResponse>, I>>(base?: I): ListUsersResponse {
    return ListUsersResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListUsersResponse>, I>>(object: I): ListUsersResponse {
    const message = createBaseListUsersResponse();
    message.users = object.users?.map((e) => UserDetails.fromPartial(e)) || [];
    message.totalPage = object.totalPage ?? 0;
    message.currentPage = object.currentPage ?? 0;
    message.totalItems = object.totalItems ?? 0;
    return message;
  },
};

function createBaseBlockUserRequest(): BlockUserRequest {
  return { userId: "", block: false };
}

export const BlockUserRequest: MessageFns<BlockUserRequest> = {
  encode(message: BlockUserRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.block !== false) {
      writer.uint32(16).bool(message.block);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockUserRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.block = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockUserRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      block: isSet(object.block) ? globalThis.Boolean(object.block) : false,
    };
  },

  toJSON(message: BlockUserRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.block !== false) {
      obj.block = message.block;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlockUserRequest>, I>>(base?: I): BlockUserRequest {
    return BlockUserRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlockUserRequest>, I>>(object: I): BlockUserRequest {
    const message = createBaseBlockUserRequest();
    message.userId = object.userId ?? "";
    message.block = object.block ?? false;
    return message;
  },
};

function createBaseUserStatsResponse(): UserStatsResponse {
  return { totalUsers: 0, todaysUsers: 0 };
}

export const UserStatsResponse: MessageFns<UserStatsResponse> = {
  encode(message: UserStatsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.totalUsers !== 0) {
      writer.uint32(8).int32(message.totalUsers);
    }
    if (message.todaysUsers !== 0) {
      writer.uint32(16).int32(message.todaysUsers);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserStatsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserStatsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.totalUsers = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.todaysUsers = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserStatsResponse {
    return {
      totalUsers: isSet(object.totalUsers) ? globalThis.Number(object.totalUsers) : 0,
      todaysUsers: isSet(object.todaysUsers) ? globalThis.Number(object.todaysUsers) : 0,
    };
  },

  toJSON(message: UserStatsResponse): unknown {
    const obj: any = {};
    if (message.totalUsers !== 0) {
      obj.totalUsers = Math.round(message.totalUsers);
    }
    if (message.todaysUsers !== 0) {
      obj.todaysUsers = Math.round(message.todaysUsers);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserStatsResponse>, I>>(base?: I): UserStatsResponse {
    return UserStatsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserStatsResponse>, I>>(object: I): UserStatsResponse {
    const message = createBaseUserStatsResponse();
    message.totalUsers = object.totalUsers ?? 0;
    message.todaysUsers = object.todaysUsers ?? 0;
    return message;
  },
};

export type AuthUserServiceService = typeof AuthUserServiceService;
export const AuthUserServiceService = {
  signup: {
    path: "/auth_user.v1.AuthUserService/Signup",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SignupRequest): Buffer => Buffer.from(SignupRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): SignupRequest => SignupRequest.decode(value),
    responseSerialize: (value: SignupResponse): Buffer => Buffer.from(SignupResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SignupResponse => SignupResponse.decode(value),
  },
  resendOtp: {
    path: "/auth_user.v1.AuthUserService/ResendOtp",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ResendOtpRequest): Buffer => Buffer.from(ResendOtpRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ResendOtpRequest => ResendOtpRequest.decode(value),
    responseSerialize: (value: ResendOtpResponse): Buffer => Buffer.from(ResendOtpResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ResendOtpResponse => ResendOtpResponse.decode(value),
  },
  verifyOtp: {
    path: "/auth_user.v1.AuthUserService/VerifyOtp",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: VerifyOtpRequest): Buffer => Buffer.from(VerifyOtpRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): VerifyOtpRequest => VerifyOtpRequest.decode(value),
    responseSerialize: (value: VerifyOtpResponse): Buffer => Buffer.from(VerifyOtpResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): VerifyOtpResponse => VerifyOtpResponse.decode(value),
  },
  login: {
    path: "/auth_user.v1.AuthUserService/Login",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: LoginRequest): Buffer => Buffer.from(LoginRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): LoginRequest => LoginRequest.decode(value),
    responseSerialize: (value: LoginResponse): Buffer => Buffer.from(LoginResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): LoginResponse => LoginResponse.decode(value),
  },
  oAuthLogin: {
    path: "/auth_user.v1.AuthUserService/OAuthLogin",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: OAuthLoginRequest): Buffer => Buffer.from(OAuthLoginRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): OAuthLoginRequest => OAuthLoginRequest.decode(value),
    responseSerialize: (value: OAuthLoginResponse): Buffer => Buffer.from(OAuthLoginResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): OAuthLoginResponse => OAuthLoginResponse.decode(value),
  },
  forgotPassword: {
    path: "/auth_user.v1.AuthUserService/ForgotPassword",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ForgotPasswordRequest): Buffer =>
      Buffer.from(ForgotPasswordRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ForgotPasswordRequest => ForgotPasswordRequest.decode(value),
    responseSerialize: (value: ForgotPasswordResponse): Buffer =>
      Buffer.from(ForgotPasswordResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ForgotPasswordResponse => ForgotPasswordResponse.decode(value),
  },
  resetPassword: {
    path: "/auth_user.v1.AuthUserService/ResetPassword",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ResetPasswordRequest): Buffer => Buffer.from(ResetPasswordRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ResetPasswordRequest => ResetPasswordRequest.decode(value),
    responseSerialize: (value: ResetPasswordResponse): Buffer =>
      Buffer.from(ResetPasswordResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ResetPasswordResponse => ResetPasswordResponse.decode(value),
  },
  refreshToken: {
    path: "/auth_user.v1.AuthUserService/RefreshToken",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RefreshTokenRequest): Buffer => Buffer.from(RefreshTokenRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): RefreshTokenRequest => RefreshTokenRequest.decode(value),
    responseSerialize: (value: RefreshTokenResponse): Buffer =>
      Buffer.from(RefreshTokenResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): RefreshTokenResponse => RefreshTokenResponse.decode(value),
  },
  profile: {
    path: "/auth_user.v1.AuthUserService/Profile",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UserProfileRequest): Buffer => Buffer.from(UserProfileRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UserProfileRequest => UserProfileRequest.decode(value),
    responseSerialize: (value: UserProfileResponse): Buffer => Buffer.from(UserProfileResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): UserProfileResponse => UserProfileResponse.decode(value),
  },
  updateProfile: {
    path: "/auth_user.v1.AuthUserService/UpdateProfile",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateProfileRequest): Buffer => Buffer.from(UpdateProfileRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateProfileRequest => UpdateProfileRequest.decode(value),
    responseSerialize: (value: UpdateProfileResponse): Buffer =>
      Buffer.from(UpdateProfileResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): UpdateProfileResponse => UpdateProfileResponse.decode(value),
  },
  changeEmail: {
    path: "/auth_user.v1.AuthUserService/ChangeEmail",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ChangeEmailRequest): Buffer => Buffer.from(ChangeEmailRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ChangeEmailRequest => ChangeEmailRequest.decode(value),
    responseSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
  },
  verifyNewEmail: {
    path: "/auth_user.v1.AuthUserService/VerifyNewEmail",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: VerifyNewEmailRequest): Buffer =>
      Buffer.from(VerifyNewEmailRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): VerifyNewEmailRequest => VerifyNewEmailRequest.decode(value),
    responseSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
  },
  changePassword: {
    path: "/auth_user.v1.AuthUserService/ChangePassword",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ChangePasswordRequest): Buffer =>
      Buffer.from(ChangePasswordRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ChangePasswordRequest => ChangePasswordRequest.decode(value),
    responseSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
  },
  deleteAccount: {
    path: "/auth_user.v1.AuthUserService/DeleteAccount",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteAccountRequest): Buffer => Buffer.from(DeleteAccountRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteAccountRequest => DeleteAccountRequest.decode(value),
    responseSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
  },
} as const;

export interface AuthUserServiceServer extends UntypedServiceImplementation {
  signup: handleUnaryCall<SignupRequest, SignupResponse>;
  resendOtp: handleUnaryCall<ResendOtpRequest, ResendOtpResponse>;
  verifyOtp: handleUnaryCall<VerifyOtpRequest, VerifyOtpResponse>;
  login: handleUnaryCall<LoginRequest, LoginResponse>;
  oAuthLogin: handleUnaryCall<OAuthLoginRequest, OAuthLoginResponse>;
  forgotPassword: handleUnaryCall<ForgotPasswordRequest, ForgotPasswordResponse>;
  resetPassword: handleUnaryCall<ResetPasswordRequest, ResetPasswordResponse>;
  refreshToken: handleUnaryCall<RefreshTokenRequest, RefreshTokenResponse>;
  profile: handleUnaryCall<UserProfileRequest, UserProfileResponse>;
  updateProfile: handleUnaryCall<UpdateProfileRequest, UpdateProfileResponse>;
  changeEmail: handleUnaryCall<ChangeEmailRequest, Empty>;
  verifyNewEmail: handleUnaryCall<VerifyNewEmailRequest, Empty>;
  changePassword: handleUnaryCall<ChangePasswordRequest, Empty>;
  deleteAccount: handleUnaryCall<DeleteAccountRequest, Empty>;
}

export interface AuthUserServiceClient extends Client {
  signup(
    request: SignupRequest,
    callback: (error: ServiceError | null, response: SignupResponse) => void,
  ): ClientUnaryCall;
  signup(
    request: SignupRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SignupResponse) => void,
  ): ClientUnaryCall;
  signup(
    request: SignupRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SignupResponse) => void,
  ): ClientUnaryCall;
  resendOtp(
    request: ResendOtpRequest,
    callback: (error: ServiceError | null, response: ResendOtpResponse) => void,
  ): ClientUnaryCall;
  resendOtp(
    request: ResendOtpRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ResendOtpResponse) => void,
  ): ClientUnaryCall;
  resendOtp(
    request: ResendOtpRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ResendOtpResponse) => void,
  ): ClientUnaryCall;
  verifyOtp(
    request: VerifyOtpRequest,
    callback: (error: ServiceError | null, response: VerifyOtpResponse) => void,
  ): ClientUnaryCall;
  verifyOtp(
    request: VerifyOtpRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: VerifyOtpResponse) => void,
  ): ClientUnaryCall;
  verifyOtp(
    request: VerifyOtpRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: VerifyOtpResponse) => void,
  ): ClientUnaryCall;
  login(
    request: LoginRequest,
    callback: (error: ServiceError | null, response: LoginResponse) => void,
  ): ClientUnaryCall;
  login(
    request: LoginRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: LoginResponse) => void,
  ): ClientUnaryCall;
  login(
    request: LoginRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: LoginResponse) => void,
  ): ClientUnaryCall;
  oAuthLogin(
    request: OAuthLoginRequest,
    callback: (error: ServiceError | null, response: OAuthLoginResponse) => void,
  ): ClientUnaryCall;
  oAuthLogin(
    request: OAuthLoginRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: OAuthLoginResponse) => void,
  ): ClientUnaryCall;
  oAuthLogin(
    request: OAuthLoginRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: OAuthLoginResponse) => void,
  ): ClientUnaryCall;
  forgotPassword(
    request: ForgotPasswordRequest,
    callback: (error: ServiceError | null, response: ForgotPasswordResponse) => void,
  ): ClientUnaryCall;
  forgotPassword(
    request: ForgotPasswordRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ForgotPasswordResponse) => void,
  ): ClientUnaryCall;
  forgotPassword(
    request: ForgotPasswordRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ForgotPasswordResponse) => void,
  ): ClientUnaryCall;
  resetPassword(
    request: ResetPasswordRequest,
    callback: (error: ServiceError | null, response: ResetPasswordResponse) => void,
  ): ClientUnaryCall;
  resetPassword(
    request: ResetPasswordRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ResetPasswordResponse) => void,
  ): ClientUnaryCall;
  resetPassword(
    request: ResetPasswordRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ResetPasswordResponse) => void,
  ): ClientUnaryCall;
  refreshToken(
    request: RefreshTokenRequest,
    callback: (error: ServiceError | null, response: RefreshTokenResponse) => void,
  ): ClientUnaryCall;
  refreshToken(
    request: RefreshTokenRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: RefreshTokenResponse) => void,
  ): ClientUnaryCall;
  refreshToken(
    request: RefreshTokenRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: RefreshTokenResponse) => void,
  ): ClientUnaryCall;
  profile(
    request: UserProfileRequest,
    callback: (error: ServiceError | null, response: UserProfileResponse) => void,
  ): ClientUnaryCall;
  profile(
    request: UserProfileRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: UserProfileResponse) => void,
  ): ClientUnaryCall;
  profile(
    request: UserProfileRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: UserProfileResponse) => void,
  ): ClientUnaryCall;
  updateProfile(
    request: UpdateProfileRequest,
    callback: (error: ServiceError | null, response: UpdateProfileResponse) => void,
  ): ClientUnaryCall;
  updateProfile(
    request: UpdateProfileRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: UpdateProfileResponse) => void,
  ): ClientUnaryCall;
  updateProfile(
    request: UpdateProfileRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: UpdateProfileResponse) => void,
  ): ClientUnaryCall;
  changeEmail(
    request: ChangeEmailRequest,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  changeEmail(
    request: ChangeEmailRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  changeEmail(
    request: ChangeEmailRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  verifyNewEmail(
    request: VerifyNewEmailRequest,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  verifyNewEmail(
    request: VerifyNewEmailRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  verifyNewEmail(
    request: VerifyNewEmailRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  changePassword(
    request: ChangePasswordRequest,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  changePassword(
    request: ChangePasswordRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  changePassword(
    request: ChangePasswordRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  deleteAccount(
    request: DeleteAccountRequest,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  deleteAccount(
    request: DeleteAccountRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  deleteAccount(
    request: DeleteAccountRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
}

export const AuthUserServiceClient = makeGenericClientConstructor(
  AuthUserServiceService,
  "auth_user.v1.AuthUserService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): AuthUserServiceClient;
  service: typeof AuthUserServiceService;
  serviceName: string;
};

export type AuthAdminServiceService = typeof AuthAdminServiceService;
export const AuthAdminServiceService = {
  login: {
    path: "/auth_user.v1.AuthAdminService/Login",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: LoginRequest): Buffer => Buffer.from(LoginRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): LoginRequest => LoginRequest.decode(value),
    responseSerialize: (value: LoginResponse): Buffer => Buffer.from(LoginResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): LoginResponse => LoginResponse.decode(value),
  },
  refreshToken: {
    path: "/auth_user.v1.AuthAdminService/RefreshToken",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RefreshTokenRequest): Buffer => Buffer.from(RefreshTokenRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): RefreshTokenRequest => RefreshTokenRequest.decode(value),
    responseSerialize: (value: RefreshTokenResponse): Buffer =>
      Buffer.from(RefreshTokenResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): RefreshTokenResponse => RefreshTokenResponse.decode(value),
  },
  profile: {
    path: "/auth_user.v1.AuthAdminService/Profile",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: AdminProfileRequest): Buffer => Buffer.from(AdminProfileRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): AdminProfileRequest => AdminProfileRequest.decode(value),
    responseSerialize: (value: AdminProfileResponse): Buffer =>
      Buffer.from(AdminProfileResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): AdminProfileResponse => AdminProfileResponse.decode(value),
  },
  updateProfile: {
    path: "/auth_user.v1.AuthAdminService/UpdateProfile",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateProfileRequest): Buffer => Buffer.from(UpdateProfileRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateProfileRequest => UpdateProfileRequest.decode(value),
    responseSerialize: (value: UpdateProfileResponse): Buffer =>
      Buffer.from(UpdateProfileResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): UpdateProfileResponse => UpdateProfileResponse.decode(value),
  },
  listUsers: {
    path: "/auth_user.v1.AuthAdminService/ListUsers",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListUsersRequest): Buffer => Buffer.from(ListUsersRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListUsersRequest => ListUsersRequest.decode(value),
    responseSerialize: (value: ListUsersResponse): Buffer => Buffer.from(ListUsersResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListUsersResponse => ListUsersResponse.decode(value),
  },
  blockUser: {
    path: "/auth_user.v1.AuthAdminService/BlockUser",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BlockUserRequest): Buffer => Buffer.from(BlockUserRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): BlockUserRequest => BlockUserRequest.decode(value),
    responseSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
  },
  userStats: {
    path: "/auth_user.v1.AuthAdminService/UserStats",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    requestDeserialize: (value: Buffer): Empty => Empty.decode(value),
    responseSerialize: (value: UserStatsResponse): Buffer => Buffer.from(UserStatsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): UserStatsResponse => UserStatsResponse.decode(value),
  },
} as const;

export interface AuthAdminServiceServer extends UntypedServiceImplementation {
  login: handleUnaryCall<LoginRequest, LoginResponse>;
  refreshToken: handleUnaryCall<RefreshTokenRequest, RefreshTokenResponse>;
  profile: handleUnaryCall<AdminProfileRequest, AdminProfileResponse>;
  updateProfile: handleUnaryCall<UpdateProfileRequest, UpdateProfileResponse>;
  listUsers: handleUnaryCall<ListUsersRequest, ListUsersResponse>;
  blockUser: handleUnaryCall<BlockUserRequest, Empty>;
  userStats: handleUnaryCall<Empty, UserStatsResponse>;
}

export interface AuthAdminServiceClient extends Client {
  login(
    request: LoginRequest,
    callback: (error: ServiceError | null, response: LoginResponse) => void,
  ): ClientUnaryCall;
  login(
    request: LoginRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: LoginResponse) => void,
  ): ClientUnaryCall;
  login(
    request: LoginRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: LoginResponse) => void,
  ): ClientUnaryCall;
  refreshToken(
    request: RefreshTokenRequest,
    callback: (error: ServiceError | null, response: RefreshTokenResponse) => void,
  ): ClientUnaryCall;
  refreshToken(
    request: RefreshTokenRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: RefreshTokenResponse) => void,
  ): ClientUnaryCall;
  refreshToken(
    request: RefreshTokenRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: RefreshTokenResponse) => void,
  ): ClientUnaryCall;
  profile(
    request: AdminProfileRequest,
    callback: (error: ServiceError | null, response: AdminProfileResponse) => void,
  ): ClientUnaryCall;
  profile(
    request: AdminProfileRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: AdminProfileResponse) => void,
  ): ClientUnaryCall;
  profile(
    request: AdminProfileRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: AdminProfileResponse) => void,
  ): ClientUnaryCall;
  updateProfile(
    request: UpdateProfileRequest,
    callback: (error: ServiceError | null, response: UpdateProfileResponse) => void,
  ): ClientUnaryCall;
  updateProfile(
    request: UpdateProfileRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: UpdateProfileResponse) => void,
  ): ClientUnaryCall;
  updateProfile(
    request: UpdateProfileRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: UpdateProfileResponse) => void,
  ): ClientUnaryCall;
  listUsers(
    request: ListUsersRequest,
    callback: (error: ServiceError | null, response: ListUsersResponse) => void,
  ): ClientUnaryCall;
  listUsers(
    request: ListUsersRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListUsersResponse) => void,
  ): ClientUnaryCall;
  listUsers(
    request: ListUsersRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListUsersResponse) => void,
  ): ClientUnaryCall;
  blockUser(
    request: BlockUserRequest,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  blockUser(
    request: BlockUserRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  blockUser(
    request: BlockUserRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  userStats(
    request: Empty,
    callback: (error: ServiceError | null, response: UserStatsResponse) => void,
  ): ClientUnaryCall;
  userStats(
    request: Empty,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: UserStatsResponse) => void,
  ): ClientUnaryCall;
  userStats(
    request: Empty,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: UserStatsResponse) => void,
  ): ClientUnaryCall;
}

export const AuthAdminServiceClient = makeGenericClientConstructor(
  AuthAdminServiceService,
  "auth_user.v1.AuthAdminService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): AuthAdminServiceClient;
  service: typeof AuthAdminServiceService;
  serviceName: string;
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}

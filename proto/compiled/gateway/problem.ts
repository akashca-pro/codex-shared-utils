// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.5
//   protoc               v5.29.3
// source: gateway/problem.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  type ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  type Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import { Empty } from "../google/protobuf/empty";

export const protobufPackage = "problem.v1";

export enum Language {
  LANGUAGE_UNSPECIFIED = 0,
  JAVASCRIPT = 1,
  PYTHON = 2,
  GO = 3,
  UNRECOGNIZED = -1,
}

export function languageFromJSON(object: any): Language {
  switch (object) {
    case 0:
    case "LANGUAGE_UNSPECIFIED":
      return Language.LANGUAGE_UNSPECIFIED;
    case 1:
    case "JAVASCRIPT":
      return Language.JAVASCRIPT;
    case 2:
    case "PYTHON":
      return Language.PYTHON;
    case 3:
    case "GO":
      return Language.GO;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Language.UNRECOGNIZED;
  }
}

export function languageToJSON(object: Language): string {
  switch (object) {
    case Language.LANGUAGE_UNSPECIFIED:
      return "LANGUAGE_UNSPECIFIED";
    case Language.JAVASCRIPT:
      return "JAVASCRIPT";
    case Language.PYTHON:
      return "PYTHON";
    case Language.GO:
      return "GO";
    case Language.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum Difficulty {
  DIFFICULTY_UNSPECIFIED = 0,
  EASY = 1,
  MEDIUM = 2,
  HARD = 3,
  UNRECOGNIZED = -1,
}

export function difficultyFromJSON(object: any): Difficulty {
  switch (object) {
    case 0:
    case "DIFFICULTY_UNSPECIFIED":
      return Difficulty.DIFFICULTY_UNSPECIFIED;
    case 1:
    case "EASY":
      return Difficulty.EASY;
    case 2:
    case "MEDIUM":
      return Difficulty.MEDIUM;
    case 3:
    case "HARD":
      return Difficulty.HARD;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Difficulty.UNRECOGNIZED;
  }
}

export function difficultyToJSON(object: Difficulty): string {
  switch (object) {
    case Difficulty.DIFFICULTY_UNSPECIFIED:
      return "DIFFICULTY_UNSPECIFIED";
    case Difficulty.EASY:
      return "EASY";
    case Difficulty.MEDIUM:
      return "MEDIUM";
    case Difficulty.HARD:
      return "HARD";
    case Difficulty.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum TestCaseCollectionType {
  TYPE_UNSPECIFIED = 0,
  RUN = 1,
  SUBMIT = 2,
  UNRECOGNIZED = -1,
}

export function testCaseCollectionTypeFromJSON(object: any): TestCaseCollectionType {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return TestCaseCollectionType.TYPE_UNSPECIFIED;
    case 1:
    case "RUN":
      return TestCaseCollectionType.RUN;
    case 2:
    case "SUBMIT":
      return TestCaseCollectionType.SUBMIT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TestCaseCollectionType.UNRECOGNIZED;
  }
}

export function testCaseCollectionTypeToJSON(object: TestCaseCollectionType): string {
  switch (object) {
    case TestCaseCollectionType.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case TestCaseCollectionType.RUN:
      return "RUN";
    case TestCaseCollectionType.SUBMIT:
      return "SUBMIT";
    case TestCaseCollectionType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface TestCase {
  Id: string;
  input: string;
  output: string;
}

export interface TestCaseCollection {
  run: TestCase[];
  submit: TestCase[];
}

export interface Example {
  Id: string;
  input: string;
  output: string;
  explanation?: string | undefined;
}

export interface StarterCode {
  Id: string;
  language: Language;
  code: string;
}

export interface TemplateCode {
  Id?: string | undefined;
  language: Language;
  submitWrapperCode: string;
  runWrapperCode: string;
}

export interface SolutionRoadmap {
  Id: string;
  level: number;
  description: string;
}

export interface Problem {
  Id: string;
  questionId: string;
  title: string;
  description: string;
  difficulty: Difficulty;
  tags: string[];
  constraints: string[];
  starterCodes: StarterCode[];
  testcaseCollection?: TestCaseCollection | undefined;
  examples: Example[];
  active: boolean;
  templateCodes: TemplateCode[];
  solutionRoadmap: SolutionRoadmap[];
  createdAt: string;
  updatedAt: string;
}

export interface ListProblemDetails {
  Id: string;
  title: string;
  questionId: string;
  difficulty: Difficulty;
  tags: string[];
  active: boolean;
  createdAt: string;
  updatedAt: string;
}

export interface CreateProblemRequest {
  questionId: string;
  title: string;
  description: string;
  difficulty: Difficulty;
  tags: string[];
}

export interface GetProblemRequest {
  Id: string;
  title?: string | undefined;
  questionId?: string | undefined;
}

export interface GetProblemPublicResponse {
  Id: string;
  questionId: string;
  title: string;
  description: string;
  difficulty: Difficulty;
  tags: string[];
  constraints: string[];
  starterCodes: StarterCode[];
  run: TestCase[];
  examples: Example[];
  createdAt: string;
  updatedAt: string;
}

export interface ListProblemRequest {
  page: number;
  limit: number;
  /** optional filters */
  difficulty?: Difficulty | undefined;
  tags: string[];
  active?: boolean | undefined;
  search?: string | undefined;
  questionId?: string | undefined;
  sort?: string | undefined;
}

export interface ListProblemResponse {
  problems: ListProblemDetails[];
  totalPage: number;
  currentPage: number;
  totalItems: number;
}

export interface UpdateBasicProblemDetailsRequest {
  Id: string;
  questionId?: string | undefined;
  title?: string | undefined;
  description?: string | undefined;
  difficulty?: Difficulty | undefined;
  active?: boolean | undefined;
  tags: string[];
  constraints: string[];
  examples: Example[];
  solutionRoadmap: SolutionRoadmap[];
  starterCodes: StarterCode[];
}

export interface AddTestCaseRequest {
  Id: string;
  testCaseCollectionType: TestCaseCollectionType;
  testCase?: TestCase | undefined;
}

export interface BulkUploadTestCasesRequest {
  Id: string;
  testCaseCollectionType: TestCaseCollectionType;
  testCase: TestCase[];
}

export interface RemoveTestCaseRequest {
  Id: string;
  testCaseId: string;
  testCaseCollectionType: TestCaseCollectionType;
}

export interface UpdateTemplateCode {
  language?: Language | undefined;
  submitWrapperCode?: string | undefined;
  runWrapperCode?: string | undefined;
}

export interface UpdateTemplateCodeRequest {
  Id: string;
  templateCodeId: string;
  updatedTemplateCode?: UpdateTemplateCode | undefined;
}

export interface CheckQuestionIdRequest {
  questionId: string;
}

export interface CheckProblemTitleRequest {
  title: string;
}

export interface Stats {
  totalTestCase: number;
  passedTestCase: number;
  failedTestCase: number;
  executionTimeMs: number;
  memoryMB: number;
}

export interface FailedTestCase {
  index: number;
  input: string;
  output: string;
  expectedOutput: string;
}

export interface ExecutionResult {
  stats?: Stats | undefined;
  failedTestCase?: FailedTestCase | undefined;
}

export interface Submission {
  Id: string;
  problemId: string;
  userId: string;
  username: string;
  country: string;
  title: string;
  battleId?: string | undefined;
  score: number;
  status: string;
  language: Language;
  userCode: string;
  executionResult?: ExecutionResult | undefined;
  difficulty: Difficulty;
  isFirst: boolean;
  isAiAssisted: boolean;
  hintsUsed: number;
  updatedAt: string;
  createdAt: string;
}

export interface CreateSubmissionRequest {
  problemId: string;
  userId: string;
  username: string;
  battleId?: string | undefined;
  country?: string | undefined;
  title: string;
  language: Language;
  userCode: string;
  difficulty: Difficulty;
}

export interface UpdateSubmissionRequest {
  Id: string;
  status: string;
  executionResult?: ExecutionResult | undefined;
}

export interface GetSubmissionsRequest {
  page: number;
  limit: number;
  problemId?: string | undefined;
  battleId?: string | undefined;
  userId?: string | undefined;
}

export interface GetSubmissionsResponse {
  submissions: Submission[];
  totalPage: number;
  currentPage: number;
  totalItems: number;
}

export interface ListProblemSpecificSubmissionRequest {
  userId: string;
  problemId: string;
  limit: number;
  nextCursor?: string | undefined;
}

export interface ProblemSpecificSubmissions {
  Id: string;
  status: string;
  language: Language;
  executionResult?: ExecutionResult | undefined;
  userCode: string;
  isAiAssisted: boolean;
  hintsUsed: number;
  createdAt: string;
}

export interface ListProblemSpecificSubmissionResponse {
  submissions: ProblemSpecificSubmissions[];
  nextCursor: string;
  hasMore: boolean;
}

export interface ListTopKGlobalLeaderboardRequest {
  k: number;
}

export interface LeaderboardUser {
  id: string;
  entity?: string | undefined;
  score: number;
  username: string;
  problemsSolved?: number | undefined;
  rank?: number | undefined;
}

export interface ListTopKGlobalLeaderboardResponse {
  users: LeaderboardUser[];
}

export interface ListTopKCountryLeaderboardRequest {
  country: string;
  k: number;
}

export interface ListTopKCountryLeaderboardResponse {
  users: LeaderboardUser[];
}

export interface GetDashboardStatsRequest {
  userId: string;
  userTimezone: string;
}

export interface Activity {
  date: string;
  count: number;
}

export interface RecentActivity {
  title: string;
  difficulty: string;
  status: string;
  timeAgo: string;
  language: string;
}

export interface LeaderboardData {
  userId: string;
  username: string;
  score: number;
  entity: string;
  globalRank: number;
  entityRank: number;
}

export interface SolvedByDifficulty {
  difficulty: string;
  count: number;
}

export interface GetDashboardStatsResponse {
  heatmap: Activity[];
  currentStreak: number;
  leaderboardDetails?: LeaderboardData | undefined;
  problemsSolved: number;
  recentActivities: RecentActivity[];
  solvedByDifficulty: SolvedByDifficulty[];
}

export interface UpdateCountryRequest {
  userId: string;
  country: string;
}

export interface RemoveUserRequest {
  userId: string;
}

export interface LanguageWiseSubmissionStats {
  language: string;
  count: number;
}

export interface SubmissionStats {
  totalSubmissions: number;
  todaysSubmissions: number;
  languageWise: LanguageWiseSubmissionStats[];
}

export interface DifficultyWiseProblemStats {
  difficulty: string;
  count: number;
}

export interface ProblemStats {
  totalProblems: number;
  todaysProblems: number;
  difficultyWise: DifficultyWiseProblemStats[];
}

export interface GetProblemSubmissionStatsResponse {
  submissionStats?: SubmissionStats | undefined;
  problemStats?: ProblemStats | undefined;
}

export interface RequestHintRequest {
  userCode: string;
  problemId: string;
  language: string;
  userId: string;
}

export interface RequestHintResponse {
  hint: string;
}

export interface GetPreviousHintsRequest {
  problemId: string;
  userId: string;
}

export interface PreviousHint {
  hint: string;
  createdAt: string;
}

export interface GetPreviousHintsResponse {
  hints: PreviousHint[];
}

export interface RequestFullSolutionRequest {
  problemId: string;
  userId: string;
  language: string;
}

export interface RequestFullSolutionResponse {
  solution: string;
}

function createBaseTestCase(): TestCase {
  return { Id: "", input: "", output: "" };
}

export const TestCase: MessageFns<TestCase> = {
  encode(message: TestCase, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.Id !== "") {
      writer.uint32(10).string(message.Id);
    }
    if (message.input !== "") {
      writer.uint32(18).string(message.input);
    }
    if (message.output !== "") {
      writer.uint32(26).string(message.output);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TestCase {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTestCase();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.Id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.input = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.output = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TestCase {
    return {
      Id: isSet(object.Id) ? globalThis.String(object.Id) : "",
      input: isSet(object.input) ? globalThis.String(object.input) : "",
      output: isSet(object.output) ? globalThis.String(object.output) : "",
    };
  },

  toJSON(message: TestCase): unknown {
    const obj: any = {};
    if (message.Id !== "") {
      obj.Id = message.Id;
    }
    if (message.input !== "") {
      obj.input = message.input;
    }
    if (message.output !== "") {
      obj.output = message.output;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TestCase>, I>>(base?: I): TestCase {
    return TestCase.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TestCase>, I>>(object: I): TestCase {
    const message = createBaseTestCase();
    message.Id = object.Id ?? "";
    message.input = object.input ?? "";
    message.output = object.output ?? "";
    return message;
  },
};

function createBaseTestCaseCollection(): TestCaseCollection {
  return { run: [], submit: [] };
}

export const TestCaseCollection: MessageFns<TestCaseCollection> = {
  encode(message: TestCaseCollection, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.run) {
      TestCase.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.submit) {
      TestCase.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TestCaseCollection {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTestCaseCollection();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.run.push(TestCase.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.submit.push(TestCase.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TestCaseCollection {
    return {
      run: globalThis.Array.isArray(object?.run) ? object.run.map((e: any) => TestCase.fromJSON(e)) : [],
      submit: globalThis.Array.isArray(object?.submit) ? object.submit.map((e: any) => TestCase.fromJSON(e)) : [],
    };
  },

  toJSON(message: TestCaseCollection): unknown {
    const obj: any = {};
    if (message.run?.length) {
      obj.run = message.run.map((e) => TestCase.toJSON(e));
    }
    if (message.submit?.length) {
      obj.submit = message.submit.map((e) => TestCase.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TestCaseCollection>, I>>(base?: I): TestCaseCollection {
    return TestCaseCollection.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TestCaseCollection>, I>>(object: I): TestCaseCollection {
    const message = createBaseTestCaseCollection();
    message.run = object.run?.map((e) => TestCase.fromPartial(e)) || [];
    message.submit = object.submit?.map((e) => TestCase.fromPartial(e)) || [];
    return message;
  },
};

function createBaseExample(): Example {
  return { Id: "", input: "", output: "", explanation: undefined };
}

export const Example: MessageFns<Example> = {
  encode(message: Example, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.Id !== "") {
      writer.uint32(10).string(message.Id);
    }
    if (message.input !== "") {
      writer.uint32(18).string(message.input);
    }
    if (message.output !== "") {
      writer.uint32(26).string(message.output);
    }
    if (message.explanation !== undefined) {
      writer.uint32(34).string(message.explanation);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Example {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExample();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.Id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.input = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.output = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.explanation = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Example {
    return {
      Id: isSet(object.Id) ? globalThis.String(object.Id) : "",
      input: isSet(object.input) ? globalThis.String(object.input) : "",
      output: isSet(object.output) ? globalThis.String(object.output) : "",
      explanation: isSet(object.explanation) ? globalThis.String(object.explanation) : undefined,
    };
  },

  toJSON(message: Example): unknown {
    const obj: any = {};
    if (message.Id !== "") {
      obj.Id = message.Id;
    }
    if (message.input !== "") {
      obj.input = message.input;
    }
    if (message.output !== "") {
      obj.output = message.output;
    }
    if (message.explanation !== undefined) {
      obj.explanation = message.explanation;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Example>, I>>(base?: I): Example {
    return Example.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Example>, I>>(object: I): Example {
    const message = createBaseExample();
    message.Id = object.Id ?? "";
    message.input = object.input ?? "";
    message.output = object.output ?? "";
    message.explanation = object.explanation ?? undefined;
    return message;
  },
};

function createBaseStarterCode(): StarterCode {
  return { Id: "", language: 0, code: "" };
}

export const StarterCode: MessageFns<StarterCode> = {
  encode(message: StarterCode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.Id !== "") {
      writer.uint32(10).string(message.Id);
    }
    if (message.language !== 0) {
      writer.uint32(16).int32(message.language);
    }
    if (message.code !== "") {
      writer.uint32(26).string(message.code);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StarterCode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStarterCode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.Id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.language = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.code = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StarterCode {
    return {
      Id: isSet(object.Id) ? globalThis.String(object.Id) : "",
      language: isSet(object.language) ? languageFromJSON(object.language) : 0,
      code: isSet(object.code) ? globalThis.String(object.code) : "",
    };
  },

  toJSON(message: StarterCode): unknown {
    const obj: any = {};
    if (message.Id !== "") {
      obj.Id = message.Id;
    }
    if (message.language !== 0) {
      obj.language = languageToJSON(message.language);
    }
    if (message.code !== "") {
      obj.code = message.code;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StarterCode>, I>>(base?: I): StarterCode {
    return StarterCode.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StarterCode>, I>>(object: I): StarterCode {
    const message = createBaseStarterCode();
    message.Id = object.Id ?? "";
    message.language = object.language ?? 0;
    message.code = object.code ?? "";
    return message;
  },
};

function createBaseTemplateCode(): TemplateCode {
  return { Id: undefined, language: 0, submitWrapperCode: "", runWrapperCode: "" };
}

export const TemplateCode: MessageFns<TemplateCode> = {
  encode(message: TemplateCode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.Id !== undefined) {
      writer.uint32(10).string(message.Id);
    }
    if (message.language !== 0) {
      writer.uint32(16).int32(message.language);
    }
    if (message.submitWrapperCode !== "") {
      writer.uint32(26).string(message.submitWrapperCode);
    }
    if (message.runWrapperCode !== "") {
      writer.uint32(34).string(message.runWrapperCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TemplateCode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTemplateCode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.Id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.language = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.submitWrapperCode = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.runWrapperCode = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TemplateCode {
    return {
      Id: isSet(object.Id) ? globalThis.String(object.Id) : undefined,
      language: isSet(object.language) ? languageFromJSON(object.language) : 0,
      submitWrapperCode: isSet(object.submitWrapperCode) ? globalThis.String(object.submitWrapperCode) : "",
      runWrapperCode: isSet(object.runWrapperCode) ? globalThis.String(object.runWrapperCode) : "",
    };
  },

  toJSON(message: TemplateCode): unknown {
    const obj: any = {};
    if (message.Id !== undefined) {
      obj.Id = message.Id;
    }
    if (message.language !== 0) {
      obj.language = languageToJSON(message.language);
    }
    if (message.submitWrapperCode !== "") {
      obj.submitWrapperCode = message.submitWrapperCode;
    }
    if (message.runWrapperCode !== "") {
      obj.runWrapperCode = message.runWrapperCode;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TemplateCode>, I>>(base?: I): TemplateCode {
    return TemplateCode.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TemplateCode>, I>>(object: I): TemplateCode {
    const message = createBaseTemplateCode();
    message.Id = object.Id ?? undefined;
    message.language = object.language ?? 0;
    message.submitWrapperCode = object.submitWrapperCode ?? "";
    message.runWrapperCode = object.runWrapperCode ?? "";
    return message;
  },
};

function createBaseSolutionRoadmap(): SolutionRoadmap {
  return { Id: "", level: 0, description: "" };
}

export const SolutionRoadmap: MessageFns<SolutionRoadmap> = {
  encode(message: SolutionRoadmap, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.Id !== "") {
      writer.uint32(10).string(message.Id);
    }
    if (message.level !== 0) {
      writer.uint32(16).int32(message.level);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SolutionRoadmap {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSolutionRoadmap();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.Id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.level = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SolutionRoadmap {
    return {
      Id: isSet(object.Id) ? globalThis.String(object.Id) : "",
      level: isSet(object.level) ? globalThis.Number(object.level) : 0,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
    };
  },

  toJSON(message: SolutionRoadmap): unknown {
    const obj: any = {};
    if (message.Id !== "") {
      obj.Id = message.Id;
    }
    if (message.level !== 0) {
      obj.level = Math.round(message.level);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SolutionRoadmap>, I>>(base?: I): SolutionRoadmap {
    return SolutionRoadmap.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SolutionRoadmap>, I>>(object: I): SolutionRoadmap {
    const message = createBaseSolutionRoadmap();
    message.Id = object.Id ?? "";
    message.level = object.level ?? 0;
    message.description = object.description ?? "";
    return message;
  },
};

function createBaseProblem(): Problem {
  return {
    Id: "",
    questionId: "",
    title: "",
    description: "",
    difficulty: 0,
    tags: [],
    constraints: [],
    starterCodes: [],
    testcaseCollection: undefined,
    examples: [],
    active: false,
    templateCodes: [],
    solutionRoadmap: [],
    createdAt: "",
    updatedAt: "",
  };
}

export const Problem: MessageFns<Problem> = {
  encode(message: Problem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.Id !== "") {
      writer.uint32(10).string(message.Id);
    }
    if (message.questionId !== "") {
      writer.uint32(18).string(message.questionId);
    }
    if (message.title !== "") {
      writer.uint32(26).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    if (message.difficulty !== 0) {
      writer.uint32(40).int32(message.difficulty);
    }
    for (const v of message.tags) {
      writer.uint32(50).string(v!);
    }
    for (const v of message.constraints) {
      writer.uint32(58).string(v!);
    }
    for (const v of message.starterCodes) {
      StarterCode.encode(v!, writer.uint32(66).fork()).join();
    }
    if (message.testcaseCollection !== undefined) {
      TestCaseCollection.encode(message.testcaseCollection, writer.uint32(74).fork()).join();
    }
    for (const v of message.examples) {
      Example.encode(v!, writer.uint32(82).fork()).join();
    }
    if (message.active !== false) {
      writer.uint32(88).bool(message.active);
    }
    for (const v of message.templateCodes) {
      TemplateCode.encode(v!, writer.uint32(98).fork()).join();
    }
    for (const v of message.solutionRoadmap) {
      SolutionRoadmap.encode(v!, writer.uint32(106).fork()).join();
    }
    if (message.createdAt !== "") {
      writer.uint32(114).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(122).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Problem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProblem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.Id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.questionId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.difficulty = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.constraints.push(reader.string());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.starterCodes.push(StarterCode.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.testcaseCollection = TestCaseCollection.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.examples.push(Example.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.active = reader.bool();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.templateCodes.push(TemplateCode.decode(reader, reader.uint32()));
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.solutionRoadmap.push(SolutionRoadmap.decode(reader, reader.uint32()));
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Problem {
    return {
      Id: isSet(object.Id) ? globalThis.String(object.Id) : "",
      questionId: isSet(object.questionId) ? globalThis.String(object.questionId) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      difficulty: isSet(object.difficulty) ? difficultyFromJSON(object.difficulty) : 0,
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      constraints: globalThis.Array.isArray(object?.constraints)
        ? object.constraints.map((e: any) => globalThis.String(e))
        : [],
      starterCodes: globalThis.Array.isArray(object?.starterCodes)
        ? object.starterCodes.map((e: any) => StarterCode.fromJSON(e))
        : [],
      testcaseCollection: isSet(object.testcaseCollection)
        ? TestCaseCollection.fromJSON(object.testcaseCollection)
        : undefined,
      examples: globalThis.Array.isArray(object?.examples) ? object.examples.map((e: any) => Example.fromJSON(e)) : [],
      active: isSet(object.active) ? globalThis.Boolean(object.active) : false,
      templateCodes: globalThis.Array.isArray(object?.templateCodes)
        ? object.templateCodes.map((e: any) => TemplateCode.fromJSON(e))
        : [],
      solutionRoadmap: globalThis.Array.isArray(object?.solutionRoadmap)
        ? object.solutionRoadmap.map((e: any) => SolutionRoadmap.fromJSON(e))
        : [],
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
      updatedAt: isSet(object.updatedAt) ? globalThis.String(object.updatedAt) : "",
    };
  },

  toJSON(message: Problem): unknown {
    const obj: any = {};
    if (message.Id !== "") {
      obj.Id = message.Id;
    }
    if (message.questionId !== "") {
      obj.questionId = message.questionId;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.difficulty !== 0) {
      obj.difficulty = difficultyToJSON(message.difficulty);
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.constraints?.length) {
      obj.constraints = message.constraints;
    }
    if (message.starterCodes?.length) {
      obj.starterCodes = message.starterCodes.map((e) => StarterCode.toJSON(e));
    }
    if (message.testcaseCollection !== undefined) {
      obj.testcaseCollection = TestCaseCollection.toJSON(message.testcaseCollection);
    }
    if (message.examples?.length) {
      obj.examples = message.examples.map((e) => Example.toJSON(e));
    }
    if (message.active !== false) {
      obj.active = message.active;
    }
    if (message.templateCodes?.length) {
      obj.templateCodes = message.templateCodes.map((e) => TemplateCode.toJSON(e));
    }
    if (message.solutionRoadmap?.length) {
      obj.solutionRoadmap = message.solutionRoadmap.map((e) => SolutionRoadmap.toJSON(e));
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Problem>, I>>(base?: I): Problem {
    return Problem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Problem>, I>>(object: I): Problem {
    const message = createBaseProblem();
    message.Id = object.Id ?? "";
    message.questionId = object.questionId ?? "";
    message.title = object.title ?? "";
    message.description = object.description ?? "";
    message.difficulty = object.difficulty ?? 0;
    message.tags = object.tags?.map((e) => e) || [];
    message.constraints = object.constraints?.map((e) => e) || [];
    message.starterCodes = object.starterCodes?.map((e) => StarterCode.fromPartial(e)) || [];
    message.testcaseCollection = (object.testcaseCollection !== undefined && object.testcaseCollection !== null)
      ? TestCaseCollection.fromPartial(object.testcaseCollection)
      : undefined;
    message.examples = object.examples?.map((e) => Example.fromPartial(e)) || [];
    message.active = object.active ?? false;
    message.templateCodes = object.templateCodes?.map((e) => TemplateCode.fromPartial(e)) || [];
    message.solutionRoadmap = object.solutionRoadmap?.map((e) => SolutionRoadmap.fromPartial(e)) || [];
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? "";
    return message;
  },
};

function createBaseListProblemDetails(): ListProblemDetails {
  return { Id: "", title: "", questionId: "", difficulty: 0, tags: [], active: false, createdAt: "", updatedAt: "" };
}

export const ListProblemDetails: MessageFns<ListProblemDetails> = {
  encode(message: ListProblemDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.Id !== "") {
      writer.uint32(10).string(message.Id);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.questionId !== "") {
      writer.uint32(26).string(message.questionId);
    }
    if (message.difficulty !== 0) {
      writer.uint32(32).int32(message.difficulty);
    }
    for (const v of message.tags) {
      writer.uint32(50).string(v!);
    }
    if (message.active !== false) {
      writer.uint32(88).bool(message.active);
    }
    if (message.createdAt !== "") {
      writer.uint32(106).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(114).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListProblemDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListProblemDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.Id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.questionId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.difficulty = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.active = reader.bool();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListProblemDetails {
    return {
      Id: isSet(object.Id) ? globalThis.String(object.Id) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      questionId: isSet(object.questionId) ? globalThis.String(object.questionId) : "",
      difficulty: isSet(object.difficulty) ? difficultyFromJSON(object.difficulty) : 0,
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      active: isSet(object.active) ? globalThis.Boolean(object.active) : false,
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
      updatedAt: isSet(object.updatedAt) ? globalThis.String(object.updatedAt) : "",
    };
  },

  toJSON(message: ListProblemDetails): unknown {
    const obj: any = {};
    if (message.Id !== "") {
      obj.Id = message.Id;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.questionId !== "") {
      obj.questionId = message.questionId;
    }
    if (message.difficulty !== 0) {
      obj.difficulty = difficultyToJSON(message.difficulty);
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.active !== false) {
      obj.active = message.active;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListProblemDetails>, I>>(base?: I): ListProblemDetails {
    return ListProblemDetails.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListProblemDetails>, I>>(object: I): ListProblemDetails {
    const message = createBaseListProblemDetails();
    message.Id = object.Id ?? "";
    message.title = object.title ?? "";
    message.questionId = object.questionId ?? "";
    message.difficulty = object.difficulty ?? 0;
    message.tags = object.tags?.map((e) => e) || [];
    message.active = object.active ?? false;
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? "";
    return message;
  },
};

function createBaseCreateProblemRequest(): CreateProblemRequest {
  return { questionId: "", title: "", description: "", difficulty: 0, tags: [] };
}

export const CreateProblemRequest: MessageFns<CreateProblemRequest> = {
  encode(message: CreateProblemRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.questionId !== "") {
      writer.uint32(10).string(message.questionId);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.difficulty !== 0) {
      writer.uint32(32).int32(message.difficulty);
    }
    for (const v of message.tags) {
      writer.uint32(42).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateProblemRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateProblemRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.questionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.difficulty = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateProblemRequest {
    return {
      questionId: isSet(object.questionId) ? globalThis.String(object.questionId) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      difficulty: isSet(object.difficulty) ? difficultyFromJSON(object.difficulty) : 0,
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: CreateProblemRequest): unknown {
    const obj: any = {};
    if (message.questionId !== "") {
      obj.questionId = message.questionId;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.difficulty !== 0) {
      obj.difficulty = difficultyToJSON(message.difficulty);
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateProblemRequest>, I>>(base?: I): CreateProblemRequest {
    return CreateProblemRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateProblemRequest>, I>>(object: I): CreateProblemRequest {
    const message = createBaseCreateProblemRequest();
    message.questionId = object.questionId ?? "";
    message.title = object.title ?? "";
    message.description = object.description ?? "";
    message.difficulty = object.difficulty ?? 0;
    message.tags = object.tags?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetProblemRequest(): GetProblemRequest {
  return { Id: "", title: undefined, questionId: undefined };
}

export const GetProblemRequest: MessageFns<GetProblemRequest> = {
  encode(message: GetProblemRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.Id !== "") {
      writer.uint32(10).string(message.Id);
    }
    if (message.title !== undefined) {
      writer.uint32(18).string(message.title);
    }
    if (message.questionId !== undefined) {
      writer.uint32(26).string(message.questionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetProblemRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProblemRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.Id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.questionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetProblemRequest {
    return {
      Id: isSet(object.Id) ? globalThis.String(object.Id) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : undefined,
      questionId: isSet(object.questionId) ? globalThis.String(object.questionId) : undefined,
    };
  },

  toJSON(message: GetProblemRequest): unknown {
    const obj: any = {};
    if (message.Id !== "") {
      obj.Id = message.Id;
    }
    if (message.title !== undefined) {
      obj.title = message.title;
    }
    if (message.questionId !== undefined) {
      obj.questionId = message.questionId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetProblemRequest>, I>>(base?: I): GetProblemRequest {
    return GetProblemRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetProblemRequest>, I>>(object: I): GetProblemRequest {
    const message = createBaseGetProblemRequest();
    message.Id = object.Id ?? "";
    message.title = object.title ?? undefined;
    message.questionId = object.questionId ?? undefined;
    return message;
  },
};

function createBaseGetProblemPublicResponse(): GetProblemPublicResponse {
  return {
    Id: "",
    questionId: "",
    title: "",
    description: "",
    difficulty: 0,
    tags: [],
    constraints: [],
    starterCodes: [],
    run: [],
    examples: [],
    createdAt: "",
    updatedAt: "",
  };
}

export const GetProblemPublicResponse: MessageFns<GetProblemPublicResponse> = {
  encode(message: GetProblemPublicResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.Id !== "") {
      writer.uint32(10).string(message.Id);
    }
    if (message.questionId !== "") {
      writer.uint32(18).string(message.questionId);
    }
    if (message.title !== "") {
      writer.uint32(26).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    if (message.difficulty !== 0) {
      writer.uint32(40).int32(message.difficulty);
    }
    for (const v of message.tags) {
      writer.uint32(50).string(v!);
    }
    for (const v of message.constraints) {
      writer.uint32(58).string(v!);
    }
    for (const v of message.starterCodes) {
      StarterCode.encode(v!, writer.uint32(66).fork()).join();
    }
    for (const v of message.run) {
      TestCase.encode(v!, writer.uint32(74).fork()).join();
    }
    for (const v of message.examples) {
      Example.encode(v!, writer.uint32(82).fork()).join();
    }
    if (message.createdAt !== "") {
      writer.uint32(106).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(114).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetProblemPublicResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProblemPublicResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.Id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.questionId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.difficulty = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.constraints.push(reader.string());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.starterCodes.push(StarterCode.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.run.push(TestCase.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.examples.push(Example.decode(reader, reader.uint32()));
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetProblemPublicResponse {
    return {
      Id: isSet(object.Id) ? globalThis.String(object.Id) : "",
      questionId: isSet(object.questionId) ? globalThis.String(object.questionId) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      difficulty: isSet(object.difficulty) ? difficultyFromJSON(object.difficulty) : 0,
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      constraints: globalThis.Array.isArray(object?.constraints)
        ? object.constraints.map((e: any) => globalThis.String(e))
        : [],
      starterCodes: globalThis.Array.isArray(object?.starterCodes)
        ? object.starterCodes.map((e: any) => StarterCode.fromJSON(e))
        : [],
      run: globalThis.Array.isArray(object?.run) ? object.run.map((e: any) => TestCase.fromJSON(e)) : [],
      examples: globalThis.Array.isArray(object?.examples) ? object.examples.map((e: any) => Example.fromJSON(e)) : [],
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
      updatedAt: isSet(object.updatedAt) ? globalThis.String(object.updatedAt) : "",
    };
  },

  toJSON(message: GetProblemPublicResponse): unknown {
    const obj: any = {};
    if (message.Id !== "") {
      obj.Id = message.Id;
    }
    if (message.questionId !== "") {
      obj.questionId = message.questionId;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.difficulty !== 0) {
      obj.difficulty = difficultyToJSON(message.difficulty);
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.constraints?.length) {
      obj.constraints = message.constraints;
    }
    if (message.starterCodes?.length) {
      obj.starterCodes = message.starterCodes.map((e) => StarterCode.toJSON(e));
    }
    if (message.run?.length) {
      obj.run = message.run.map((e) => TestCase.toJSON(e));
    }
    if (message.examples?.length) {
      obj.examples = message.examples.map((e) => Example.toJSON(e));
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetProblemPublicResponse>, I>>(base?: I): GetProblemPublicResponse {
    return GetProblemPublicResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetProblemPublicResponse>, I>>(object: I): GetProblemPublicResponse {
    const message = createBaseGetProblemPublicResponse();
    message.Id = object.Id ?? "";
    message.questionId = object.questionId ?? "";
    message.title = object.title ?? "";
    message.description = object.description ?? "";
    message.difficulty = object.difficulty ?? 0;
    message.tags = object.tags?.map((e) => e) || [];
    message.constraints = object.constraints?.map((e) => e) || [];
    message.starterCodes = object.starterCodes?.map((e) => StarterCode.fromPartial(e)) || [];
    message.run = object.run?.map((e) => TestCase.fromPartial(e)) || [];
    message.examples = object.examples?.map((e) => Example.fromPartial(e)) || [];
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? "";
    return message;
  },
};

function createBaseListProblemRequest(): ListProblemRequest {
  return {
    page: 0,
    limit: 0,
    difficulty: undefined,
    tags: [],
    active: undefined,
    search: undefined,
    questionId: undefined,
    sort: undefined,
  };
}

export const ListProblemRequest: MessageFns<ListProblemRequest> = {
  encode(message: ListProblemRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.page !== 0) {
      writer.uint32(8).int32(message.page);
    }
    if (message.limit !== 0) {
      writer.uint32(16).int32(message.limit);
    }
    if (message.difficulty !== undefined) {
      writer.uint32(24).int32(message.difficulty);
    }
    for (const v of message.tags) {
      writer.uint32(34).string(v!);
    }
    if (message.active !== undefined) {
      writer.uint32(40).bool(message.active);
    }
    if (message.search !== undefined) {
      writer.uint32(50).string(message.search);
    }
    if (message.questionId !== undefined) {
      writer.uint32(58).string(message.questionId);
    }
    if (message.sort !== undefined) {
      writer.uint32(66).string(message.sort);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListProblemRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListProblemRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.difficulty = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.active = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.search = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.questionId = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.sort = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListProblemRequest {
    return {
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
      difficulty: isSet(object.difficulty) ? difficultyFromJSON(object.difficulty) : undefined,
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      active: isSet(object.active) ? globalThis.Boolean(object.active) : undefined,
      search: isSet(object.search) ? globalThis.String(object.search) : undefined,
      questionId: isSet(object.questionId) ? globalThis.String(object.questionId) : undefined,
      sort: isSet(object.sort) ? globalThis.String(object.sort) : undefined,
    };
  },

  toJSON(message: ListProblemRequest): unknown {
    const obj: any = {};
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    if (message.difficulty !== undefined) {
      obj.difficulty = difficultyToJSON(message.difficulty);
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.active !== undefined) {
      obj.active = message.active;
    }
    if (message.search !== undefined) {
      obj.search = message.search;
    }
    if (message.questionId !== undefined) {
      obj.questionId = message.questionId;
    }
    if (message.sort !== undefined) {
      obj.sort = message.sort;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListProblemRequest>, I>>(base?: I): ListProblemRequest {
    return ListProblemRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListProblemRequest>, I>>(object: I): ListProblemRequest {
    const message = createBaseListProblemRequest();
    message.page = object.page ?? 0;
    message.limit = object.limit ?? 0;
    message.difficulty = object.difficulty ?? undefined;
    message.tags = object.tags?.map((e) => e) || [];
    message.active = object.active ?? undefined;
    message.search = object.search ?? undefined;
    message.questionId = object.questionId ?? undefined;
    message.sort = object.sort ?? undefined;
    return message;
  },
};

function createBaseListProblemResponse(): ListProblemResponse {
  return { problems: [], totalPage: 0, currentPage: 0, totalItems: 0 };
}

export const ListProblemResponse: MessageFns<ListProblemResponse> = {
  encode(message: ListProblemResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.problems) {
      ListProblemDetails.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.totalPage !== 0) {
      writer.uint32(16).int32(message.totalPage);
    }
    if (message.currentPage !== 0) {
      writer.uint32(24).int32(message.currentPage);
    }
    if (message.totalItems !== 0) {
      writer.uint32(32).int32(message.totalItems);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListProblemResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListProblemResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.problems.push(ListProblemDetails.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.totalPage = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.currentPage = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.totalItems = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListProblemResponse {
    return {
      problems: globalThis.Array.isArray(object?.problems)
        ? object.problems.map((e: any) => ListProblemDetails.fromJSON(e))
        : [],
      totalPage: isSet(object.totalPage) ? globalThis.Number(object.totalPage) : 0,
      currentPage: isSet(object.currentPage) ? globalThis.Number(object.currentPage) : 0,
      totalItems: isSet(object.totalItems) ? globalThis.Number(object.totalItems) : 0,
    };
  },

  toJSON(message: ListProblemResponse): unknown {
    const obj: any = {};
    if (message.problems?.length) {
      obj.problems = message.problems.map((e) => ListProblemDetails.toJSON(e));
    }
    if (message.totalPage !== 0) {
      obj.totalPage = Math.round(message.totalPage);
    }
    if (message.currentPage !== 0) {
      obj.currentPage = Math.round(message.currentPage);
    }
    if (message.totalItems !== 0) {
      obj.totalItems = Math.round(message.totalItems);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListProblemResponse>, I>>(base?: I): ListProblemResponse {
    return ListProblemResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListProblemResponse>, I>>(object: I): ListProblemResponse {
    const message = createBaseListProblemResponse();
    message.problems = object.problems?.map((e) => ListProblemDetails.fromPartial(e)) || [];
    message.totalPage = object.totalPage ?? 0;
    message.currentPage = object.currentPage ?? 0;
    message.totalItems = object.totalItems ?? 0;
    return message;
  },
};

function createBaseUpdateBasicProblemDetailsRequest(): UpdateBasicProblemDetailsRequest {
  return {
    Id: "",
    questionId: undefined,
    title: undefined,
    description: undefined,
    difficulty: undefined,
    active: undefined,
    tags: [],
    constraints: [],
    examples: [],
    solutionRoadmap: [],
    starterCodes: [],
  };
}

export const UpdateBasicProblemDetailsRequest: MessageFns<UpdateBasicProblemDetailsRequest> = {
  encode(message: UpdateBasicProblemDetailsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.Id !== "") {
      writer.uint32(10).string(message.Id);
    }
    if (message.questionId !== undefined) {
      writer.uint32(18).string(message.questionId);
    }
    if (message.title !== undefined) {
      writer.uint32(26).string(message.title);
    }
    if (message.description !== undefined) {
      writer.uint32(34).string(message.description);
    }
    if (message.difficulty !== undefined) {
      writer.uint32(40).int32(message.difficulty);
    }
    if (message.active !== undefined) {
      writer.uint32(48).bool(message.active);
    }
    for (const v of message.tags) {
      writer.uint32(58).string(v!);
    }
    for (const v of message.constraints) {
      writer.uint32(66).string(v!);
    }
    for (const v of message.examples) {
      Example.encode(v!, writer.uint32(74).fork()).join();
    }
    for (const v of message.solutionRoadmap) {
      SolutionRoadmap.encode(v!, writer.uint32(82).fork()).join();
    }
    for (const v of message.starterCodes) {
      StarterCode.encode(v!, writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateBasicProblemDetailsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateBasicProblemDetailsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.Id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.questionId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.difficulty = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.active = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.constraints.push(reader.string());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.examples.push(Example.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.solutionRoadmap.push(SolutionRoadmap.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.starterCodes.push(StarterCode.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateBasicProblemDetailsRequest {
    return {
      Id: isSet(object.Id) ? globalThis.String(object.Id) : "",
      questionId: isSet(object.questionId) ? globalThis.String(object.questionId) : undefined,
      title: isSet(object.title) ? globalThis.String(object.title) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      difficulty: isSet(object.difficulty) ? difficultyFromJSON(object.difficulty) : undefined,
      active: isSet(object.active) ? globalThis.Boolean(object.active) : undefined,
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      constraints: globalThis.Array.isArray(object?.constraints)
        ? object.constraints.map((e: any) => globalThis.String(e))
        : [],
      examples: globalThis.Array.isArray(object?.examples) ? object.examples.map((e: any) => Example.fromJSON(e)) : [],
      solutionRoadmap: globalThis.Array.isArray(object?.solutionRoadmap)
        ? object.solutionRoadmap.map((e: any) => SolutionRoadmap.fromJSON(e))
        : [],
      starterCodes: globalThis.Array.isArray(object?.starterCodes)
        ? object.starterCodes.map((e: any) => StarterCode.fromJSON(e))
        : [],
    };
  },

  toJSON(message: UpdateBasicProblemDetailsRequest): unknown {
    const obj: any = {};
    if (message.Id !== "") {
      obj.Id = message.Id;
    }
    if (message.questionId !== undefined) {
      obj.questionId = message.questionId;
    }
    if (message.title !== undefined) {
      obj.title = message.title;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.difficulty !== undefined) {
      obj.difficulty = difficultyToJSON(message.difficulty);
    }
    if (message.active !== undefined) {
      obj.active = message.active;
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.constraints?.length) {
      obj.constraints = message.constraints;
    }
    if (message.examples?.length) {
      obj.examples = message.examples.map((e) => Example.toJSON(e));
    }
    if (message.solutionRoadmap?.length) {
      obj.solutionRoadmap = message.solutionRoadmap.map((e) => SolutionRoadmap.toJSON(e));
    }
    if (message.starterCodes?.length) {
      obj.starterCodes = message.starterCodes.map((e) => StarterCode.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateBasicProblemDetailsRequest>, I>>(
    base?: I,
  ): UpdateBasicProblemDetailsRequest {
    return UpdateBasicProblemDetailsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateBasicProblemDetailsRequest>, I>>(
    object: I,
  ): UpdateBasicProblemDetailsRequest {
    const message = createBaseUpdateBasicProblemDetailsRequest();
    message.Id = object.Id ?? "";
    message.questionId = object.questionId ?? undefined;
    message.title = object.title ?? undefined;
    message.description = object.description ?? undefined;
    message.difficulty = object.difficulty ?? undefined;
    message.active = object.active ?? undefined;
    message.tags = object.tags?.map((e) => e) || [];
    message.constraints = object.constraints?.map((e) => e) || [];
    message.examples = object.examples?.map((e) => Example.fromPartial(e)) || [];
    message.solutionRoadmap = object.solutionRoadmap?.map((e) => SolutionRoadmap.fromPartial(e)) || [];
    message.starterCodes = object.starterCodes?.map((e) => StarterCode.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAddTestCaseRequest(): AddTestCaseRequest {
  return { Id: "", testCaseCollectionType: 0, testCase: undefined };
}

export const AddTestCaseRequest: MessageFns<AddTestCaseRequest> = {
  encode(message: AddTestCaseRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.Id !== "") {
      writer.uint32(10).string(message.Id);
    }
    if (message.testCaseCollectionType !== 0) {
      writer.uint32(16).int32(message.testCaseCollectionType);
    }
    if (message.testCase !== undefined) {
      TestCase.encode(message.testCase, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddTestCaseRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddTestCaseRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.Id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.testCaseCollectionType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.testCase = TestCase.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddTestCaseRequest {
    return {
      Id: isSet(object.Id) ? globalThis.String(object.Id) : "",
      testCaseCollectionType: isSet(object.testCaseCollectionType)
        ? testCaseCollectionTypeFromJSON(object.testCaseCollectionType)
        : 0,
      testCase: isSet(object.testCase) ? TestCase.fromJSON(object.testCase) : undefined,
    };
  },

  toJSON(message: AddTestCaseRequest): unknown {
    const obj: any = {};
    if (message.Id !== "") {
      obj.Id = message.Id;
    }
    if (message.testCaseCollectionType !== 0) {
      obj.testCaseCollectionType = testCaseCollectionTypeToJSON(message.testCaseCollectionType);
    }
    if (message.testCase !== undefined) {
      obj.testCase = TestCase.toJSON(message.testCase);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddTestCaseRequest>, I>>(base?: I): AddTestCaseRequest {
    return AddTestCaseRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddTestCaseRequest>, I>>(object: I): AddTestCaseRequest {
    const message = createBaseAddTestCaseRequest();
    message.Id = object.Id ?? "";
    message.testCaseCollectionType = object.testCaseCollectionType ?? 0;
    message.testCase = (object.testCase !== undefined && object.testCase !== null)
      ? TestCase.fromPartial(object.testCase)
      : undefined;
    return message;
  },
};

function createBaseBulkUploadTestCasesRequest(): BulkUploadTestCasesRequest {
  return { Id: "", testCaseCollectionType: 0, testCase: [] };
}

export const BulkUploadTestCasesRequest: MessageFns<BulkUploadTestCasesRequest> = {
  encode(message: BulkUploadTestCasesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.Id !== "") {
      writer.uint32(10).string(message.Id);
    }
    if (message.testCaseCollectionType !== 0) {
      writer.uint32(16).int32(message.testCaseCollectionType);
    }
    for (const v of message.testCase) {
      TestCase.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BulkUploadTestCasesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBulkUploadTestCasesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.Id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.testCaseCollectionType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.testCase.push(TestCase.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BulkUploadTestCasesRequest {
    return {
      Id: isSet(object.Id) ? globalThis.String(object.Id) : "",
      testCaseCollectionType: isSet(object.testCaseCollectionType)
        ? testCaseCollectionTypeFromJSON(object.testCaseCollectionType)
        : 0,
      testCase: globalThis.Array.isArray(object?.testCase) ? object.testCase.map((e: any) => TestCase.fromJSON(e)) : [],
    };
  },

  toJSON(message: BulkUploadTestCasesRequest): unknown {
    const obj: any = {};
    if (message.Id !== "") {
      obj.Id = message.Id;
    }
    if (message.testCaseCollectionType !== 0) {
      obj.testCaseCollectionType = testCaseCollectionTypeToJSON(message.testCaseCollectionType);
    }
    if (message.testCase?.length) {
      obj.testCase = message.testCase.map((e) => TestCase.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BulkUploadTestCasesRequest>, I>>(base?: I): BulkUploadTestCasesRequest {
    return BulkUploadTestCasesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BulkUploadTestCasesRequest>, I>>(object: I): BulkUploadTestCasesRequest {
    const message = createBaseBulkUploadTestCasesRequest();
    message.Id = object.Id ?? "";
    message.testCaseCollectionType = object.testCaseCollectionType ?? 0;
    message.testCase = object.testCase?.map((e) => TestCase.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRemoveTestCaseRequest(): RemoveTestCaseRequest {
  return { Id: "", testCaseId: "", testCaseCollectionType: 0 };
}

export const RemoveTestCaseRequest: MessageFns<RemoveTestCaseRequest> = {
  encode(message: RemoveTestCaseRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.Id !== "") {
      writer.uint32(10).string(message.Id);
    }
    if (message.testCaseId !== "") {
      writer.uint32(18).string(message.testCaseId);
    }
    if (message.testCaseCollectionType !== 0) {
      writer.uint32(24).int32(message.testCaseCollectionType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RemoveTestCaseRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveTestCaseRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.Id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.testCaseId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.testCaseCollectionType = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RemoveTestCaseRequest {
    return {
      Id: isSet(object.Id) ? globalThis.String(object.Id) : "",
      testCaseId: isSet(object.testCaseId) ? globalThis.String(object.testCaseId) : "",
      testCaseCollectionType: isSet(object.testCaseCollectionType)
        ? testCaseCollectionTypeFromJSON(object.testCaseCollectionType)
        : 0,
    };
  },

  toJSON(message: RemoveTestCaseRequest): unknown {
    const obj: any = {};
    if (message.Id !== "") {
      obj.Id = message.Id;
    }
    if (message.testCaseId !== "") {
      obj.testCaseId = message.testCaseId;
    }
    if (message.testCaseCollectionType !== 0) {
      obj.testCaseCollectionType = testCaseCollectionTypeToJSON(message.testCaseCollectionType);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RemoveTestCaseRequest>, I>>(base?: I): RemoveTestCaseRequest {
    return RemoveTestCaseRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RemoveTestCaseRequest>, I>>(object: I): RemoveTestCaseRequest {
    const message = createBaseRemoveTestCaseRequest();
    message.Id = object.Id ?? "";
    message.testCaseId = object.testCaseId ?? "";
    message.testCaseCollectionType = object.testCaseCollectionType ?? 0;
    return message;
  },
};

function createBaseUpdateTemplateCode(): UpdateTemplateCode {
  return { language: undefined, submitWrapperCode: undefined, runWrapperCode: undefined };
}

export const UpdateTemplateCode: MessageFns<UpdateTemplateCode> = {
  encode(message: UpdateTemplateCode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.language !== undefined) {
      writer.uint32(8).int32(message.language);
    }
    if (message.submitWrapperCode !== undefined) {
      writer.uint32(18).string(message.submitWrapperCode);
    }
    if (message.runWrapperCode !== undefined) {
      writer.uint32(26).string(message.runWrapperCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateTemplateCode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateTemplateCode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.language = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.submitWrapperCode = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.runWrapperCode = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateTemplateCode {
    return {
      language: isSet(object.language) ? languageFromJSON(object.language) : undefined,
      submitWrapperCode: isSet(object.submitWrapperCode) ? globalThis.String(object.submitWrapperCode) : undefined,
      runWrapperCode: isSet(object.runWrapperCode) ? globalThis.String(object.runWrapperCode) : undefined,
    };
  },

  toJSON(message: UpdateTemplateCode): unknown {
    const obj: any = {};
    if (message.language !== undefined) {
      obj.language = languageToJSON(message.language);
    }
    if (message.submitWrapperCode !== undefined) {
      obj.submitWrapperCode = message.submitWrapperCode;
    }
    if (message.runWrapperCode !== undefined) {
      obj.runWrapperCode = message.runWrapperCode;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateTemplateCode>, I>>(base?: I): UpdateTemplateCode {
    return UpdateTemplateCode.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateTemplateCode>, I>>(object: I): UpdateTemplateCode {
    const message = createBaseUpdateTemplateCode();
    message.language = object.language ?? undefined;
    message.submitWrapperCode = object.submitWrapperCode ?? undefined;
    message.runWrapperCode = object.runWrapperCode ?? undefined;
    return message;
  },
};

function createBaseUpdateTemplateCodeRequest(): UpdateTemplateCodeRequest {
  return { Id: "", templateCodeId: "", updatedTemplateCode: undefined };
}

export const UpdateTemplateCodeRequest: MessageFns<UpdateTemplateCodeRequest> = {
  encode(message: UpdateTemplateCodeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.Id !== "") {
      writer.uint32(10).string(message.Id);
    }
    if (message.templateCodeId !== "") {
      writer.uint32(18).string(message.templateCodeId);
    }
    if (message.updatedTemplateCode !== undefined) {
      UpdateTemplateCode.encode(message.updatedTemplateCode, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateTemplateCodeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateTemplateCodeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.Id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.templateCodeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.updatedTemplateCode = UpdateTemplateCode.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateTemplateCodeRequest {
    return {
      Id: isSet(object.Id) ? globalThis.String(object.Id) : "",
      templateCodeId: isSet(object.templateCodeId) ? globalThis.String(object.templateCodeId) : "",
      updatedTemplateCode: isSet(object.updatedTemplateCode)
        ? UpdateTemplateCode.fromJSON(object.updatedTemplateCode)
        : undefined,
    };
  },

  toJSON(message: UpdateTemplateCodeRequest): unknown {
    const obj: any = {};
    if (message.Id !== "") {
      obj.Id = message.Id;
    }
    if (message.templateCodeId !== "") {
      obj.templateCodeId = message.templateCodeId;
    }
    if (message.updatedTemplateCode !== undefined) {
      obj.updatedTemplateCode = UpdateTemplateCode.toJSON(message.updatedTemplateCode);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateTemplateCodeRequest>, I>>(base?: I): UpdateTemplateCodeRequest {
    return UpdateTemplateCodeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateTemplateCodeRequest>, I>>(object: I): UpdateTemplateCodeRequest {
    const message = createBaseUpdateTemplateCodeRequest();
    message.Id = object.Id ?? "";
    message.templateCodeId = object.templateCodeId ?? "";
    message.updatedTemplateCode = (object.updatedTemplateCode !== undefined && object.updatedTemplateCode !== null)
      ? UpdateTemplateCode.fromPartial(object.updatedTemplateCode)
      : undefined;
    return message;
  },
};

function createBaseCheckQuestionIdRequest(): CheckQuestionIdRequest {
  return { questionId: "" };
}

export const CheckQuestionIdRequest: MessageFns<CheckQuestionIdRequest> = {
  encode(message: CheckQuestionIdRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.questionId !== "") {
      writer.uint32(10).string(message.questionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CheckQuestionIdRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckQuestionIdRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.questionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CheckQuestionIdRequest {
    return { questionId: isSet(object.questionId) ? globalThis.String(object.questionId) : "" };
  },

  toJSON(message: CheckQuestionIdRequest): unknown {
    const obj: any = {};
    if (message.questionId !== "") {
      obj.questionId = message.questionId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CheckQuestionIdRequest>, I>>(base?: I): CheckQuestionIdRequest {
    return CheckQuestionIdRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CheckQuestionIdRequest>, I>>(object: I): CheckQuestionIdRequest {
    const message = createBaseCheckQuestionIdRequest();
    message.questionId = object.questionId ?? "";
    return message;
  },
};

function createBaseCheckProblemTitleRequest(): CheckProblemTitleRequest {
  return { title: "" };
}

export const CheckProblemTitleRequest: MessageFns<CheckProblemTitleRequest> = {
  encode(message: CheckProblemTitleRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CheckProblemTitleRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckProblemTitleRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CheckProblemTitleRequest {
    return { title: isSet(object.title) ? globalThis.String(object.title) : "" };
  },

  toJSON(message: CheckProblemTitleRequest): unknown {
    const obj: any = {};
    if (message.title !== "") {
      obj.title = message.title;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CheckProblemTitleRequest>, I>>(base?: I): CheckProblemTitleRequest {
    return CheckProblemTitleRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CheckProblemTitleRequest>, I>>(object: I): CheckProblemTitleRequest {
    const message = createBaseCheckProblemTitleRequest();
    message.title = object.title ?? "";
    return message;
  },
};

function createBaseStats(): Stats {
  return { totalTestCase: 0, passedTestCase: 0, failedTestCase: 0, executionTimeMs: 0, memoryMB: 0 };
}

export const Stats: MessageFns<Stats> = {
  encode(message: Stats, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.totalTestCase !== 0) {
      writer.uint32(8).int32(message.totalTestCase);
    }
    if (message.passedTestCase !== 0) {
      writer.uint32(16).int32(message.passedTestCase);
    }
    if (message.failedTestCase !== 0) {
      writer.uint32(24).int32(message.failedTestCase);
    }
    if (message.executionTimeMs !== 0) {
      writer.uint32(33).double(message.executionTimeMs);
    }
    if (message.memoryMB !== 0) {
      writer.uint32(41).double(message.memoryMB);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Stats {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.totalTestCase = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.passedTestCase = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.failedTestCase = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.executionTimeMs = reader.double();
          continue;
        }
        case 5: {
          if (tag !== 41) {
            break;
          }

          message.memoryMB = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Stats {
    return {
      totalTestCase: isSet(object.totalTestCase) ? globalThis.Number(object.totalTestCase) : 0,
      passedTestCase: isSet(object.passedTestCase) ? globalThis.Number(object.passedTestCase) : 0,
      failedTestCase: isSet(object.failedTestCase) ? globalThis.Number(object.failedTestCase) : 0,
      executionTimeMs: isSet(object.executionTimeMs) ? globalThis.Number(object.executionTimeMs) : 0,
      memoryMB: isSet(object.memoryMB) ? globalThis.Number(object.memoryMB) : 0,
    };
  },

  toJSON(message: Stats): unknown {
    const obj: any = {};
    if (message.totalTestCase !== 0) {
      obj.totalTestCase = Math.round(message.totalTestCase);
    }
    if (message.passedTestCase !== 0) {
      obj.passedTestCase = Math.round(message.passedTestCase);
    }
    if (message.failedTestCase !== 0) {
      obj.failedTestCase = Math.round(message.failedTestCase);
    }
    if (message.executionTimeMs !== 0) {
      obj.executionTimeMs = message.executionTimeMs;
    }
    if (message.memoryMB !== 0) {
      obj.memoryMB = message.memoryMB;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Stats>, I>>(base?: I): Stats {
    return Stats.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Stats>, I>>(object: I): Stats {
    const message = createBaseStats();
    message.totalTestCase = object.totalTestCase ?? 0;
    message.passedTestCase = object.passedTestCase ?? 0;
    message.failedTestCase = object.failedTestCase ?? 0;
    message.executionTimeMs = object.executionTimeMs ?? 0;
    message.memoryMB = object.memoryMB ?? 0;
    return message;
  },
};

function createBaseFailedTestCase(): FailedTestCase {
  return { index: 0, input: "", output: "", expectedOutput: "" };
}

export const FailedTestCase: MessageFns<FailedTestCase> = {
  encode(message: FailedTestCase, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.index !== 0) {
      writer.uint32(8).int32(message.index);
    }
    if (message.input !== "") {
      writer.uint32(18).string(message.input);
    }
    if (message.output !== "") {
      writer.uint32(26).string(message.output);
    }
    if (message.expectedOutput !== "") {
      writer.uint32(34).string(message.expectedOutput);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FailedTestCase {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFailedTestCase();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.index = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.input = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.output = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.expectedOutput = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FailedTestCase {
    return {
      index: isSet(object.index) ? globalThis.Number(object.index) : 0,
      input: isSet(object.input) ? globalThis.String(object.input) : "",
      output: isSet(object.output) ? globalThis.String(object.output) : "",
      expectedOutput: isSet(object.expectedOutput) ? globalThis.String(object.expectedOutput) : "",
    };
  },

  toJSON(message: FailedTestCase): unknown {
    const obj: any = {};
    if (message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    if (message.input !== "") {
      obj.input = message.input;
    }
    if (message.output !== "") {
      obj.output = message.output;
    }
    if (message.expectedOutput !== "") {
      obj.expectedOutput = message.expectedOutput;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FailedTestCase>, I>>(base?: I): FailedTestCase {
    return FailedTestCase.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FailedTestCase>, I>>(object: I): FailedTestCase {
    const message = createBaseFailedTestCase();
    message.index = object.index ?? 0;
    message.input = object.input ?? "";
    message.output = object.output ?? "";
    message.expectedOutput = object.expectedOutput ?? "";
    return message;
  },
};

function createBaseExecutionResult(): ExecutionResult {
  return { stats: undefined, failedTestCase: undefined };
}

export const ExecutionResult: MessageFns<ExecutionResult> = {
  encode(message: ExecutionResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.stats !== undefined) {
      Stats.encode(message.stats, writer.uint32(10).fork()).join();
    }
    if (message.failedTestCase !== undefined) {
      FailedTestCase.encode(message.failedTestCase, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExecutionResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecutionResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.stats = Stats.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.failedTestCase = FailedTestCase.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecutionResult {
    return {
      stats: isSet(object.stats) ? Stats.fromJSON(object.stats) : undefined,
      failedTestCase: isSet(object.failedTestCase) ? FailedTestCase.fromJSON(object.failedTestCase) : undefined,
    };
  },

  toJSON(message: ExecutionResult): unknown {
    const obj: any = {};
    if (message.stats !== undefined) {
      obj.stats = Stats.toJSON(message.stats);
    }
    if (message.failedTestCase !== undefined) {
      obj.failedTestCase = FailedTestCase.toJSON(message.failedTestCase);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExecutionResult>, I>>(base?: I): ExecutionResult {
    return ExecutionResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExecutionResult>, I>>(object: I): ExecutionResult {
    const message = createBaseExecutionResult();
    message.stats = (object.stats !== undefined && object.stats !== null) ? Stats.fromPartial(object.stats) : undefined;
    message.failedTestCase = (object.failedTestCase !== undefined && object.failedTestCase !== null)
      ? FailedTestCase.fromPartial(object.failedTestCase)
      : undefined;
    return message;
  },
};

function createBaseSubmission(): Submission {
  return {
    Id: "",
    problemId: "",
    userId: "",
    username: "",
    country: "",
    title: "",
    battleId: undefined,
    score: 0,
    status: "",
    language: 0,
    userCode: "",
    executionResult: undefined,
    difficulty: 0,
    isFirst: false,
    isAiAssisted: false,
    hintsUsed: 0,
    updatedAt: "",
    createdAt: "",
  };
}

export const Submission: MessageFns<Submission> = {
  encode(message: Submission, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.Id !== "") {
      writer.uint32(10).string(message.Id);
    }
    if (message.problemId !== "") {
      writer.uint32(18).string(message.problemId);
    }
    if (message.userId !== "") {
      writer.uint32(26).string(message.userId);
    }
    if (message.username !== "") {
      writer.uint32(34).string(message.username);
    }
    if (message.country !== "") {
      writer.uint32(42).string(message.country);
    }
    if (message.title !== "") {
      writer.uint32(50).string(message.title);
    }
    if (message.battleId !== undefined) {
      writer.uint32(58).string(message.battleId);
    }
    if (message.score !== 0) {
      writer.uint32(64).int32(message.score);
    }
    if (message.status !== "") {
      writer.uint32(74).string(message.status);
    }
    if (message.language !== 0) {
      writer.uint32(80).int32(message.language);
    }
    if (message.userCode !== "") {
      writer.uint32(90).string(message.userCode);
    }
    if (message.executionResult !== undefined) {
      ExecutionResult.encode(message.executionResult, writer.uint32(98).fork()).join();
    }
    if (message.difficulty !== 0) {
      writer.uint32(104).int32(message.difficulty);
    }
    if (message.isFirst !== false) {
      writer.uint32(112).bool(message.isFirst);
    }
    if (message.isAiAssisted !== false) {
      writer.uint32(120).bool(message.isAiAssisted);
    }
    if (message.hintsUsed !== 0) {
      writer.uint32(128).int32(message.hintsUsed);
    }
    if (message.updatedAt !== "") {
      writer.uint32(138).string(message.updatedAt);
    }
    if (message.createdAt !== "") {
      writer.uint32(146).string(message.createdAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Submission {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubmission();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.Id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.problemId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.country = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.battleId = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.score = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.language = reader.int32() as any;
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.userCode = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.executionResult = ExecutionResult.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.difficulty = reader.int32() as any;
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.isFirst = reader.bool();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.isAiAssisted = reader.bool();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.hintsUsed = reader.int32();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Submission {
    return {
      Id: isSet(object.Id) ? globalThis.String(object.Id) : "",
      problemId: isSet(object.problemId) ? globalThis.String(object.problemId) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      country: isSet(object.country) ? globalThis.String(object.country) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      battleId: isSet(object.battleId) ? globalThis.String(object.battleId) : undefined,
      score: isSet(object.score) ? globalThis.Number(object.score) : 0,
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      language: isSet(object.language) ? languageFromJSON(object.language) : 0,
      userCode: isSet(object.userCode) ? globalThis.String(object.userCode) : "",
      executionResult: isSet(object.executionResult) ? ExecutionResult.fromJSON(object.executionResult) : undefined,
      difficulty: isSet(object.difficulty) ? difficultyFromJSON(object.difficulty) : 0,
      isFirst: isSet(object.isFirst) ? globalThis.Boolean(object.isFirst) : false,
      isAiAssisted: isSet(object.isAiAssisted) ? globalThis.Boolean(object.isAiAssisted) : false,
      hintsUsed: isSet(object.hintsUsed) ? globalThis.Number(object.hintsUsed) : 0,
      updatedAt: isSet(object.updatedAt) ? globalThis.String(object.updatedAt) : "",
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
    };
  },

  toJSON(message: Submission): unknown {
    const obj: any = {};
    if (message.Id !== "") {
      obj.Id = message.Id;
    }
    if (message.problemId !== "") {
      obj.problemId = message.problemId;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.country !== "") {
      obj.country = message.country;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.battleId !== undefined) {
      obj.battleId = message.battleId;
    }
    if (message.score !== 0) {
      obj.score = Math.round(message.score);
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.language !== 0) {
      obj.language = languageToJSON(message.language);
    }
    if (message.userCode !== "") {
      obj.userCode = message.userCode;
    }
    if (message.executionResult !== undefined) {
      obj.executionResult = ExecutionResult.toJSON(message.executionResult);
    }
    if (message.difficulty !== 0) {
      obj.difficulty = difficultyToJSON(message.difficulty);
    }
    if (message.isFirst !== false) {
      obj.isFirst = message.isFirst;
    }
    if (message.isAiAssisted !== false) {
      obj.isAiAssisted = message.isAiAssisted;
    }
    if (message.hintsUsed !== 0) {
      obj.hintsUsed = Math.round(message.hintsUsed);
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Submission>, I>>(base?: I): Submission {
    return Submission.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Submission>, I>>(object: I): Submission {
    const message = createBaseSubmission();
    message.Id = object.Id ?? "";
    message.problemId = object.problemId ?? "";
    message.userId = object.userId ?? "";
    message.username = object.username ?? "";
    message.country = object.country ?? "";
    message.title = object.title ?? "";
    message.battleId = object.battleId ?? undefined;
    message.score = object.score ?? 0;
    message.status = object.status ?? "";
    message.language = object.language ?? 0;
    message.userCode = object.userCode ?? "";
    message.executionResult = (object.executionResult !== undefined && object.executionResult !== null)
      ? ExecutionResult.fromPartial(object.executionResult)
      : undefined;
    message.difficulty = object.difficulty ?? 0;
    message.isFirst = object.isFirst ?? false;
    message.isAiAssisted = object.isAiAssisted ?? false;
    message.hintsUsed = object.hintsUsed ?? 0;
    message.updatedAt = object.updatedAt ?? "";
    message.createdAt = object.createdAt ?? "";
    return message;
  },
};

function createBaseCreateSubmissionRequest(): CreateSubmissionRequest {
  return {
    problemId: "",
    userId: "",
    username: "",
    battleId: undefined,
    country: undefined,
    title: "",
    language: 0,
    userCode: "",
    difficulty: 0,
  };
}

export const CreateSubmissionRequest: MessageFns<CreateSubmissionRequest> = {
  encode(message: CreateSubmissionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.problemId !== "") {
      writer.uint32(10).string(message.problemId);
    }
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    if (message.username !== "") {
      writer.uint32(26).string(message.username);
    }
    if (message.battleId !== undefined) {
      writer.uint32(34).string(message.battleId);
    }
    if (message.country !== undefined) {
      writer.uint32(42).string(message.country);
    }
    if (message.title !== "") {
      writer.uint32(50).string(message.title);
    }
    if (message.language !== 0) {
      writer.uint32(56).int32(message.language);
    }
    if (message.userCode !== "") {
      writer.uint32(66).string(message.userCode);
    }
    if (message.difficulty !== 0) {
      writer.uint32(72).int32(message.difficulty);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateSubmissionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateSubmissionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.problemId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.battleId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.country = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.language = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.userCode = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.difficulty = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateSubmissionRequest {
    return {
      problemId: isSet(object.problemId) ? globalThis.String(object.problemId) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      battleId: isSet(object.battleId) ? globalThis.String(object.battleId) : undefined,
      country: isSet(object.country) ? globalThis.String(object.country) : undefined,
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      language: isSet(object.language) ? languageFromJSON(object.language) : 0,
      userCode: isSet(object.userCode) ? globalThis.String(object.userCode) : "",
      difficulty: isSet(object.difficulty) ? difficultyFromJSON(object.difficulty) : 0,
    };
  },

  toJSON(message: CreateSubmissionRequest): unknown {
    const obj: any = {};
    if (message.problemId !== "") {
      obj.problemId = message.problemId;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.battleId !== undefined) {
      obj.battleId = message.battleId;
    }
    if (message.country !== undefined) {
      obj.country = message.country;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.language !== 0) {
      obj.language = languageToJSON(message.language);
    }
    if (message.userCode !== "") {
      obj.userCode = message.userCode;
    }
    if (message.difficulty !== 0) {
      obj.difficulty = difficultyToJSON(message.difficulty);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateSubmissionRequest>, I>>(base?: I): CreateSubmissionRequest {
    return CreateSubmissionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateSubmissionRequest>, I>>(object: I): CreateSubmissionRequest {
    const message = createBaseCreateSubmissionRequest();
    message.problemId = object.problemId ?? "";
    message.userId = object.userId ?? "";
    message.username = object.username ?? "";
    message.battleId = object.battleId ?? undefined;
    message.country = object.country ?? undefined;
    message.title = object.title ?? "";
    message.language = object.language ?? 0;
    message.userCode = object.userCode ?? "";
    message.difficulty = object.difficulty ?? 0;
    return message;
  },
};

function createBaseUpdateSubmissionRequest(): UpdateSubmissionRequest {
  return { Id: "", status: "", executionResult: undefined };
}

export const UpdateSubmissionRequest: MessageFns<UpdateSubmissionRequest> = {
  encode(message: UpdateSubmissionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.Id !== "") {
      writer.uint32(10).string(message.Id);
    }
    if (message.status !== "") {
      writer.uint32(26).string(message.status);
    }
    if (message.executionResult !== undefined) {
      ExecutionResult.encode(message.executionResult, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateSubmissionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateSubmissionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.Id = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.executionResult = ExecutionResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateSubmissionRequest {
    return {
      Id: isSet(object.Id) ? globalThis.String(object.Id) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      executionResult: isSet(object.executionResult) ? ExecutionResult.fromJSON(object.executionResult) : undefined,
    };
  },

  toJSON(message: UpdateSubmissionRequest): unknown {
    const obj: any = {};
    if (message.Id !== "") {
      obj.Id = message.Id;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.executionResult !== undefined) {
      obj.executionResult = ExecutionResult.toJSON(message.executionResult);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateSubmissionRequest>, I>>(base?: I): UpdateSubmissionRequest {
    return UpdateSubmissionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateSubmissionRequest>, I>>(object: I): UpdateSubmissionRequest {
    const message = createBaseUpdateSubmissionRequest();
    message.Id = object.Id ?? "";
    message.status = object.status ?? "";
    message.executionResult = (object.executionResult !== undefined && object.executionResult !== null)
      ? ExecutionResult.fromPartial(object.executionResult)
      : undefined;
    return message;
  },
};

function createBaseGetSubmissionsRequest(): GetSubmissionsRequest {
  return { page: 0, limit: 0, problemId: undefined, battleId: undefined, userId: undefined };
}

export const GetSubmissionsRequest: MessageFns<GetSubmissionsRequest> = {
  encode(message: GetSubmissionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.page !== 0) {
      writer.uint32(8).int32(message.page);
    }
    if (message.limit !== 0) {
      writer.uint32(16).int32(message.limit);
    }
    if (message.problemId !== undefined) {
      writer.uint32(26).string(message.problemId);
    }
    if (message.battleId !== undefined) {
      writer.uint32(34).string(message.battleId);
    }
    if (message.userId !== undefined) {
      writer.uint32(42).string(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSubmissionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSubmissionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.problemId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.battleId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSubmissionsRequest {
    return {
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
      problemId: isSet(object.problemId) ? globalThis.String(object.problemId) : undefined,
      battleId: isSet(object.battleId) ? globalThis.String(object.battleId) : undefined,
      userId: isSet(object.userId) ? globalThis.String(object.userId) : undefined,
    };
  },

  toJSON(message: GetSubmissionsRequest): unknown {
    const obj: any = {};
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    if (message.problemId !== undefined) {
      obj.problemId = message.problemId;
    }
    if (message.battleId !== undefined) {
      obj.battleId = message.battleId;
    }
    if (message.userId !== undefined) {
      obj.userId = message.userId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetSubmissionsRequest>, I>>(base?: I): GetSubmissionsRequest {
    return GetSubmissionsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSubmissionsRequest>, I>>(object: I): GetSubmissionsRequest {
    const message = createBaseGetSubmissionsRequest();
    message.page = object.page ?? 0;
    message.limit = object.limit ?? 0;
    message.problemId = object.problemId ?? undefined;
    message.battleId = object.battleId ?? undefined;
    message.userId = object.userId ?? undefined;
    return message;
  },
};

function createBaseGetSubmissionsResponse(): GetSubmissionsResponse {
  return { submissions: [], totalPage: 0, currentPage: 0, totalItems: 0 };
}

export const GetSubmissionsResponse: MessageFns<GetSubmissionsResponse> = {
  encode(message: GetSubmissionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.submissions) {
      Submission.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.totalPage !== 0) {
      writer.uint32(16).int32(message.totalPage);
    }
    if (message.currentPage !== 0) {
      writer.uint32(24).int32(message.currentPage);
    }
    if (message.totalItems !== 0) {
      writer.uint32(32).int32(message.totalItems);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSubmissionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSubmissionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.submissions.push(Submission.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.totalPage = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.currentPage = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.totalItems = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSubmissionsResponse {
    return {
      submissions: globalThis.Array.isArray(object?.submissions)
        ? object.submissions.map((e: any) => Submission.fromJSON(e))
        : [],
      totalPage: isSet(object.totalPage) ? globalThis.Number(object.totalPage) : 0,
      currentPage: isSet(object.currentPage) ? globalThis.Number(object.currentPage) : 0,
      totalItems: isSet(object.totalItems) ? globalThis.Number(object.totalItems) : 0,
    };
  },

  toJSON(message: GetSubmissionsResponse): unknown {
    const obj: any = {};
    if (message.submissions?.length) {
      obj.submissions = message.submissions.map((e) => Submission.toJSON(e));
    }
    if (message.totalPage !== 0) {
      obj.totalPage = Math.round(message.totalPage);
    }
    if (message.currentPage !== 0) {
      obj.currentPage = Math.round(message.currentPage);
    }
    if (message.totalItems !== 0) {
      obj.totalItems = Math.round(message.totalItems);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetSubmissionsResponse>, I>>(base?: I): GetSubmissionsResponse {
    return GetSubmissionsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSubmissionsResponse>, I>>(object: I): GetSubmissionsResponse {
    const message = createBaseGetSubmissionsResponse();
    message.submissions = object.submissions?.map((e) => Submission.fromPartial(e)) || [];
    message.totalPage = object.totalPage ?? 0;
    message.currentPage = object.currentPage ?? 0;
    message.totalItems = object.totalItems ?? 0;
    return message;
  },
};

function createBaseListProblemSpecificSubmissionRequest(): ListProblemSpecificSubmissionRequest {
  return { userId: "", problemId: "", limit: 0, nextCursor: undefined };
}

export const ListProblemSpecificSubmissionRequest: MessageFns<ListProblemSpecificSubmissionRequest> = {
  encode(message: ListProblemSpecificSubmissionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.problemId !== "") {
      writer.uint32(18).string(message.problemId);
    }
    if (message.limit !== 0) {
      writer.uint32(24).int32(message.limit);
    }
    if (message.nextCursor !== undefined) {
      writer.uint32(34).string(message.nextCursor);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListProblemSpecificSubmissionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListProblemSpecificSubmissionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.problemId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.nextCursor = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListProblemSpecificSubmissionRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      problemId: isSet(object.problemId) ? globalThis.String(object.problemId) : "",
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
      nextCursor: isSet(object.nextCursor) ? globalThis.String(object.nextCursor) : undefined,
    };
  },

  toJSON(message: ListProblemSpecificSubmissionRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.problemId !== "") {
      obj.problemId = message.problemId;
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    if (message.nextCursor !== undefined) {
      obj.nextCursor = message.nextCursor;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListProblemSpecificSubmissionRequest>, I>>(
    base?: I,
  ): ListProblemSpecificSubmissionRequest {
    return ListProblemSpecificSubmissionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListProblemSpecificSubmissionRequest>, I>>(
    object: I,
  ): ListProblemSpecificSubmissionRequest {
    const message = createBaseListProblemSpecificSubmissionRequest();
    message.userId = object.userId ?? "";
    message.problemId = object.problemId ?? "";
    message.limit = object.limit ?? 0;
    message.nextCursor = object.nextCursor ?? undefined;
    return message;
  },
};

function createBaseProblemSpecificSubmissions(): ProblemSpecificSubmissions {
  return {
    Id: "",
    status: "",
    language: 0,
    executionResult: undefined,
    userCode: "",
    isAiAssisted: false,
    hintsUsed: 0,
    createdAt: "",
  };
}

export const ProblemSpecificSubmissions: MessageFns<ProblemSpecificSubmissions> = {
  encode(message: ProblemSpecificSubmissions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.Id !== "") {
      writer.uint32(10).string(message.Id);
    }
    if (message.status !== "") {
      writer.uint32(18).string(message.status);
    }
    if (message.language !== 0) {
      writer.uint32(24).int32(message.language);
    }
    if (message.executionResult !== undefined) {
      ExecutionResult.encode(message.executionResult, writer.uint32(34).fork()).join();
    }
    if (message.userCode !== "") {
      writer.uint32(42).string(message.userCode);
    }
    if (message.isAiAssisted !== false) {
      writer.uint32(48).bool(message.isAiAssisted);
    }
    if (message.hintsUsed !== 0) {
      writer.uint32(56).int32(message.hintsUsed);
    }
    if (message.createdAt !== "") {
      writer.uint32(66).string(message.createdAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProblemSpecificSubmissions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProblemSpecificSubmissions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.Id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.language = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.executionResult = ExecutionResult.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.userCode = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.isAiAssisted = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.hintsUsed = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProblemSpecificSubmissions {
    return {
      Id: isSet(object.Id) ? globalThis.String(object.Id) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      language: isSet(object.language) ? languageFromJSON(object.language) : 0,
      executionResult: isSet(object.executionResult) ? ExecutionResult.fromJSON(object.executionResult) : undefined,
      userCode: isSet(object.userCode) ? globalThis.String(object.userCode) : "",
      isAiAssisted: isSet(object.isAiAssisted) ? globalThis.Boolean(object.isAiAssisted) : false,
      hintsUsed: isSet(object.hintsUsed) ? globalThis.Number(object.hintsUsed) : 0,
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
    };
  },

  toJSON(message: ProblemSpecificSubmissions): unknown {
    const obj: any = {};
    if (message.Id !== "") {
      obj.Id = message.Id;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.language !== 0) {
      obj.language = languageToJSON(message.language);
    }
    if (message.executionResult !== undefined) {
      obj.executionResult = ExecutionResult.toJSON(message.executionResult);
    }
    if (message.userCode !== "") {
      obj.userCode = message.userCode;
    }
    if (message.isAiAssisted !== false) {
      obj.isAiAssisted = message.isAiAssisted;
    }
    if (message.hintsUsed !== 0) {
      obj.hintsUsed = Math.round(message.hintsUsed);
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProblemSpecificSubmissions>, I>>(base?: I): ProblemSpecificSubmissions {
    return ProblemSpecificSubmissions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProblemSpecificSubmissions>, I>>(object: I): ProblemSpecificSubmissions {
    const message = createBaseProblemSpecificSubmissions();
    message.Id = object.Id ?? "";
    message.status = object.status ?? "";
    message.language = object.language ?? 0;
    message.executionResult = (object.executionResult !== undefined && object.executionResult !== null)
      ? ExecutionResult.fromPartial(object.executionResult)
      : undefined;
    message.userCode = object.userCode ?? "";
    message.isAiAssisted = object.isAiAssisted ?? false;
    message.hintsUsed = object.hintsUsed ?? 0;
    message.createdAt = object.createdAt ?? "";
    return message;
  },
};

function createBaseListProblemSpecificSubmissionResponse(): ListProblemSpecificSubmissionResponse {
  return { submissions: [], nextCursor: "", hasMore: false };
}

export const ListProblemSpecificSubmissionResponse: MessageFns<ListProblemSpecificSubmissionResponse> = {
  encode(message: ListProblemSpecificSubmissionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.submissions) {
      ProblemSpecificSubmissions.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextCursor !== "") {
      writer.uint32(18).string(message.nextCursor);
    }
    if (message.hasMore !== false) {
      writer.uint32(24).bool(message.hasMore);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListProblemSpecificSubmissionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListProblemSpecificSubmissionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.submissions.push(ProblemSpecificSubmissions.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nextCursor = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.hasMore = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListProblemSpecificSubmissionResponse {
    return {
      submissions: globalThis.Array.isArray(object?.submissions)
        ? object.submissions.map((e: any) => ProblemSpecificSubmissions.fromJSON(e))
        : [],
      nextCursor: isSet(object.nextCursor) ? globalThis.String(object.nextCursor) : "",
      hasMore: isSet(object.hasMore) ? globalThis.Boolean(object.hasMore) : false,
    };
  },

  toJSON(message: ListProblemSpecificSubmissionResponse): unknown {
    const obj: any = {};
    if (message.submissions?.length) {
      obj.submissions = message.submissions.map((e) => ProblemSpecificSubmissions.toJSON(e));
    }
    if (message.nextCursor !== "") {
      obj.nextCursor = message.nextCursor;
    }
    if (message.hasMore !== false) {
      obj.hasMore = message.hasMore;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListProblemSpecificSubmissionResponse>, I>>(
    base?: I,
  ): ListProblemSpecificSubmissionResponse {
    return ListProblemSpecificSubmissionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListProblemSpecificSubmissionResponse>, I>>(
    object: I,
  ): ListProblemSpecificSubmissionResponse {
    const message = createBaseListProblemSpecificSubmissionResponse();
    message.submissions = object.submissions?.map((e) => ProblemSpecificSubmissions.fromPartial(e)) || [];
    message.nextCursor = object.nextCursor ?? "";
    message.hasMore = object.hasMore ?? false;
    return message;
  },
};

function createBaseListTopKGlobalLeaderboardRequest(): ListTopKGlobalLeaderboardRequest {
  return { k: 0 };
}

export const ListTopKGlobalLeaderboardRequest: MessageFns<ListTopKGlobalLeaderboardRequest> = {
  encode(message: ListTopKGlobalLeaderboardRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.k !== 0) {
      writer.uint32(8).int32(message.k);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListTopKGlobalLeaderboardRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTopKGlobalLeaderboardRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.k = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListTopKGlobalLeaderboardRequest {
    return { k: isSet(object.k) ? globalThis.Number(object.k) : 0 };
  },

  toJSON(message: ListTopKGlobalLeaderboardRequest): unknown {
    const obj: any = {};
    if (message.k !== 0) {
      obj.k = Math.round(message.k);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListTopKGlobalLeaderboardRequest>, I>>(
    base?: I,
  ): ListTopKGlobalLeaderboardRequest {
    return ListTopKGlobalLeaderboardRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListTopKGlobalLeaderboardRequest>, I>>(
    object: I,
  ): ListTopKGlobalLeaderboardRequest {
    const message = createBaseListTopKGlobalLeaderboardRequest();
    message.k = object.k ?? 0;
    return message;
  },
};

function createBaseLeaderboardUser(): LeaderboardUser {
  return { id: "", entity: undefined, score: 0, username: "", problemsSolved: undefined, rank: undefined };
}

export const LeaderboardUser: MessageFns<LeaderboardUser> = {
  encode(message: LeaderboardUser, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.entity !== undefined) {
      writer.uint32(18).string(message.entity);
    }
    if (message.score !== 0) {
      writer.uint32(24).int32(message.score);
    }
    if (message.username !== "") {
      writer.uint32(34).string(message.username);
    }
    if (message.problemsSolved !== undefined) {
      writer.uint32(40).int32(message.problemsSolved);
    }
    if (message.rank !== undefined) {
      writer.uint32(48).int32(message.rank);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LeaderboardUser {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLeaderboardUser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.entity = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.score = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.problemsSolved = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.rank = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LeaderboardUser {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      entity: isSet(object.entity) ? globalThis.String(object.entity) : undefined,
      score: isSet(object.score) ? globalThis.Number(object.score) : 0,
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      problemsSolved: isSet(object.problemsSolved) ? globalThis.Number(object.problemsSolved) : undefined,
      rank: isSet(object.rank) ? globalThis.Number(object.rank) : undefined,
    };
  },

  toJSON(message: LeaderboardUser): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.entity !== undefined) {
      obj.entity = message.entity;
    }
    if (message.score !== 0) {
      obj.score = Math.round(message.score);
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.problemsSolved !== undefined) {
      obj.problemsSolved = Math.round(message.problemsSolved);
    }
    if (message.rank !== undefined) {
      obj.rank = Math.round(message.rank);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LeaderboardUser>, I>>(base?: I): LeaderboardUser {
    return LeaderboardUser.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LeaderboardUser>, I>>(object: I): LeaderboardUser {
    const message = createBaseLeaderboardUser();
    message.id = object.id ?? "";
    message.entity = object.entity ?? undefined;
    message.score = object.score ?? 0;
    message.username = object.username ?? "";
    message.problemsSolved = object.problemsSolved ?? undefined;
    message.rank = object.rank ?? undefined;
    return message;
  },
};

function createBaseListTopKGlobalLeaderboardResponse(): ListTopKGlobalLeaderboardResponse {
  return { users: [] };
}

export const ListTopKGlobalLeaderboardResponse: MessageFns<ListTopKGlobalLeaderboardResponse> = {
  encode(message: ListTopKGlobalLeaderboardResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.users) {
      LeaderboardUser.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListTopKGlobalLeaderboardResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTopKGlobalLeaderboardResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.users.push(LeaderboardUser.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListTopKGlobalLeaderboardResponse {
    return {
      users: globalThis.Array.isArray(object?.users) ? object.users.map((e: any) => LeaderboardUser.fromJSON(e)) : [],
    };
  },

  toJSON(message: ListTopKGlobalLeaderboardResponse): unknown {
    const obj: any = {};
    if (message.users?.length) {
      obj.users = message.users.map((e) => LeaderboardUser.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListTopKGlobalLeaderboardResponse>, I>>(
    base?: I,
  ): ListTopKGlobalLeaderboardResponse {
    return ListTopKGlobalLeaderboardResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListTopKGlobalLeaderboardResponse>, I>>(
    object: I,
  ): ListTopKGlobalLeaderboardResponse {
    const message = createBaseListTopKGlobalLeaderboardResponse();
    message.users = object.users?.map((e) => LeaderboardUser.fromPartial(e)) || [];
    return message;
  },
};

function createBaseListTopKCountryLeaderboardRequest(): ListTopKCountryLeaderboardRequest {
  return { country: "", k: 0 };
}

export const ListTopKCountryLeaderboardRequest: MessageFns<ListTopKCountryLeaderboardRequest> = {
  encode(message: ListTopKCountryLeaderboardRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.country !== "") {
      writer.uint32(10).string(message.country);
    }
    if (message.k !== 0) {
      writer.uint32(16).int32(message.k);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListTopKCountryLeaderboardRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTopKCountryLeaderboardRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.country = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.k = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListTopKCountryLeaderboardRequest {
    return {
      country: isSet(object.country) ? globalThis.String(object.country) : "",
      k: isSet(object.k) ? globalThis.Number(object.k) : 0,
    };
  },

  toJSON(message: ListTopKCountryLeaderboardRequest): unknown {
    const obj: any = {};
    if (message.country !== "") {
      obj.country = message.country;
    }
    if (message.k !== 0) {
      obj.k = Math.round(message.k);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListTopKCountryLeaderboardRequest>, I>>(
    base?: I,
  ): ListTopKCountryLeaderboardRequest {
    return ListTopKCountryLeaderboardRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListTopKCountryLeaderboardRequest>, I>>(
    object: I,
  ): ListTopKCountryLeaderboardRequest {
    const message = createBaseListTopKCountryLeaderboardRequest();
    message.country = object.country ?? "";
    message.k = object.k ?? 0;
    return message;
  },
};

function createBaseListTopKCountryLeaderboardResponse(): ListTopKCountryLeaderboardResponse {
  return { users: [] };
}

export const ListTopKCountryLeaderboardResponse: MessageFns<ListTopKCountryLeaderboardResponse> = {
  encode(message: ListTopKCountryLeaderboardResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.users) {
      LeaderboardUser.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListTopKCountryLeaderboardResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTopKCountryLeaderboardResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.users.push(LeaderboardUser.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListTopKCountryLeaderboardResponse {
    return {
      users: globalThis.Array.isArray(object?.users) ? object.users.map((e: any) => LeaderboardUser.fromJSON(e)) : [],
    };
  },

  toJSON(message: ListTopKCountryLeaderboardResponse): unknown {
    const obj: any = {};
    if (message.users?.length) {
      obj.users = message.users.map((e) => LeaderboardUser.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListTopKCountryLeaderboardResponse>, I>>(
    base?: I,
  ): ListTopKCountryLeaderboardResponse {
    return ListTopKCountryLeaderboardResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListTopKCountryLeaderboardResponse>, I>>(
    object: I,
  ): ListTopKCountryLeaderboardResponse {
    const message = createBaseListTopKCountryLeaderboardResponse();
    message.users = object.users?.map((e) => LeaderboardUser.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetDashboardStatsRequest(): GetDashboardStatsRequest {
  return { userId: "", userTimezone: "" };
}

export const GetDashboardStatsRequest: MessageFns<GetDashboardStatsRequest> = {
  encode(message: GetDashboardStatsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.userTimezone !== "") {
      writer.uint32(18).string(message.userTimezone);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDashboardStatsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDashboardStatsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userTimezone = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDashboardStatsRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      userTimezone: isSet(object.userTimezone) ? globalThis.String(object.userTimezone) : "",
    };
  },

  toJSON(message: GetDashboardStatsRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.userTimezone !== "") {
      obj.userTimezone = message.userTimezone;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetDashboardStatsRequest>, I>>(base?: I): GetDashboardStatsRequest {
    return GetDashboardStatsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetDashboardStatsRequest>, I>>(object: I): GetDashboardStatsRequest {
    const message = createBaseGetDashboardStatsRequest();
    message.userId = object.userId ?? "";
    message.userTimezone = object.userTimezone ?? "";
    return message;
  },
};

function createBaseActivity(): Activity {
  return { date: "", count: 0 };
}

export const Activity: MessageFns<Activity> = {
  encode(message: Activity, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.date !== "") {
      writer.uint32(10).string(message.date);
    }
    if (message.count !== 0) {
      writer.uint32(16).int32(message.count);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Activity {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseActivity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.date = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.count = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Activity {
    return {
      date: isSet(object.date) ? globalThis.String(object.date) : "",
      count: isSet(object.count) ? globalThis.Number(object.count) : 0,
    };
  },

  toJSON(message: Activity): unknown {
    const obj: any = {};
    if (message.date !== "") {
      obj.date = message.date;
    }
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Activity>, I>>(base?: I): Activity {
    return Activity.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Activity>, I>>(object: I): Activity {
    const message = createBaseActivity();
    message.date = object.date ?? "";
    message.count = object.count ?? 0;
    return message;
  },
};

function createBaseRecentActivity(): RecentActivity {
  return { title: "", difficulty: "", status: "", timeAgo: "", language: "" };
}

export const RecentActivity: MessageFns<RecentActivity> = {
  encode(message: RecentActivity, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.difficulty !== "") {
      writer.uint32(18).string(message.difficulty);
    }
    if (message.status !== "") {
      writer.uint32(26).string(message.status);
    }
    if (message.timeAgo !== "") {
      writer.uint32(34).string(message.timeAgo);
    }
    if (message.language !== "") {
      writer.uint32(42).string(message.language);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RecentActivity {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRecentActivity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.difficulty = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.timeAgo = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.language = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RecentActivity {
    return {
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      difficulty: isSet(object.difficulty) ? globalThis.String(object.difficulty) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      timeAgo: isSet(object.timeAgo) ? globalThis.String(object.timeAgo) : "",
      language: isSet(object.language) ? globalThis.String(object.language) : "",
    };
  },

  toJSON(message: RecentActivity): unknown {
    const obj: any = {};
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.difficulty !== "") {
      obj.difficulty = message.difficulty;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.timeAgo !== "") {
      obj.timeAgo = message.timeAgo;
    }
    if (message.language !== "") {
      obj.language = message.language;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RecentActivity>, I>>(base?: I): RecentActivity {
    return RecentActivity.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RecentActivity>, I>>(object: I): RecentActivity {
    const message = createBaseRecentActivity();
    message.title = object.title ?? "";
    message.difficulty = object.difficulty ?? "";
    message.status = object.status ?? "";
    message.timeAgo = object.timeAgo ?? "";
    message.language = object.language ?? "";
    return message;
  },
};

function createBaseLeaderboardData(): LeaderboardData {
  return { userId: "", username: "", score: 0, entity: "", globalRank: 0, entityRank: 0 };
}

export const LeaderboardData: MessageFns<LeaderboardData> = {
  encode(message: LeaderboardData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.username !== "") {
      writer.uint32(18).string(message.username);
    }
    if (message.score !== 0) {
      writer.uint32(24).int32(message.score);
    }
    if (message.entity !== "") {
      writer.uint32(34).string(message.entity);
    }
    if (message.globalRank !== 0) {
      writer.uint32(40).int32(message.globalRank);
    }
    if (message.entityRank !== 0) {
      writer.uint32(48).int32(message.entityRank);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LeaderboardData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLeaderboardData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.score = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.entity = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.globalRank = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.entityRank = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LeaderboardData {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      score: isSet(object.score) ? globalThis.Number(object.score) : 0,
      entity: isSet(object.entity) ? globalThis.String(object.entity) : "",
      globalRank: isSet(object.globalRank) ? globalThis.Number(object.globalRank) : 0,
      entityRank: isSet(object.entityRank) ? globalThis.Number(object.entityRank) : 0,
    };
  },

  toJSON(message: LeaderboardData): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.score !== 0) {
      obj.score = Math.round(message.score);
    }
    if (message.entity !== "") {
      obj.entity = message.entity;
    }
    if (message.globalRank !== 0) {
      obj.globalRank = Math.round(message.globalRank);
    }
    if (message.entityRank !== 0) {
      obj.entityRank = Math.round(message.entityRank);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LeaderboardData>, I>>(base?: I): LeaderboardData {
    return LeaderboardData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LeaderboardData>, I>>(object: I): LeaderboardData {
    const message = createBaseLeaderboardData();
    message.userId = object.userId ?? "";
    message.username = object.username ?? "";
    message.score = object.score ?? 0;
    message.entity = object.entity ?? "";
    message.globalRank = object.globalRank ?? 0;
    message.entityRank = object.entityRank ?? 0;
    return message;
  },
};

function createBaseSolvedByDifficulty(): SolvedByDifficulty {
  return { difficulty: "", count: 0 };
}

export const SolvedByDifficulty: MessageFns<SolvedByDifficulty> = {
  encode(message: SolvedByDifficulty, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.difficulty !== "") {
      writer.uint32(10).string(message.difficulty);
    }
    if (message.count !== 0) {
      writer.uint32(16).int32(message.count);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SolvedByDifficulty {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSolvedByDifficulty();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.difficulty = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.count = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SolvedByDifficulty {
    return {
      difficulty: isSet(object.difficulty) ? globalThis.String(object.difficulty) : "",
      count: isSet(object.count) ? globalThis.Number(object.count) : 0,
    };
  },

  toJSON(message: SolvedByDifficulty): unknown {
    const obj: any = {};
    if (message.difficulty !== "") {
      obj.difficulty = message.difficulty;
    }
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SolvedByDifficulty>, I>>(base?: I): SolvedByDifficulty {
    return SolvedByDifficulty.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SolvedByDifficulty>, I>>(object: I): SolvedByDifficulty {
    const message = createBaseSolvedByDifficulty();
    message.difficulty = object.difficulty ?? "";
    message.count = object.count ?? 0;
    return message;
  },
};

function createBaseGetDashboardStatsResponse(): GetDashboardStatsResponse {
  return {
    heatmap: [],
    currentStreak: 0,
    leaderboardDetails: undefined,
    problemsSolved: 0,
    recentActivities: [],
    solvedByDifficulty: [],
  };
}

export const GetDashboardStatsResponse: MessageFns<GetDashboardStatsResponse> = {
  encode(message: GetDashboardStatsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.heatmap) {
      Activity.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.currentStreak !== 0) {
      writer.uint32(16).int32(message.currentStreak);
    }
    if (message.leaderboardDetails !== undefined) {
      LeaderboardData.encode(message.leaderboardDetails, writer.uint32(26).fork()).join();
    }
    if (message.problemsSolved !== 0) {
      writer.uint32(32).int32(message.problemsSolved);
    }
    for (const v of message.recentActivities) {
      RecentActivity.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.solvedByDifficulty) {
      SolvedByDifficulty.encode(v!, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDashboardStatsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDashboardStatsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.heatmap.push(Activity.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.currentStreak = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.leaderboardDetails = LeaderboardData.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.problemsSolved = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.recentActivities.push(RecentActivity.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.solvedByDifficulty.push(SolvedByDifficulty.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDashboardStatsResponse {
    return {
      heatmap: globalThis.Array.isArray(object?.heatmap) ? object.heatmap.map((e: any) => Activity.fromJSON(e)) : [],
      currentStreak: isSet(object.currentStreak) ? globalThis.Number(object.currentStreak) : 0,
      leaderboardDetails: isSet(object.leaderboardDetails)
        ? LeaderboardData.fromJSON(object.leaderboardDetails)
        : undefined,
      problemsSolved: isSet(object.problemsSolved) ? globalThis.Number(object.problemsSolved) : 0,
      recentActivities: globalThis.Array.isArray(object?.recentActivities)
        ? object.recentActivities.map((e: any) => RecentActivity.fromJSON(e))
        : [],
      solvedByDifficulty: globalThis.Array.isArray(object?.solvedByDifficulty)
        ? object.solvedByDifficulty.map((e: any) => SolvedByDifficulty.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetDashboardStatsResponse): unknown {
    const obj: any = {};
    if (message.heatmap?.length) {
      obj.heatmap = message.heatmap.map((e) => Activity.toJSON(e));
    }
    if (message.currentStreak !== 0) {
      obj.currentStreak = Math.round(message.currentStreak);
    }
    if (message.leaderboardDetails !== undefined) {
      obj.leaderboardDetails = LeaderboardData.toJSON(message.leaderboardDetails);
    }
    if (message.problemsSolved !== 0) {
      obj.problemsSolved = Math.round(message.problemsSolved);
    }
    if (message.recentActivities?.length) {
      obj.recentActivities = message.recentActivities.map((e) => RecentActivity.toJSON(e));
    }
    if (message.solvedByDifficulty?.length) {
      obj.solvedByDifficulty = message.solvedByDifficulty.map((e) => SolvedByDifficulty.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetDashboardStatsResponse>, I>>(base?: I): GetDashboardStatsResponse {
    return GetDashboardStatsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetDashboardStatsResponse>, I>>(object: I): GetDashboardStatsResponse {
    const message = createBaseGetDashboardStatsResponse();
    message.heatmap = object.heatmap?.map((e) => Activity.fromPartial(e)) || [];
    message.currentStreak = object.currentStreak ?? 0;
    message.leaderboardDetails = (object.leaderboardDetails !== undefined && object.leaderboardDetails !== null)
      ? LeaderboardData.fromPartial(object.leaderboardDetails)
      : undefined;
    message.problemsSolved = object.problemsSolved ?? 0;
    message.recentActivities = object.recentActivities?.map((e) => RecentActivity.fromPartial(e)) || [];
    message.solvedByDifficulty = object.solvedByDifficulty?.map((e) => SolvedByDifficulty.fromPartial(e)) || [];
    return message;
  },
};

function createBaseUpdateCountryRequest(): UpdateCountryRequest {
  return { userId: "", country: "" };
}

export const UpdateCountryRequest: MessageFns<UpdateCountryRequest> = {
  encode(message: UpdateCountryRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.country !== "") {
      writer.uint32(18).string(message.country);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateCountryRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateCountryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.country = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateCountryRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      country: isSet(object.country) ? globalThis.String(object.country) : "",
    };
  },

  toJSON(message: UpdateCountryRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.country !== "") {
      obj.country = message.country;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateCountryRequest>, I>>(base?: I): UpdateCountryRequest {
    return UpdateCountryRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateCountryRequest>, I>>(object: I): UpdateCountryRequest {
    const message = createBaseUpdateCountryRequest();
    message.userId = object.userId ?? "";
    message.country = object.country ?? "";
    return message;
  },
};

function createBaseRemoveUserRequest(): RemoveUserRequest {
  return { userId: "" };
}

export const RemoveUserRequest: MessageFns<RemoveUserRequest> = {
  encode(message: RemoveUserRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RemoveUserRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RemoveUserRequest {
    return { userId: isSet(object.userId) ? globalThis.String(object.userId) : "" };
  },

  toJSON(message: RemoveUserRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RemoveUserRequest>, I>>(base?: I): RemoveUserRequest {
    return RemoveUserRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RemoveUserRequest>, I>>(object: I): RemoveUserRequest {
    const message = createBaseRemoveUserRequest();
    message.userId = object.userId ?? "";
    return message;
  },
};

function createBaseLanguageWiseSubmissionStats(): LanguageWiseSubmissionStats {
  return { language: "", count: 0 };
}

export const LanguageWiseSubmissionStats: MessageFns<LanguageWiseSubmissionStats> = {
  encode(message: LanguageWiseSubmissionStats, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.language !== "") {
      writer.uint32(10).string(message.language);
    }
    if (message.count !== 0) {
      writer.uint32(16).int32(message.count);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LanguageWiseSubmissionStats {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLanguageWiseSubmissionStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.language = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.count = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LanguageWiseSubmissionStats {
    return {
      language: isSet(object.language) ? globalThis.String(object.language) : "",
      count: isSet(object.count) ? globalThis.Number(object.count) : 0,
    };
  },

  toJSON(message: LanguageWiseSubmissionStats): unknown {
    const obj: any = {};
    if (message.language !== "") {
      obj.language = message.language;
    }
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LanguageWiseSubmissionStats>, I>>(base?: I): LanguageWiseSubmissionStats {
    return LanguageWiseSubmissionStats.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LanguageWiseSubmissionStats>, I>>(object: I): LanguageWiseSubmissionStats {
    const message = createBaseLanguageWiseSubmissionStats();
    message.language = object.language ?? "";
    message.count = object.count ?? 0;
    return message;
  },
};

function createBaseSubmissionStats(): SubmissionStats {
  return { totalSubmissions: 0, todaysSubmissions: 0, languageWise: [] };
}

export const SubmissionStats: MessageFns<SubmissionStats> = {
  encode(message: SubmissionStats, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.totalSubmissions !== 0) {
      writer.uint32(8).int32(message.totalSubmissions);
    }
    if (message.todaysSubmissions !== 0) {
      writer.uint32(16).int32(message.todaysSubmissions);
    }
    for (const v of message.languageWise) {
      LanguageWiseSubmissionStats.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubmissionStats {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubmissionStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.totalSubmissions = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.todaysSubmissions = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.languageWise.push(LanguageWiseSubmissionStats.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubmissionStats {
    return {
      totalSubmissions: isSet(object.totalSubmissions) ? globalThis.Number(object.totalSubmissions) : 0,
      todaysSubmissions: isSet(object.todaysSubmissions) ? globalThis.Number(object.todaysSubmissions) : 0,
      languageWise: globalThis.Array.isArray(object?.languageWise)
        ? object.languageWise.map((e: any) => LanguageWiseSubmissionStats.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SubmissionStats): unknown {
    const obj: any = {};
    if (message.totalSubmissions !== 0) {
      obj.totalSubmissions = Math.round(message.totalSubmissions);
    }
    if (message.todaysSubmissions !== 0) {
      obj.todaysSubmissions = Math.round(message.todaysSubmissions);
    }
    if (message.languageWise?.length) {
      obj.languageWise = message.languageWise.map((e) => LanguageWiseSubmissionStats.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubmissionStats>, I>>(base?: I): SubmissionStats {
    return SubmissionStats.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubmissionStats>, I>>(object: I): SubmissionStats {
    const message = createBaseSubmissionStats();
    message.totalSubmissions = object.totalSubmissions ?? 0;
    message.todaysSubmissions = object.todaysSubmissions ?? 0;
    message.languageWise = object.languageWise?.map((e) => LanguageWiseSubmissionStats.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDifficultyWiseProblemStats(): DifficultyWiseProblemStats {
  return { difficulty: "", count: 0 };
}

export const DifficultyWiseProblemStats: MessageFns<DifficultyWiseProblemStats> = {
  encode(message: DifficultyWiseProblemStats, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.difficulty !== "") {
      writer.uint32(10).string(message.difficulty);
    }
    if (message.count !== 0) {
      writer.uint32(16).int32(message.count);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DifficultyWiseProblemStats {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDifficultyWiseProblemStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.difficulty = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.count = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DifficultyWiseProblemStats {
    return {
      difficulty: isSet(object.difficulty) ? globalThis.String(object.difficulty) : "",
      count: isSet(object.count) ? globalThis.Number(object.count) : 0,
    };
  },

  toJSON(message: DifficultyWiseProblemStats): unknown {
    const obj: any = {};
    if (message.difficulty !== "") {
      obj.difficulty = message.difficulty;
    }
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DifficultyWiseProblemStats>, I>>(base?: I): DifficultyWiseProblemStats {
    return DifficultyWiseProblemStats.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DifficultyWiseProblemStats>, I>>(object: I): DifficultyWiseProblemStats {
    const message = createBaseDifficultyWiseProblemStats();
    message.difficulty = object.difficulty ?? "";
    message.count = object.count ?? 0;
    return message;
  },
};

function createBaseProblemStats(): ProblemStats {
  return { totalProblems: 0, todaysProblems: 0, difficultyWise: [] };
}

export const ProblemStats: MessageFns<ProblemStats> = {
  encode(message: ProblemStats, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.totalProblems !== 0) {
      writer.uint32(8).int32(message.totalProblems);
    }
    if (message.todaysProblems !== 0) {
      writer.uint32(16).int32(message.todaysProblems);
    }
    for (const v of message.difficultyWise) {
      DifficultyWiseProblemStats.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProblemStats {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProblemStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.totalProblems = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.todaysProblems = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.difficultyWise.push(DifficultyWiseProblemStats.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProblemStats {
    return {
      totalProblems: isSet(object.totalProblems) ? globalThis.Number(object.totalProblems) : 0,
      todaysProblems: isSet(object.todaysProblems) ? globalThis.Number(object.todaysProblems) : 0,
      difficultyWise: globalThis.Array.isArray(object?.difficultyWise)
        ? object.difficultyWise.map((e: any) => DifficultyWiseProblemStats.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ProblemStats): unknown {
    const obj: any = {};
    if (message.totalProblems !== 0) {
      obj.totalProblems = Math.round(message.totalProblems);
    }
    if (message.todaysProblems !== 0) {
      obj.todaysProblems = Math.round(message.todaysProblems);
    }
    if (message.difficultyWise?.length) {
      obj.difficultyWise = message.difficultyWise.map((e) => DifficultyWiseProblemStats.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProblemStats>, I>>(base?: I): ProblemStats {
    return ProblemStats.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProblemStats>, I>>(object: I): ProblemStats {
    const message = createBaseProblemStats();
    message.totalProblems = object.totalProblems ?? 0;
    message.todaysProblems = object.todaysProblems ?? 0;
    message.difficultyWise = object.difficultyWise?.map((e) => DifficultyWiseProblemStats.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetProblemSubmissionStatsResponse(): GetProblemSubmissionStatsResponse {
  return { submissionStats: undefined, problemStats: undefined };
}

export const GetProblemSubmissionStatsResponse: MessageFns<GetProblemSubmissionStatsResponse> = {
  encode(message: GetProblemSubmissionStatsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.submissionStats !== undefined) {
      SubmissionStats.encode(message.submissionStats, writer.uint32(10).fork()).join();
    }
    if (message.problemStats !== undefined) {
      ProblemStats.encode(message.problemStats, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetProblemSubmissionStatsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProblemSubmissionStatsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.submissionStats = SubmissionStats.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.problemStats = ProblemStats.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetProblemSubmissionStatsResponse {
    return {
      submissionStats: isSet(object.submissionStats) ? SubmissionStats.fromJSON(object.submissionStats) : undefined,
      problemStats: isSet(object.problemStats) ? ProblemStats.fromJSON(object.problemStats) : undefined,
    };
  },

  toJSON(message: GetProblemSubmissionStatsResponse): unknown {
    const obj: any = {};
    if (message.submissionStats !== undefined) {
      obj.submissionStats = SubmissionStats.toJSON(message.submissionStats);
    }
    if (message.problemStats !== undefined) {
      obj.problemStats = ProblemStats.toJSON(message.problemStats);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetProblemSubmissionStatsResponse>, I>>(
    base?: I,
  ): GetProblemSubmissionStatsResponse {
    return GetProblemSubmissionStatsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetProblemSubmissionStatsResponse>, I>>(
    object: I,
  ): GetProblemSubmissionStatsResponse {
    const message = createBaseGetProblemSubmissionStatsResponse();
    message.submissionStats = (object.submissionStats !== undefined && object.submissionStats !== null)
      ? SubmissionStats.fromPartial(object.submissionStats)
      : undefined;
    message.problemStats = (object.problemStats !== undefined && object.problemStats !== null)
      ? ProblemStats.fromPartial(object.problemStats)
      : undefined;
    return message;
  },
};

function createBaseRequestHintRequest(): RequestHintRequest {
  return { userCode: "", problemId: "", language: "", userId: "" };
}

export const RequestHintRequest: MessageFns<RequestHintRequest> = {
  encode(message: RequestHintRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userCode !== "") {
      writer.uint32(10).string(message.userCode);
    }
    if (message.problemId !== "") {
      writer.uint32(18).string(message.problemId);
    }
    if (message.language !== "") {
      writer.uint32(26).string(message.language);
    }
    if (message.userId !== "") {
      writer.uint32(34).string(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RequestHintRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestHintRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userCode = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.problemId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.language = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RequestHintRequest {
    return {
      userCode: isSet(object.userCode) ? globalThis.String(object.userCode) : "",
      problemId: isSet(object.problemId) ? globalThis.String(object.problemId) : "",
      language: isSet(object.language) ? globalThis.String(object.language) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
    };
  },

  toJSON(message: RequestHintRequest): unknown {
    const obj: any = {};
    if (message.userCode !== "") {
      obj.userCode = message.userCode;
    }
    if (message.problemId !== "") {
      obj.problemId = message.problemId;
    }
    if (message.language !== "") {
      obj.language = message.language;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RequestHintRequest>, I>>(base?: I): RequestHintRequest {
    return RequestHintRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RequestHintRequest>, I>>(object: I): RequestHintRequest {
    const message = createBaseRequestHintRequest();
    message.userCode = object.userCode ?? "";
    message.problemId = object.problemId ?? "";
    message.language = object.language ?? "";
    message.userId = object.userId ?? "";
    return message;
  },
};

function createBaseRequestHintResponse(): RequestHintResponse {
  return { hint: "" };
}

export const RequestHintResponse: MessageFns<RequestHintResponse> = {
  encode(message: RequestHintResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hint !== "") {
      writer.uint32(10).string(message.hint);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RequestHintResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestHintResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.hint = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RequestHintResponse {
    return { hint: isSet(object.hint) ? globalThis.String(object.hint) : "" };
  },

  toJSON(message: RequestHintResponse): unknown {
    const obj: any = {};
    if (message.hint !== "") {
      obj.hint = message.hint;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RequestHintResponse>, I>>(base?: I): RequestHintResponse {
    return RequestHintResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RequestHintResponse>, I>>(object: I): RequestHintResponse {
    const message = createBaseRequestHintResponse();
    message.hint = object.hint ?? "";
    return message;
  },
};

function createBaseGetPreviousHintsRequest(): GetPreviousHintsRequest {
  return { problemId: "", userId: "" };
}

export const GetPreviousHintsRequest: MessageFns<GetPreviousHintsRequest> = {
  encode(message: GetPreviousHintsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.problemId !== "") {
      writer.uint32(10).string(message.problemId);
    }
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPreviousHintsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPreviousHintsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.problemId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPreviousHintsRequest {
    return {
      problemId: isSet(object.problemId) ? globalThis.String(object.problemId) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
    };
  },

  toJSON(message: GetPreviousHintsRequest): unknown {
    const obj: any = {};
    if (message.problemId !== "") {
      obj.problemId = message.problemId;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetPreviousHintsRequest>, I>>(base?: I): GetPreviousHintsRequest {
    return GetPreviousHintsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetPreviousHintsRequest>, I>>(object: I): GetPreviousHintsRequest {
    const message = createBaseGetPreviousHintsRequest();
    message.problemId = object.problemId ?? "";
    message.userId = object.userId ?? "";
    return message;
  },
};

function createBasePreviousHint(): PreviousHint {
  return { hint: "", createdAt: "" };
}

export const PreviousHint: MessageFns<PreviousHint> = {
  encode(message: PreviousHint, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hint !== "") {
      writer.uint32(10).string(message.hint);
    }
    if (message.createdAt !== "") {
      writer.uint32(18).string(message.createdAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PreviousHint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePreviousHint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.hint = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PreviousHint {
    return {
      hint: isSet(object.hint) ? globalThis.String(object.hint) : "",
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
    };
  },

  toJSON(message: PreviousHint): unknown {
    const obj: any = {};
    if (message.hint !== "") {
      obj.hint = message.hint;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PreviousHint>, I>>(base?: I): PreviousHint {
    return PreviousHint.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PreviousHint>, I>>(object: I): PreviousHint {
    const message = createBasePreviousHint();
    message.hint = object.hint ?? "";
    message.createdAt = object.createdAt ?? "";
    return message;
  },
};

function createBaseGetPreviousHintsResponse(): GetPreviousHintsResponse {
  return { hints: [] };
}

export const GetPreviousHintsResponse: MessageFns<GetPreviousHintsResponse> = {
  encode(message: GetPreviousHintsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.hints) {
      PreviousHint.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPreviousHintsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPreviousHintsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.hints.push(PreviousHint.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPreviousHintsResponse {
    return {
      hints: globalThis.Array.isArray(object?.hints) ? object.hints.map((e: any) => PreviousHint.fromJSON(e)) : [],
    };
  },

  toJSON(message: GetPreviousHintsResponse): unknown {
    const obj: any = {};
    if (message.hints?.length) {
      obj.hints = message.hints.map((e) => PreviousHint.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetPreviousHintsResponse>, I>>(base?: I): GetPreviousHintsResponse {
    return GetPreviousHintsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetPreviousHintsResponse>, I>>(object: I): GetPreviousHintsResponse {
    const message = createBaseGetPreviousHintsResponse();
    message.hints = object.hints?.map((e) => PreviousHint.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRequestFullSolutionRequest(): RequestFullSolutionRequest {
  return { problemId: "", userId: "", language: "" };
}

export const RequestFullSolutionRequest: MessageFns<RequestFullSolutionRequest> = {
  encode(message: RequestFullSolutionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.problemId !== "") {
      writer.uint32(10).string(message.problemId);
    }
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    if (message.language !== "") {
      writer.uint32(26).string(message.language);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RequestFullSolutionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestFullSolutionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.problemId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.language = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RequestFullSolutionRequest {
    return {
      problemId: isSet(object.problemId) ? globalThis.String(object.problemId) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      language: isSet(object.language) ? globalThis.String(object.language) : "",
    };
  },

  toJSON(message: RequestFullSolutionRequest): unknown {
    const obj: any = {};
    if (message.problemId !== "") {
      obj.problemId = message.problemId;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.language !== "") {
      obj.language = message.language;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RequestFullSolutionRequest>, I>>(base?: I): RequestFullSolutionRequest {
    return RequestFullSolutionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RequestFullSolutionRequest>, I>>(object: I): RequestFullSolutionRequest {
    const message = createBaseRequestFullSolutionRequest();
    message.problemId = object.problemId ?? "";
    message.userId = object.userId ?? "";
    message.language = object.language ?? "";
    return message;
  },
};

function createBaseRequestFullSolutionResponse(): RequestFullSolutionResponse {
  return { solution: "" };
}

export const RequestFullSolutionResponse: MessageFns<RequestFullSolutionResponse> = {
  encode(message: RequestFullSolutionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.solution !== "") {
      writer.uint32(10).string(message.solution);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RequestFullSolutionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestFullSolutionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.solution = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RequestFullSolutionResponse {
    return { solution: isSet(object.solution) ? globalThis.String(object.solution) : "" };
  },

  toJSON(message: RequestFullSolutionResponse): unknown {
    const obj: any = {};
    if (message.solution !== "") {
      obj.solution = message.solution;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RequestFullSolutionResponse>, I>>(base?: I): RequestFullSolutionResponse {
    return RequestFullSolutionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RequestFullSolutionResponse>, I>>(object: I): RequestFullSolutionResponse {
    const message = createBaseRequestFullSolutionResponse();
    message.solution = object.solution ?? "";
    return message;
  },
};

export type ProblemServiceService = typeof ProblemServiceService;
export const ProblemServiceService = {
  createProblem: {
    path: "/problem.v1.ProblemService/CreateProblem",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateProblemRequest): Buffer => Buffer.from(CreateProblemRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateProblemRequest => CreateProblemRequest.decode(value),
    responseSerialize: (value: Problem): Buffer => Buffer.from(Problem.encode(value).finish()),
    responseDeserialize: (value: Buffer): Problem => Problem.decode(value),
  },
  getProblem: {
    path: "/problem.v1.ProblemService/GetProblem",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetProblemRequest): Buffer => Buffer.from(GetProblemRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetProblemRequest => GetProblemRequest.decode(value),
    responseSerialize: (value: Problem): Buffer => Buffer.from(Problem.encode(value).finish()),
    responseDeserialize: (value: Buffer): Problem => Problem.decode(value),
  },
  getProblemForPublic: {
    path: "/problem.v1.ProblemService/GetProblemForPublic",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetProblemRequest): Buffer => Buffer.from(GetProblemRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetProblemRequest => GetProblemRequest.decode(value),
    responseSerialize: (value: GetProblemPublicResponse): Buffer =>
      Buffer.from(GetProblemPublicResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetProblemPublicResponse => GetProblemPublicResponse.decode(value),
  },
  updateBasicProblemDetails: {
    path: "/problem.v1.ProblemService/UpdateBasicProblemDetails",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateBasicProblemDetailsRequest): Buffer =>
      Buffer.from(UpdateBasicProblemDetailsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateBasicProblemDetailsRequest =>
      UpdateBasicProblemDetailsRequest.decode(value),
    responseSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
  },
  listProblems: {
    path: "/problem.v1.ProblemService/ListProblems",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListProblemRequest): Buffer => Buffer.from(ListProblemRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListProblemRequest => ListProblemRequest.decode(value),
    responseSerialize: (value: ListProblemResponse): Buffer => Buffer.from(ListProblemResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListProblemResponse => ListProblemResponse.decode(value),
  },
  addTestCase: {
    path: "/problem.v1.ProblemService/AddTestCase",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: AddTestCaseRequest): Buffer => Buffer.from(AddTestCaseRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): AddTestCaseRequest => AddTestCaseRequest.decode(value),
    responseSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
  },
  bulkUploadTestCases: {
    path: "/problem.v1.ProblemService/BulkUploadTestCases",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BulkUploadTestCasesRequest): Buffer =>
      Buffer.from(BulkUploadTestCasesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): BulkUploadTestCasesRequest => BulkUploadTestCasesRequest.decode(value),
    responseSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
  },
  removeTestCase: {
    path: "/problem.v1.ProblemService/RemoveTestCase",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RemoveTestCaseRequest): Buffer =>
      Buffer.from(RemoveTestCaseRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): RemoveTestCaseRequest => RemoveTestCaseRequest.decode(value),
    responseSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
  },
  updateTemplateCode: {
    path: "/problem.v1.ProblemService/UpdateTemplateCode",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateTemplateCodeRequest): Buffer =>
      Buffer.from(UpdateTemplateCodeRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateTemplateCodeRequest => UpdateTemplateCodeRequest.decode(value),
    responseSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
  },
  checkQuestionIdAvailability: {
    path: "/problem.v1.ProblemService/CheckQuestionIdAvailability",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CheckQuestionIdRequest): Buffer =>
      Buffer.from(CheckQuestionIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CheckQuestionIdRequest => CheckQuestionIdRequest.decode(value),
    responseSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
  },
  checkProblemTitle: {
    path: "/problem.v1.ProblemService/CheckProblemTitle",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CheckProblemTitleRequest): Buffer =>
      Buffer.from(CheckProblemTitleRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CheckProblemTitleRequest => CheckProblemTitleRequest.decode(value),
    responseSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
  },
} as const;

export interface ProblemServiceServer extends UntypedServiceImplementation {
  createProblem: handleUnaryCall<CreateProblemRequest, Problem>;
  getProblem: handleUnaryCall<GetProblemRequest, Problem>;
  getProblemForPublic: handleUnaryCall<GetProblemRequest, GetProblemPublicResponse>;
  updateBasicProblemDetails: handleUnaryCall<UpdateBasicProblemDetailsRequest, Empty>;
  listProblems: handleUnaryCall<ListProblemRequest, ListProblemResponse>;
  addTestCase: handleUnaryCall<AddTestCaseRequest, Empty>;
  bulkUploadTestCases: handleUnaryCall<BulkUploadTestCasesRequest, Empty>;
  removeTestCase: handleUnaryCall<RemoveTestCaseRequest, Empty>;
  updateTemplateCode: handleUnaryCall<UpdateTemplateCodeRequest, Empty>;
  checkQuestionIdAvailability: handleUnaryCall<CheckQuestionIdRequest, Empty>;
  checkProblemTitle: handleUnaryCall<CheckProblemTitleRequest, Empty>;
}

export interface ProblemServiceClient extends Client {
  createProblem(
    request: CreateProblemRequest,
    callback: (error: ServiceError | null, response: Problem) => void,
  ): ClientUnaryCall;
  createProblem(
    request: CreateProblemRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Problem) => void,
  ): ClientUnaryCall;
  createProblem(
    request: CreateProblemRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Problem) => void,
  ): ClientUnaryCall;
  getProblem(
    request: GetProblemRequest,
    callback: (error: ServiceError | null, response: Problem) => void,
  ): ClientUnaryCall;
  getProblem(
    request: GetProblemRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Problem) => void,
  ): ClientUnaryCall;
  getProblem(
    request: GetProblemRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Problem) => void,
  ): ClientUnaryCall;
  getProblemForPublic(
    request: GetProblemRequest,
    callback: (error: ServiceError | null, response: GetProblemPublicResponse) => void,
  ): ClientUnaryCall;
  getProblemForPublic(
    request: GetProblemRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetProblemPublicResponse) => void,
  ): ClientUnaryCall;
  getProblemForPublic(
    request: GetProblemRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetProblemPublicResponse) => void,
  ): ClientUnaryCall;
  updateBasicProblemDetails(
    request: UpdateBasicProblemDetailsRequest,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  updateBasicProblemDetails(
    request: UpdateBasicProblemDetailsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  updateBasicProblemDetails(
    request: UpdateBasicProblemDetailsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  listProblems(
    request: ListProblemRequest,
    callback: (error: ServiceError | null, response: ListProblemResponse) => void,
  ): ClientUnaryCall;
  listProblems(
    request: ListProblemRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListProblemResponse) => void,
  ): ClientUnaryCall;
  listProblems(
    request: ListProblemRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListProblemResponse) => void,
  ): ClientUnaryCall;
  addTestCase(
    request: AddTestCaseRequest,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  addTestCase(
    request: AddTestCaseRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  addTestCase(
    request: AddTestCaseRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  bulkUploadTestCases(
    request: BulkUploadTestCasesRequest,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  bulkUploadTestCases(
    request: BulkUploadTestCasesRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  bulkUploadTestCases(
    request: BulkUploadTestCasesRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  removeTestCase(
    request: RemoveTestCaseRequest,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  removeTestCase(
    request: RemoveTestCaseRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  removeTestCase(
    request: RemoveTestCaseRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  updateTemplateCode(
    request: UpdateTemplateCodeRequest,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  updateTemplateCode(
    request: UpdateTemplateCodeRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  updateTemplateCode(
    request: UpdateTemplateCodeRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  checkQuestionIdAvailability(
    request: CheckQuestionIdRequest,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  checkQuestionIdAvailability(
    request: CheckQuestionIdRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  checkQuestionIdAvailability(
    request: CheckQuestionIdRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  checkProblemTitle(
    request: CheckProblemTitleRequest,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  checkProblemTitle(
    request: CheckProblemTitleRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  checkProblemTitle(
    request: CheckProblemTitleRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
}

export const ProblemServiceClient = makeGenericClientConstructor(
  ProblemServiceService,
  "problem.v1.ProblemService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): ProblemServiceClient;
  service: typeof ProblemServiceService;
  serviceName: string;
};

export type SubmissionServiceService = typeof SubmissionServiceService;
export const SubmissionServiceService = {
  createSubmission: {
    path: "/problem.v1.SubmissionService/CreateSubmission",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateSubmissionRequest): Buffer =>
      Buffer.from(CreateSubmissionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateSubmissionRequest => CreateSubmissionRequest.decode(value),
    responseSerialize: (value: Submission): Buffer => Buffer.from(Submission.encode(value).finish()),
    responseDeserialize: (value: Buffer): Submission => Submission.decode(value),
  },
  updateSubmission: {
    path: "/problem.v1.SubmissionService/UpdateSubmission",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateSubmissionRequest): Buffer =>
      Buffer.from(UpdateSubmissionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateSubmissionRequest => UpdateSubmissionRequest.decode(value),
    responseSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
  },
  listProblemSpecificSubmission: {
    path: "/problem.v1.SubmissionService/ListProblemSpecificSubmission",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListProblemSpecificSubmissionRequest): Buffer =>
      Buffer.from(ListProblemSpecificSubmissionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListProblemSpecificSubmissionRequest =>
      ListProblemSpecificSubmissionRequest.decode(value),
    responseSerialize: (value: ListProblemSpecificSubmissionResponse): Buffer =>
      Buffer.from(ListProblemSpecificSubmissionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListProblemSpecificSubmissionResponse =>
      ListProblemSpecificSubmissionResponse.decode(value),
  },
  getSubmissions: {
    path: "/problem.v1.SubmissionService/GetSubmissions",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetSubmissionsRequest): Buffer =>
      Buffer.from(GetSubmissionsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetSubmissionsRequest => GetSubmissionsRequest.decode(value),
    responseSerialize: (value: GetSubmissionsResponse): Buffer =>
      Buffer.from(GetSubmissionsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetSubmissionsResponse => GetSubmissionsResponse.decode(value),
  },
  listTopKGlobalLeaderboard: {
    path: "/problem.v1.SubmissionService/ListTopKGlobalLeaderboard",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListTopKGlobalLeaderboardRequest): Buffer =>
      Buffer.from(ListTopKGlobalLeaderboardRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListTopKGlobalLeaderboardRequest =>
      ListTopKGlobalLeaderboardRequest.decode(value),
    responseSerialize: (value: ListTopKGlobalLeaderboardResponse): Buffer =>
      Buffer.from(ListTopKGlobalLeaderboardResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListTopKGlobalLeaderboardResponse =>
      ListTopKGlobalLeaderboardResponse.decode(value),
  },
  listTopKCountryLeaderboard: {
    path: "/problem.v1.SubmissionService/ListTopKCountryLeaderboard",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListTopKCountryLeaderboardRequest): Buffer =>
      Buffer.from(ListTopKCountryLeaderboardRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListTopKCountryLeaderboardRequest =>
      ListTopKCountryLeaderboardRequest.decode(value),
    responseSerialize: (value: ListTopKCountryLeaderboardResponse): Buffer =>
      Buffer.from(ListTopKCountryLeaderboardResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListTopKCountryLeaderboardResponse =>
      ListTopKCountryLeaderboardResponse.decode(value),
  },
  getDashboardStats: {
    path: "/problem.v1.SubmissionService/GetDashboardStats",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetDashboardStatsRequest): Buffer =>
      Buffer.from(GetDashboardStatsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetDashboardStatsRequest => GetDashboardStatsRequest.decode(value),
    responseSerialize: (value: GetDashboardStatsResponse): Buffer =>
      Buffer.from(GetDashboardStatsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetDashboardStatsResponse => GetDashboardStatsResponse.decode(value),
  },
  getProblemSubmissionStats: {
    path: "/problem.v1.SubmissionService/GetProblemSubmissionStats",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    requestDeserialize: (value: Buffer): Empty => Empty.decode(value),
    responseSerialize: (value: GetProblemSubmissionStatsResponse): Buffer =>
      Buffer.from(GetProblemSubmissionStatsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetProblemSubmissionStatsResponse =>
      GetProblemSubmissionStatsResponse.decode(value),
  },
  updateCountryInLeaderboard: {
    path: "/problem.v1.SubmissionService/UpdateCountryInLeaderboard",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateCountryRequest): Buffer => Buffer.from(UpdateCountryRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateCountryRequest => UpdateCountryRequest.decode(value),
    responseSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
  },
  removeUserInLeaderboard: {
    path: "/problem.v1.SubmissionService/RemoveUserInLeaderboard",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RemoveUserRequest): Buffer => Buffer.from(RemoveUserRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): RemoveUserRequest => RemoveUserRequest.decode(value),
    responseSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
  },
  requestHint: {
    path: "/problem.v1.SubmissionService/RequestHint",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RequestHintRequest): Buffer => Buffer.from(RequestHintRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): RequestHintRequest => RequestHintRequest.decode(value),
    responseSerialize: (value: RequestHintResponse): Buffer => Buffer.from(RequestHintResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): RequestHintResponse => RequestHintResponse.decode(value),
  },
  getPreviousHints: {
    path: "/problem.v1.SubmissionService/GetPreviousHints",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetPreviousHintsRequest): Buffer =>
      Buffer.from(GetPreviousHintsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetPreviousHintsRequest => GetPreviousHintsRequest.decode(value),
    responseSerialize: (value: GetPreviousHintsResponse): Buffer =>
      Buffer.from(GetPreviousHintsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetPreviousHintsResponse => GetPreviousHintsResponse.decode(value),
  },
  requestFullSolution: {
    path: "/problem.v1.SubmissionService/RequestFullSolution",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RequestFullSolutionRequest): Buffer =>
      Buffer.from(RequestFullSolutionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): RequestFullSolutionRequest => RequestFullSolutionRequest.decode(value),
    responseSerialize: (value: RequestFullSolutionResponse): Buffer =>
      Buffer.from(RequestFullSolutionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): RequestFullSolutionResponse => RequestFullSolutionResponse.decode(value),
  },
} as const;

export interface SubmissionServiceServer extends UntypedServiceImplementation {
  createSubmission: handleUnaryCall<CreateSubmissionRequest, Submission>;
  updateSubmission: handleUnaryCall<UpdateSubmissionRequest, Empty>;
  listProblemSpecificSubmission: handleUnaryCall<
    ListProblemSpecificSubmissionRequest,
    ListProblemSpecificSubmissionResponse
  >;
  getSubmissions: handleUnaryCall<GetSubmissionsRequest, GetSubmissionsResponse>;
  listTopKGlobalLeaderboard: handleUnaryCall<ListTopKGlobalLeaderboardRequest, ListTopKGlobalLeaderboardResponse>;
  listTopKCountryLeaderboard: handleUnaryCall<ListTopKCountryLeaderboardRequest, ListTopKCountryLeaderboardResponse>;
  getDashboardStats: handleUnaryCall<GetDashboardStatsRequest, GetDashboardStatsResponse>;
  getProblemSubmissionStats: handleUnaryCall<Empty, GetProblemSubmissionStatsResponse>;
  updateCountryInLeaderboard: handleUnaryCall<UpdateCountryRequest, Empty>;
  removeUserInLeaderboard: handleUnaryCall<RemoveUserRequest, Empty>;
  requestHint: handleUnaryCall<RequestHintRequest, RequestHintResponse>;
  getPreviousHints: handleUnaryCall<GetPreviousHintsRequest, GetPreviousHintsResponse>;
  requestFullSolution: handleUnaryCall<RequestFullSolutionRequest, RequestFullSolutionResponse>;
}

export interface SubmissionServiceClient extends Client {
  createSubmission(
    request: CreateSubmissionRequest,
    callback: (error: ServiceError | null, response: Submission) => void,
  ): ClientUnaryCall;
  createSubmission(
    request: CreateSubmissionRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Submission) => void,
  ): ClientUnaryCall;
  createSubmission(
    request: CreateSubmissionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Submission) => void,
  ): ClientUnaryCall;
  updateSubmission(
    request: UpdateSubmissionRequest,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  updateSubmission(
    request: UpdateSubmissionRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  updateSubmission(
    request: UpdateSubmissionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  listProblemSpecificSubmission(
    request: ListProblemSpecificSubmissionRequest,
    callback: (error: ServiceError | null, response: ListProblemSpecificSubmissionResponse) => void,
  ): ClientUnaryCall;
  listProblemSpecificSubmission(
    request: ListProblemSpecificSubmissionRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListProblemSpecificSubmissionResponse) => void,
  ): ClientUnaryCall;
  listProblemSpecificSubmission(
    request: ListProblemSpecificSubmissionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListProblemSpecificSubmissionResponse) => void,
  ): ClientUnaryCall;
  getSubmissions(
    request: GetSubmissionsRequest,
    callback: (error: ServiceError | null, response: GetSubmissionsResponse) => void,
  ): ClientUnaryCall;
  getSubmissions(
    request: GetSubmissionsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetSubmissionsResponse) => void,
  ): ClientUnaryCall;
  getSubmissions(
    request: GetSubmissionsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetSubmissionsResponse) => void,
  ): ClientUnaryCall;
  listTopKGlobalLeaderboard(
    request: ListTopKGlobalLeaderboardRequest,
    callback: (error: ServiceError | null, response: ListTopKGlobalLeaderboardResponse) => void,
  ): ClientUnaryCall;
  listTopKGlobalLeaderboard(
    request: ListTopKGlobalLeaderboardRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListTopKGlobalLeaderboardResponse) => void,
  ): ClientUnaryCall;
  listTopKGlobalLeaderboard(
    request: ListTopKGlobalLeaderboardRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListTopKGlobalLeaderboardResponse) => void,
  ): ClientUnaryCall;
  listTopKCountryLeaderboard(
    request: ListTopKCountryLeaderboardRequest,
    callback: (error: ServiceError | null, response: ListTopKCountryLeaderboardResponse) => void,
  ): ClientUnaryCall;
  listTopKCountryLeaderboard(
    request: ListTopKCountryLeaderboardRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListTopKCountryLeaderboardResponse) => void,
  ): ClientUnaryCall;
  listTopKCountryLeaderboard(
    request: ListTopKCountryLeaderboardRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListTopKCountryLeaderboardResponse) => void,
  ): ClientUnaryCall;
  getDashboardStats(
    request: GetDashboardStatsRequest,
    callback: (error: ServiceError | null, response: GetDashboardStatsResponse) => void,
  ): ClientUnaryCall;
  getDashboardStats(
    request: GetDashboardStatsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetDashboardStatsResponse) => void,
  ): ClientUnaryCall;
  getDashboardStats(
    request: GetDashboardStatsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetDashboardStatsResponse) => void,
  ): ClientUnaryCall;
  getProblemSubmissionStats(
    request: Empty,
    callback: (error: ServiceError | null, response: GetProblemSubmissionStatsResponse) => void,
  ): ClientUnaryCall;
  getProblemSubmissionStats(
    request: Empty,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetProblemSubmissionStatsResponse) => void,
  ): ClientUnaryCall;
  getProblemSubmissionStats(
    request: Empty,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetProblemSubmissionStatsResponse) => void,
  ): ClientUnaryCall;
  updateCountryInLeaderboard(
    request: UpdateCountryRequest,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  updateCountryInLeaderboard(
    request: UpdateCountryRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  updateCountryInLeaderboard(
    request: UpdateCountryRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  removeUserInLeaderboard(
    request: RemoveUserRequest,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  removeUserInLeaderboard(
    request: RemoveUserRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  removeUserInLeaderboard(
    request: RemoveUserRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  requestHint(
    request: RequestHintRequest,
    callback: (error: ServiceError | null, response: RequestHintResponse) => void,
  ): ClientUnaryCall;
  requestHint(
    request: RequestHintRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: RequestHintResponse) => void,
  ): ClientUnaryCall;
  requestHint(
    request: RequestHintRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: RequestHintResponse) => void,
  ): ClientUnaryCall;
  getPreviousHints(
    request: GetPreviousHintsRequest,
    callback: (error: ServiceError | null, response: GetPreviousHintsResponse) => void,
  ): ClientUnaryCall;
  getPreviousHints(
    request: GetPreviousHintsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetPreviousHintsResponse) => void,
  ): ClientUnaryCall;
  getPreviousHints(
    request: GetPreviousHintsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetPreviousHintsResponse) => void,
  ): ClientUnaryCall;
  requestFullSolution(
    request: RequestFullSolutionRequest,
    callback: (error: ServiceError | null, response: RequestFullSolutionResponse) => void,
  ): ClientUnaryCall;
  requestFullSolution(
    request: RequestFullSolutionRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: RequestFullSolutionResponse) => void,
  ): ClientUnaryCall;
  requestFullSolution(
    request: RequestFullSolutionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: RequestFullSolutionResponse) => void,
  ): ClientUnaryCall;
}

export const SubmissionServiceClient = makeGenericClientConstructor(
  SubmissionServiceService,
  "problem.v1.SubmissionService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): SubmissionServiceClient;
  service: typeof SubmissionServiceService;
  serviceName: string;
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}

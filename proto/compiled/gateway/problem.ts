// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.5
//   protoc               v5.29.3
// source: gateway/problem.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  type ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  type Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import { Empty } from "../google/protobuf/empty";

export const protobufPackage = "problem.v1";

export enum Language {
  LANGUAGE_UNSPECIFIED = 0,
  JAVASCRIPT = 1,
  PYTHON = 2,
  UNRECOGNIZED = -1,
}

export function languageFromJSON(object: any): Language {
  switch (object) {
    case 0:
    case "LANGUAGE_UNSPECIFIED":
      return Language.LANGUAGE_UNSPECIFIED;
    case 1:
    case "JAVASCRIPT":
      return Language.JAVASCRIPT;
    case 2:
    case "PYTHON":
      return Language.PYTHON;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Language.UNRECOGNIZED;
  }
}

export function languageToJSON(object: Language): string {
  switch (object) {
    case Language.LANGUAGE_UNSPECIFIED:
      return "LANGUAGE_UNSPECIFIED";
    case Language.JAVASCRIPT:
      return "JAVASCRIPT";
    case Language.PYTHON:
      return "PYTHON";
    case Language.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum Difficulty {
  DIFFICULTY_UNSPECIFIED = 0,
  EASY = 1,
  MEDIUM = 2,
  HARD = 3,
  UNRECOGNIZED = -1,
}

export function difficultyFromJSON(object: any): Difficulty {
  switch (object) {
    case 0:
    case "DIFFICULTY_UNSPECIFIED":
      return Difficulty.DIFFICULTY_UNSPECIFIED;
    case 1:
    case "EASY":
      return Difficulty.EASY;
    case 2:
    case "MEDIUM":
      return Difficulty.MEDIUM;
    case 3:
    case "HARD":
      return Difficulty.HARD;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Difficulty.UNRECOGNIZED;
  }
}

export function difficultyToJSON(object: Difficulty): string {
  switch (object) {
    case Difficulty.DIFFICULTY_UNSPECIFIED:
      return "DIFFICULTY_UNSPECIFIED";
    case Difficulty.EASY:
      return "EASY";
    case Difficulty.MEDIUM:
      return "MEDIUM";
    case Difficulty.HARD:
      return "HARD";
    case Difficulty.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum TestCaseCollectionType {
  TYPE_UNSPECIFIED = 0,
  RUN = 1,
  SUBMIT = 2,
  UNRECOGNIZED = -1,
}

export function testCaseCollectionTypeFromJSON(object: any): TestCaseCollectionType {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return TestCaseCollectionType.TYPE_UNSPECIFIED;
    case 1:
    case "RUN":
      return TestCaseCollectionType.RUN;
    case 2:
    case "SUBMIT":
      return TestCaseCollectionType.SUBMIT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TestCaseCollectionType.UNRECOGNIZED;
  }
}

export function testCaseCollectionTypeToJSON(object: TestCaseCollectionType): string {
  switch (object) {
    case TestCaseCollectionType.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case TestCaseCollectionType.RUN:
      return "RUN";
    case TestCaseCollectionType.SUBMIT:
      return "SUBMIT";
    case TestCaseCollectionType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface TestCase {
  Id: string;
  input: string;
  output: string;
}

export interface TestCaseCollection {
  run: TestCase[];
  submit: TestCase[];
}

export interface Example {
  Id: string;
  input: string;
  output: string;
  explanation: string;
}

export interface StarterCode {
  Id: string;
  language: Language;
  code: string;
}

export interface SolutionCode {
  Id: string;
  language: Language;
  code: string;
  executionTime: number;
  memoryTaken: number;
}

export interface UpdateSolutionCode {
  language?: Language | undefined;
  code?: string | undefined;
  executionTime?: number | undefined;
  memoryTaken?: number | undefined;
}

export interface Problem {
  Id: string;
  questionId: string;
  title: string;
  decription: string;
  difficulty: Difficulty;
  tags: string[];
  constraints: string[];
  starterCodes: StarterCode[];
  testcaseCollection?: TestCaseCollection | undefined;
  examples: Example[];
  active: boolean;
  solutionCodes: SolutionCode[];
  createdAt: string;
  updatedAt: string;
}

export interface ListProblemDetails {
  Id: string;
  title: string;
  questionId: string;
  difficulty: Difficulty;
  tags: string[];
  active: boolean;
  createdAt: string;
  updatedAt: string;
}

export interface CreateProblemRequest {
  questionId: string;
  title: string;
  description: string;
  difficulty: Difficulty;
  tags: string[];
}

export interface GetProblemRequest {
  Id: string;
  title?: string | undefined;
  questionId?: string | undefined;
}

export interface GetProblemPublicResponse {
  Id: string;
  questionId: string;
  title: string;
  decription: string;
  difficulty: Difficulty;
  tags: string[];
  constraints: string[];
  starterCodes: StarterCode[];
  run: TestCase[];
  examples: Example[];
  createdAt: string;
  updatedAt: string;
}

export interface ListProblemRequest {
  page: number;
  limit: number;
  /** optional filters */
  difficulty?: Difficulty | undefined;
  tag?: string | undefined;
  active?: boolean | undefined;
  search?: string | undefined;
  questionId?: string | undefined;
}

export interface ListProblemResponse {
  problems: ListProblemDetails[];
  totalPage: number;
  currentPage: number;
  totalItems: number;
}

export interface UpdateBasicProblemDetailsRequest {
  Id: string;
  questionId?: string | undefined;
  title?: string | undefined;
  description?: string | undefined;
  difficulty?: Difficulty | undefined;
  active?: boolean | undefined;
  tags: string[];
  constraints: string[];
  examples: Example[];
  starterCodes: StarterCode[];
}

export interface AddTestCaseRequest {
  Id: string;
  testCaseCollectionType: TestCaseCollectionType;
  testCase?: TestCase | undefined;
}

export interface BulkUploadTestCasesRequest {
  Id: string;
  testCaseCollectionType: TestCaseCollectionType;
  testCase: TestCase[];
}

export interface RemoveTestCaseRequest {
  Id: string;
  testCaseId: string;
  testCaseCollectionType: TestCaseCollectionType;
}

export interface AddSolutionCodeRequest {
  Id: string;
  solutionCode?: SolutionCode | undefined;
}

export interface UpdateSolutionCodeRequest {
  Id: string;
  solutionCodeId: string;
  solutionCode?: UpdateSolutionCode | undefined;
}

export interface RemoveSolutionCodeRequest {
  Id: string;
  solutionCodeId: string;
}

export interface Stats {
  totalTestCase: number;
  passedTestCase: number;
  failedTestCase: number;
}

export interface FailedTestCase {
  index: number;
  input: string;
  output: string;
  expectedOutput: string;
}

export interface ExecutionResult {
  stats?: Stats | undefined;
  failedTestCase?: FailedTestCase | undefined;
}

export interface Submission {
  Id: string;
  problemId: string;
  userId: string;
  country: string;
  title: string;
  battleId?: string | undefined;
  score: number;
  language: Language;
  userCode: string;
  executionResult?: ExecutionResult | undefined;
  executionTime?: number | undefined;
  memoryUsage?: number | undefined;
  difficulty: Difficulty;
  isFirst: boolean;
  updatedAt: string;
  createdAt: string;
}

export interface CreateSubmissionRequest {
  problemId: string;
  userId: string;
  battleId?: string | undefined;
  country?: string | undefined;
  title: string;
  language: Language;
  userCode: string;
  difficulty: Difficulty;
}

export interface UpdateSubmissionRequest {
  Id: string;
  executionResult?: ExecutionResult | undefined;
  executionTime: number;
  memoryUsage: number;
}

export interface GetSubmissionsRequest {
  page: number;
  limit: number;
  problemId?: string | undefined;
  battleId?: string | undefined;
  userId?: string | undefined;
}

export interface GetSubmissionsResponse {
  submissions: Submission[];
  totalPage: number;
  currentPage: number;
  totalItems: number;
}

function createBaseTestCase(): TestCase {
  return { Id: "", input: "", output: "" };
}

export const TestCase: MessageFns<TestCase> = {
  encode(message: TestCase, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.Id !== "") {
      writer.uint32(10).string(message.Id);
    }
    if (message.input !== "") {
      writer.uint32(18).string(message.input);
    }
    if (message.output !== "") {
      writer.uint32(26).string(message.output);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TestCase {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTestCase();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.Id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.input = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.output = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TestCase {
    return {
      Id: isSet(object.Id) ? globalThis.String(object.Id) : "",
      input: isSet(object.input) ? globalThis.String(object.input) : "",
      output: isSet(object.output) ? globalThis.String(object.output) : "",
    };
  },

  toJSON(message: TestCase): unknown {
    const obj: any = {};
    if (message.Id !== "") {
      obj.Id = message.Id;
    }
    if (message.input !== "") {
      obj.input = message.input;
    }
    if (message.output !== "") {
      obj.output = message.output;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TestCase>, I>>(base?: I): TestCase {
    return TestCase.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TestCase>, I>>(object: I): TestCase {
    const message = createBaseTestCase();
    message.Id = object.Id ?? "";
    message.input = object.input ?? "";
    message.output = object.output ?? "";
    return message;
  },
};

function createBaseTestCaseCollection(): TestCaseCollection {
  return { run: [], submit: [] };
}

export const TestCaseCollection: MessageFns<TestCaseCollection> = {
  encode(message: TestCaseCollection, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.run) {
      TestCase.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.submit) {
      TestCase.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TestCaseCollection {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTestCaseCollection();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.run.push(TestCase.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.submit.push(TestCase.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TestCaseCollection {
    return {
      run: globalThis.Array.isArray(object?.run) ? object.run.map((e: any) => TestCase.fromJSON(e)) : [],
      submit: globalThis.Array.isArray(object?.submit) ? object.submit.map((e: any) => TestCase.fromJSON(e)) : [],
    };
  },

  toJSON(message: TestCaseCollection): unknown {
    const obj: any = {};
    if (message.run?.length) {
      obj.run = message.run.map((e) => TestCase.toJSON(e));
    }
    if (message.submit?.length) {
      obj.submit = message.submit.map((e) => TestCase.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TestCaseCollection>, I>>(base?: I): TestCaseCollection {
    return TestCaseCollection.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TestCaseCollection>, I>>(object: I): TestCaseCollection {
    const message = createBaseTestCaseCollection();
    message.run = object.run?.map((e) => TestCase.fromPartial(e)) || [];
    message.submit = object.submit?.map((e) => TestCase.fromPartial(e)) || [];
    return message;
  },
};

function createBaseExample(): Example {
  return { Id: "", input: "", output: "", explanation: "" };
}

export const Example: MessageFns<Example> = {
  encode(message: Example, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.Id !== "") {
      writer.uint32(10).string(message.Id);
    }
    if (message.input !== "") {
      writer.uint32(18).string(message.input);
    }
    if (message.output !== "") {
      writer.uint32(26).string(message.output);
    }
    if (message.explanation !== "") {
      writer.uint32(34).string(message.explanation);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Example {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExample();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.Id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.input = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.output = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.explanation = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Example {
    return {
      Id: isSet(object.Id) ? globalThis.String(object.Id) : "",
      input: isSet(object.input) ? globalThis.String(object.input) : "",
      output: isSet(object.output) ? globalThis.String(object.output) : "",
      explanation: isSet(object.explanation) ? globalThis.String(object.explanation) : "",
    };
  },

  toJSON(message: Example): unknown {
    const obj: any = {};
    if (message.Id !== "") {
      obj.Id = message.Id;
    }
    if (message.input !== "") {
      obj.input = message.input;
    }
    if (message.output !== "") {
      obj.output = message.output;
    }
    if (message.explanation !== "") {
      obj.explanation = message.explanation;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Example>, I>>(base?: I): Example {
    return Example.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Example>, I>>(object: I): Example {
    const message = createBaseExample();
    message.Id = object.Id ?? "";
    message.input = object.input ?? "";
    message.output = object.output ?? "";
    message.explanation = object.explanation ?? "";
    return message;
  },
};

function createBaseStarterCode(): StarterCode {
  return { Id: "", language: 0, code: "" };
}

export const StarterCode: MessageFns<StarterCode> = {
  encode(message: StarterCode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.Id !== "") {
      writer.uint32(10).string(message.Id);
    }
    if (message.language !== 0) {
      writer.uint32(16).int32(message.language);
    }
    if (message.code !== "") {
      writer.uint32(26).string(message.code);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StarterCode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStarterCode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.Id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.language = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.code = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StarterCode {
    return {
      Id: isSet(object.Id) ? globalThis.String(object.Id) : "",
      language: isSet(object.language) ? languageFromJSON(object.language) : 0,
      code: isSet(object.code) ? globalThis.String(object.code) : "",
    };
  },

  toJSON(message: StarterCode): unknown {
    const obj: any = {};
    if (message.Id !== "") {
      obj.Id = message.Id;
    }
    if (message.language !== 0) {
      obj.language = languageToJSON(message.language);
    }
    if (message.code !== "") {
      obj.code = message.code;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StarterCode>, I>>(base?: I): StarterCode {
    return StarterCode.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StarterCode>, I>>(object: I): StarterCode {
    const message = createBaseStarterCode();
    message.Id = object.Id ?? "";
    message.language = object.language ?? 0;
    message.code = object.code ?? "";
    return message;
  },
};

function createBaseSolutionCode(): SolutionCode {
  return { Id: "", language: 0, code: "", executionTime: 0, memoryTaken: 0 };
}

export const SolutionCode: MessageFns<SolutionCode> = {
  encode(message: SolutionCode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.Id !== "") {
      writer.uint32(10).string(message.Id);
    }
    if (message.language !== 0) {
      writer.uint32(16).int32(message.language);
    }
    if (message.code !== "") {
      writer.uint32(26).string(message.code);
    }
    if (message.executionTime !== 0) {
      writer.uint32(32).int32(message.executionTime);
    }
    if (message.memoryTaken !== 0) {
      writer.uint32(40).int32(message.memoryTaken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SolutionCode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSolutionCode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.Id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.language = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.executionTime = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.memoryTaken = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SolutionCode {
    return {
      Id: isSet(object.Id) ? globalThis.String(object.Id) : "",
      language: isSet(object.language) ? languageFromJSON(object.language) : 0,
      code: isSet(object.code) ? globalThis.String(object.code) : "",
      executionTime: isSet(object.executionTime) ? globalThis.Number(object.executionTime) : 0,
      memoryTaken: isSet(object.memoryTaken) ? globalThis.Number(object.memoryTaken) : 0,
    };
  },

  toJSON(message: SolutionCode): unknown {
    const obj: any = {};
    if (message.Id !== "") {
      obj.Id = message.Id;
    }
    if (message.language !== 0) {
      obj.language = languageToJSON(message.language);
    }
    if (message.code !== "") {
      obj.code = message.code;
    }
    if (message.executionTime !== 0) {
      obj.executionTime = Math.round(message.executionTime);
    }
    if (message.memoryTaken !== 0) {
      obj.memoryTaken = Math.round(message.memoryTaken);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SolutionCode>, I>>(base?: I): SolutionCode {
    return SolutionCode.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SolutionCode>, I>>(object: I): SolutionCode {
    const message = createBaseSolutionCode();
    message.Id = object.Id ?? "";
    message.language = object.language ?? 0;
    message.code = object.code ?? "";
    message.executionTime = object.executionTime ?? 0;
    message.memoryTaken = object.memoryTaken ?? 0;
    return message;
  },
};

function createBaseUpdateSolutionCode(): UpdateSolutionCode {
  return { language: undefined, code: undefined, executionTime: undefined, memoryTaken: undefined };
}

export const UpdateSolutionCode: MessageFns<UpdateSolutionCode> = {
  encode(message: UpdateSolutionCode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.language !== undefined) {
      writer.uint32(16).int32(message.language);
    }
    if (message.code !== undefined) {
      writer.uint32(26).string(message.code);
    }
    if (message.executionTime !== undefined) {
      writer.uint32(32).int32(message.executionTime);
    }
    if (message.memoryTaken !== undefined) {
      writer.uint32(40).int32(message.memoryTaken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateSolutionCode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateSolutionCode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.language = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.executionTime = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.memoryTaken = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateSolutionCode {
    return {
      language: isSet(object.language) ? languageFromJSON(object.language) : undefined,
      code: isSet(object.code) ? globalThis.String(object.code) : undefined,
      executionTime: isSet(object.executionTime) ? globalThis.Number(object.executionTime) : undefined,
      memoryTaken: isSet(object.memoryTaken) ? globalThis.Number(object.memoryTaken) : undefined,
    };
  },

  toJSON(message: UpdateSolutionCode): unknown {
    const obj: any = {};
    if (message.language !== undefined) {
      obj.language = languageToJSON(message.language);
    }
    if (message.code !== undefined) {
      obj.code = message.code;
    }
    if (message.executionTime !== undefined) {
      obj.executionTime = Math.round(message.executionTime);
    }
    if (message.memoryTaken !== undefined) {
      obj.memoryTaken = Math.round(message.memoryTaken);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateSolutionCode>, I>>(base?: I): UpdateSolutionCode {
    return UpdateSolutionCode.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateSolutionCode>, I>>(object: I): UpdateSolutionCode {
    const message = createBaseUpdateSolutionCode();
    message.language = object.language ?? undefined;
    message.code = object.code ?? undefined;
    message.executionTime = object.executionTime ?? undefined;
    message.memoryTaken = object.memoryTaken ?? undefined;
    return message;
  },
};

function createBaseProblem(): Problem {
  return {
    Id: "",
    questionId: "",
    title: "",
    decription: "",
    difficulty: 0,
    tags: [],
    constraints: [],
    starterCodes: [],
    testcaseCollection: undefined,
    examples: [],
    active: false,
    solutionCodes: [],
    createdAt: "",
    updatedAt: "",
  };
}

export const Problem: MessageFns<Problem> = {
  encode(message: Problem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.Id !== "") {
      writer.uint32(10).string(message.Id);
    }
    if (message.questionId !== "") {
      writer.uint32(18).string(message.questionId);
    }
    if (message.title !== "") {
      writer.uint32(26).string(message.title);
    }
    if (message.decription !== "") {
      writer.uint32(34).string(message.decription);
    }
    if (message.difficulty !== 0) {
      writer.uint32(40).int32(message.difficulty);
    }
    for (const v of message.tags) {
      writer.uint32(50).string(v!);
    }
    for (const v of message.constraints) {
      writer.uint32(58).string(v!);
    }
    for (const v of message.starterCodes) {
      StarterCode.encode(v!, writer.uint32(66).fork()).join();
    }
    if (message.testcaseCollection !== undefined) {
      TestCaseCollection.encode(message.testcaseCollection, writer.uint32(74).fork()).join();
    }
    for (const v of message.examples) {
      Example.encode(v!, writer.uint32(82).fork()).join();
    }
    if (message.active !== false) {
      writer.uint32(88).bool(message.active);
    }
    for (const v of message.solutionCodes) {
      SolutionCode.encode(v!, writer.uint32(98).fork()).join();
    }
    if (message.createdAt !== "") {
      writer.uint32(106).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(114).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Problem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProblem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.Id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.questionId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.decription = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.difficulty = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.constraints.push(reader.string());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.starterCodes.push(StarterCode.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.testcaseCollection = TestCaseCollection.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.examples.push(Example.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.active = reader.bool();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.solutionCodes.push(SolutionCode.decode(reader, reader.uint32()));
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Problem {
    return {
      Id: isSet(object.Id) ? globalThis.String(object.Id) : "",
      questionId: isSet(object.questionId) ? globalThis.String(object.questionId) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      decription: isSet(object.decription) ? globalThis.String(object.decription) : "",
      difficulty: isSet(object.difficulty) ? difficultyFromJSON(object.difficulty) : 0,
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      constraints: globalThis.Array.isArray(object?.constraints)
        ? object.constraints.map((e: any) => globalThis.String(e))
        : [],
      starterCodes: globalThis.Array.isArray(object?.starterCodes)
        ? object.starterCodes.map((e: any) => StarterCode.fromJSON(e))
        : [],
      testcaseCollection: isSet(object.testcaseCollection)
        ? TestCaseCollection.fromJSON(object.testcaseCollection)
        : undefined,
      examples: globalThis.Array.isArray(object?.examples) ? object.examples.map((e: any) => Example.fromJSON(e)) : [],
      active: isSet(object.active) ? globalThis.Boolean(object.active) : false,
      solutionCodes: globalThis.Array.isArray(object?.solutionCodes)
        ? object.solutionCodes.map((e: any) => SolutionCode.fromJSON(e))
        : [],
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
      updatedAt: isSet(object.updatedAt) ? globalThis.String(object.updatedAt) : "",
    };
  },

  toJSON(message: Problem): unknown {
    const obj: any = {};
    if (message.Id !== "") {
      obj.Id = message.Id;
    }
    if (message.questionId !== "") {
      obj.questionId = message.questionId;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.decription !== "") {
      obj.decription = message.decription;
    }
    if (message.difficulty !== 0) {
      obj.difficulty = difficultyToJSON(message.difficulty);
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.constraints?.length) {
      obj.constraints = message.constraints;
    }
    if (message.starterCodes?.length) {
      obj.starterCodes = message.starterCodes.map((e) => StarterCode.toJSON(e));
    }
    if (message.testcaseCollection !== undefined) {
      obj.testcaseCollection = TestCaseCollection.toJSON(message.testcaseCollection);
    }
    if (message.examples?.length) {
      obj.examples = message.examples.map((e) => Example.toJSON(e));
    }
    if (message.active !== false) {
      obj.active = message.active;
    }
    if (message.solutionCodes?.length) {
      obj.solutionCodes = message.solutionCodes.map((e) => SolutionCode.toJSON(e));
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Problem>, I>>(base?: I): Problem {
    return Problem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Problem>, I>>(object: I): Problem {
    const message = createBaseProblem();
    message.Id = object.Id ?? "";
    message.questionId = object.questionId ?? "";
    message.title = object.title ?? "";
    message.decription = object.decription ?? "";
    message.difficulty = object.difficulty ?? 0;
    message.tags = object.tags?.map((e) => e) || [];
    message.constraints = object.constraints?.map((e) => e) || [];
    message.starterCodes = object.starterCodes?.map((e) => StarterCode.fromPartial(e)) || [];
    message.testcaseCollection = (object.testcaseCollection !== undefined && object.testcaseCollection !== null)
      ? TestCaseCollection.fromPartial(object.testcaseCollection)
      : undefined;
    message.examples = object.examples?.map((e) => Example.fromPartial(e)) || [];
    message.active = object.active ?? false;
    message.solutionCodes = object.solutionCodes?.map((e) => SolutionCode.fromPartial(e)) || [];
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? "";
    return message;
  },
};

function createBaseListProblemDetails(): ListProblemDetails {
  return { Id: "", title: "", questionId: "", difficulty: 0, tags: [], active: false, createdAt: "", updatedAt: "" };
}

export const ListProblemDetails: MessageFns<ListProblemDetails> = {
  encode(message: ListProblemDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.Id !== "") {
      writer.uint32(10).string(message.Id);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.questionId !== "") {
      writer.uint32(26).string(message.questionId);
    }
    if (message.difficulty !== 0) {
      writer.uint32(32).int32(message.difficulty);
    }
    for (const v of message.tags) {
      writer.uint32(50).string(v!);
    }
    if (message.active !== false) {
      writer.uint32(88).bool(message.active);
    }
    if (message.createdAt !== "") {
      writer.uint32(106).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(114).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListProblemDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListProblemDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.Id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.questionId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.difficulty = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.active = reader.bool();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListProblemDetails {
    return {
      Id: isSet(object.Id) ? globalThis.String(object.Id) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      questionId: isSet(object.questionId) ? globalThis.String(object.questionId) : "",
      difficulty: isSet(object.difficulty) ? difficultyFromJSON(object.difficulty) : 0,
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      active: isSet(object.active) ? globalThis.Boolean(object.active) : false,
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
      updatedAt: isSet(object.updatedAt) ? globalThis.String(object.updatedAt) : "",
    };
  },

  toJSON(message: ListProblemDetails): unknown {
    const obj: any = {};
    if (message.Id !== "") {
      obj.Id = message.Id;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.questionId !== "") {
      obj.questionId = message.questionId;
    }
    if (message.difficulty !== 0) {
      obj.difficulty = difficultyToJSON(message.difficulty);
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.active !== false) {
      obj.active = message.active;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListProblemDetails>, I>>(base?: I): ListProblemDetails {
    return ListProblemDetails.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListProblemDetails>, I>>(object: I): ListProblemDetails {
    const message = createBaseListProblemDetails();
    message.Id = object.Id ?? "";
    message.title = object.title ?? "";
    message.questionId = object.questionId ?? "";
    message.difficulty = object.difficulty ?? 0;
    message.tags = object.tags?.map((e) => e) || [];
    message.active = object.active ?? false;
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? "";
    return message;
  },
};

function createBaseCreateProblemRequest(): CreateProblemRequest {
  return { questionId: "", title: "", description: "", difficulty: 0, tags: [] };
}

export const CreateProblemRequest: MessageFns<CreateProblemRequest> = {
  encode(message: CreateProblemRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.questionId !== "") {
      writer.uint32(10).string(message.questionId);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.difficulty !== 0) {
      writer.uint32(32).int32(message.difficulty);
    }
    for (const v of message.tags) {
      writer.uint32(42).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateProblemRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateProblemRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.questionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.difficulty = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateProblemRequest {
    return {
      questionId: isSet(object.questionId) ? globalThis.String(object.questionId) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      difficulty: isSet(object.difficulty) ? difficultyFromJSON(object.difficulty) : 0,
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: CreateProblemRequest): unknown {
    const obj: any = {};
    if (message.questionId !== "") {
      obj.questionId = message.questionId;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.difficulty !== 0) {
      obj.difficulty = difficultyToJSON(message.difficulty);
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateProblemRequest>, I>>(base?: I): CreateProblemRequest {
    return CreateProblemRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateProblemRequest>, I>>(object: I): CreateProblemRequest {
    const message = createBaseCreateProblemRequest();
    message.questionId = object.questionId ?? "";
    message.title = object.title ?? "";
    message.description = object.description ?? "";
    message.difficulty = object.difficulty ?? 0;
    message.tags = object.tags?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetProblemRequest(): GetProblemRequest {
  return { Id: "", title: undefined, questionId: undefined };
}

export const GetProblemRequest: MessageFns<GetProblemRequest> = {
  encode(message: GetProblemRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.Id !== "") {
      writer.uint32(10).string(message.Id);
    }
    if (message.title !== undefined) {
      writer.uint32(18).string(message.title);
    }
    if (message.questionId !== undefined) {
      writer.uint32(26).string(message.questionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetProblemRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProblemRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.Id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.questionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetProblemRequest {
    return {
      Id: isSet(object.Id) ? globalThis.String(object.Id) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : undefined,
      questionId: isSet(object.questionId) ? globalThis.String(object.questionId) : undefined,
    };
  },

  toJSON(message: GetProblemRequest): unknown {
    const obj: any = {};
    if (message.Id !== "") {
      obj.Id = message.Id;
    }
    if (message.title !== undefined) {
      obj.title = message.title;
    }
    if (message.questionId !== undefined) {
      obj.questionId = message.questionId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetProblemRequest>, I>>(base?: I): GetProblemRequest {
    return GetProblemRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetProblemRequest>, I>>(object: I): GetProblemRequest {
    const message = createBaseGetProblemRequest();
    message.Id = object.Id ?? "";
    message.title = object.title ?? undefined;
    message.questionId = object.questionId ?? undefined;
    return message;
  },
};

function createBaseGetProblemPublicResponse(): GetProblemPublicResponse {
  return {
    Id: "",
    questionId: "",
    title: "",
    decription: "",
    difficulty: 0,
    tags: [],
    constraints: [],
    starterCodes: [],
    run: [],
    examples: [],
    createdAt: "",
    updatedAt: "",
  };
}

export const GetProblemPublicResponse: MessageFns<GetProblemPublicResponse> = {
  encode(message: GetProblemPublicResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.Id !== "") {
      writer.uint32(10).string(message.Id);
    }
    if (message.questionId !== "") {
      writer.uint32(18).string(message.questionId);
    }
    if (message.title !== "") {
      writer.uint32(26).string(message.title);
    }
    if (message.decription !== "") {
      writer.uint32(34).string(message.decription);
    }
    if (message.difficulty !== 0) {
      writer.uint32(40).int32(message.difficulty);
    }
    for (const v of message.tags) {
      writer.uint32(50).string(v!);
    }
    for (const v of message.constraints) {
      writer.uint32(58).string(v!);
    }
    for (const v of message.starterCodes) {
      StarterCode.encode(v!, writer.uint32(66).fork()).join();
    }
    for (const v of message.run) {
      TestCase.encode(v!, writer.uint32(74).fork()).join();
    }
    for (const v of message.examples) {
      Example.encode(v!, writer.uint32(82).fork()).join();
    }
    if (message.createdAt !== "") {
      writer.uint32(106).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(114).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetProblemPublicResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProblemPublicResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.Id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.questionId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.decription = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.difficulty = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.constraints.push(reader.string());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.starterCodes.push(StarterCode.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.run.push(TestCase.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.examples.push(Example.decode(reader, reader.uint32()));
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetProblemPublicResponse {
    return {
      Id: isSet(object.Id) ? globalThis.String(object.Id) : "",
      questionId: isSet(object.questionId) ? globalThis.String(object.questionId) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      decription: isSet(object.decription) ? globalThis.String(object.decription) : "",
      difficulty: isSet(object.difficulty) ? difficultyFromJSON(object.difficulty) : 0,
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      constraints: globalThis.Array.isArray(object?.constraints)
        ? object.constraints.map((e: any) => globalThis.String(e))
        : [],
      starterCodes: globalThis.Array.isArray(object?.starterCodes)
        ? object.starterCodes.map((e: any) => StarterCode.fromJSON(e))
        : [],
      run: globalThis.Array.isArray(object?.run) ? object.run.map((e: any) => TestCase.fromJSON(e)) : [],
      examples: globalThis.Array.isArray(object?.examples) ? object.examples.map((e: any) => Example.fromJSON(e)) : [],
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
      updatedAt: isSet(object.updatedAt) ? globalThis.String(object.updatedAt) : "",
    };
  },

  toJSON(message: GetProblemPublicResponse): unknown {
    const obj: any = {};
    if (message.Id !== "") {
      obj.Id = message.Id;
    }
    if (message.questionId !== "") {
      obj.questionId = message.questionId;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.decription !== "") {
      obj.decription = message.decription;
    }
    if (message.difficulty !== 0) {
      obj.difficulty = difficultyToJSON(message.difficulty);
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.constraints?.length) {
      obj.constraints = message.constraints;
    }
    if (message.starterCodes?.length) {
      obj.starterCodes = message.starterCodes.map((e) => StarterCode.toJSON(e));
    }
    if (message.run?.length) {
      obj.run = message.run.map((e) => TestCase.toJSON(e));
    }
    if (message.examples?.length) {
      obj.examples = message.examples.map((e) => Example.toJSON(e));
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetProblemPublicResponse>, I>>(base?: I): GetProblemPublicResponse {
    return GetProblemPublicResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetProblemPublicResponse>, I>>(object: I): GetProblemPublicResponse {
    const message = createBaseGetProblemPublicResponse();
    message.Id = object.Id ?? "";
    message.questionId = object.questionId ?? "";
    message.title = object.title ?? "";
    message.decription = object.decription ?? "";
    message.difficulty = object.difficulty ?? 0;
    message.tags = object.tags?.map((e) => e) || [];
    message.constraints = object.constraints?.map((e) => e) || [];
    message.starterCodes = object.starterCodes?.map((e) => StarterCode.fromPartial(e)) || [];
    message.run = object.run?.map((e) => TestCase.fromPartial(e)) || [];
    message.examples = object.examples?.map((e) => Example.fromPartial(e)) || [];
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? "";
    return message;
  },
};

function createBaseListProblemRequest(): ListProblemRequest {
  return {
    page: 0,
    limit: 0,
    difficulty: undefined,
    tag: undefined,
    active: undefined,
    search: undefined,
    questionId: undefined,
  };
}

export const ListProblemRequest: MessageFns<ListProblemRequest> = {
  encode(message: ListProblemRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.page !== 0) {
      writer.uint32(8).int32(message.page);
    }
    if (message.limit !== 0) {
      writer.uint32(16).int32(message.limit);
    }
    if (message.difficulty !== undefined) {
      writer.uint32(24).int32(message.difficulty);
    }
    if (message.tag !== undefined) {
      writer.uint32(34).string(message.tag);
    }
    if (message.active !== undefined) {
      writer.uint32(40).bool(message.active);
    }
    if (message.search !== undefined) {
      writer.uint32(50).string(message.search);
    }
    if (message.questionId !== undefined) {
      writer.uint32(58).string(message.questionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListProblemRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListProblemRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.difficulty = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.tag = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.active = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.search = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.questionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListProblemRequest {
    return {
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
      difficulty: isSet(object.difficulty) ? difficultyFromJSON(object.difficulty) : undefined,
      tag: isSet(object.tag) ? globalThis.String(object.tag) : undefined,
      active: isSet(object.active) ? globalThis.Boolean(object.active) : undefined,
      search: isSet(object.search) ? globalThis.String(object.search) : undefined,
      questionId: isSet(object.questionId) ? globalThis.String(object.questionId) : undefined,
    };
  },

  toJSON(message: ListProblemRequest): unknown {
    const obj: any = {};
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    if (message.difficulty !== undefined) {
      obj.difficulty = difficultyToJSON(message.difficulty);
    }
    if (message.tag !== undefined) {
      obj.tag = message.tag;
    }
    if (message.active !== undefined) {
      obj.active = message.active;
    }
    if (message.search !== undefined) {
      obj.search = message.search;
    }
    if (message.questionId !== undefined) {
      obj.questionId = message.questionId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListProblemRequest>, I>>(base?: I): ListProblemRequest {
    return ListProblemRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListProblemRequest>, I>>(object: I): ListProblemRequest {
    const message = createBaseListProblemRequest();
    message.page = object.page ?? 0;
    message.limit = object.limit ?? 0;
    message.difficulty = object.difficulty ?? undefined;
    message.tag = object.tag ?? undefined;
    message.active = object.active ?? undefined;
    message.search = object.search ?? undefined;
    message.questionId = object.questionId ?? undefined;
    return message;
  },
};

function createBaseListProblemResponse(): ListProblemResponse {
  return { problems: [], totalPage: 0, currentPage: 0, totalItems: 0 };
}

export const ListProblemResponse: MessageFns<ListProblemResponse> = {
  encode(message: ListProblemResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.problems) {
      ListProblemDetails.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.totalPage !== 0) {
      writer.uint32(16).int32(message.totalPage);
    }
    if (message.currentPage !== 0) {
      writer.uint32(24).int32(message.currentPage);
    }
    if (message.totalItems !== 0) {
      writer.uint32(32).int32(message.totalItems);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListProblemResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListProblemResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.problems.push(ListProblemDetails.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.totalPage = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.currentPage = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.totalItems = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListProblemResponse {
    return {
      problems: globalThis.Array.isArray(object?.problems)
        ? object.problems.map((e: any) => ListProblemDetails.fromJSON(e))
        : [],
      totalPage: isSet(object.totalPage) ? globalThis.Number(object.totalPage) : 0,
      currentPage: isSet(object.currentPage) ? globalThis.Number(object.currentPage) : 0,
      totalItems: isSet(object.totalItems) ? globalThis.Number(object.totalItems) : 0,
    };
  },

  toJSON(message: ListProblemResponse): unknown {
    const obj: any = {};
    if (message.problems?.length) {
      obj.problems = message.problems.map((e) => ListProblemDetails.toJSON(e));
    }
    if (message.totalPage !== 0) {
      obj.totalPage = Math.round(message.totalPage);
    }
    if (message.currentPage !== 0) {
      obj.currentPage = Math.round(message.currentPage);
    }
    if (message.totalItems !== 0) {
      obj.totalItems = Math.round(message.totalItems);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListProblemResponse>, I>>(base?: I): ListProblemResponse {
    return ListProblemResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListProblemResponse>, I>>(object: I): ListProblemResponse {
    const message = createBaseListProblemResponse();
    message.problems = object.problems?.map((e) => ListProblemDetails.fromPartial(e)) || [];
    message.totalPage = object.totalPage ?? 0;
    message.currentPage = object.currentPage ?? 0;
    message.totalItems = object.totalItems ?? 0;
    return message;
  },
};

function createBaseUpdateBasicProblemDetailsRequest(): UpdateBasicProblemDetailsRequest {
  return {
    Id: "",
    questionId: undefined,
    title: undefined,
    description: undefined,
    difficulty: undefined,
    active: undefined,
    tags: [],
    constraints: [],
    examples: [],
    starterCodes: [],
  };
}

export const UpdateBasicProblemDetailsRequest: MessageFns<UpdateBasicProblemDetailsRequest> = {
  encode(message: UpdateBasicProblemDetailsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.Id !== "") {
      writer.uint32(10).string(message.Id);
    }
    if (message.questionId !== undefined) {
      writer.uint32(18).string(message.questionId);
    }
    if (message.title !== undefined) {
      writer.uint32(26).string(message.title);
    }
    if (message.description !== undefined) {
      writer.uint32(34).string(message.description);
    }
    if (message.difficulty !== undefined) {
      writer.uint32(40).int32(message.difficulty);
    }
    if (message.active !== undefined) {
      writer.uint32(48).bool(message.active);
    }
    for (const v of message.tags) {
      writer.uint32(58).string(v!);
    }
    for (const v of message.constraints) {
      writer.uint32(66).string(v!);
    }
    for (const v of message.examples) {
      Example.encode(v!, writer.uint32(74).fork()).join();
    }
    for (const v of message.starterCodes) {
      StarterCode.encode(v!, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateBasicProblemDetailsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateBasicProblemDetailsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.Id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.questionId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.difficulty = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.active = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.constraints.push(reader.string());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.examples.push(Example.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.starterCodes.push(StarterCode.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateBasicProblemDetailsRequest {
    return {
      Id: isSet(object.Id) ? globalThis.String(object.Id) : "",
      questionId: isSet(object.questionId) ? globalThis.String(object.questionId) : undefined,
      title: isSet(object.title) ? globalThis.String(object.title) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      difficulty: isSet(object.difficulty) ? difficultyFromJSON(object.difficulty) : undefined,
      active: isSet(object.active) ? globalThis.Boolean(object.active) : undefined,
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      constraints: globalThis.Array.isArray(object?.constraints)
        ? object.constraints.map((e: any) => globalThis.String(e))
        : [],
      examples: globalThis.Array.isArray(object?.examples) ? object.examples.map((e: any) => Example.fromJSON(e)) : [],
      starterCodes: globalThis.Array.isArray(object?.starterCodes)
        ? object.starterCodes.map((e: any) => StarterCode.fromJSON(e))
        : [],
    };
  },

  toJSON(message: UpdateBasicProblemDetailsRequest): unknown {
    const obj: any = {};
    if (message.Id !== "") {
      obj.Id = message.Id;
    }
    if (message.questionId !== undefined) {
      obj.questionId = message.questionId;
    }
    if (message.title !== undefined) {
      obj.title = message.title;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.difficulty !== undefined) {
      obj.difficulty = difficultyToJSON(message.difficulty);
    }
    if (message.active !== undefined) {
      obj.active = message.active;
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.constraints?.length) {
      obj.constraints = message.constraints;
    }
    if (message.examples?.length) {
      obj.examples = message.examples.map((e) => Example.toJSON(e));
    }
    if (message.starterCodes?.length) {
      obj.starterCodes = message.starterCodes.map((e) => StarterCode.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateBasicProblemDetailsRequest>, I>>(
    base?: I,
  ): UpdateBasicProblemDetailsRequest {
    return UpdateBasicProblemDetailsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateBasicProblemDetailsRequest>, I>>(
    object: I,
  ): UpdateBasicProblemDetailsRequest {
    const message = createBaseUpdateBasicProblemDetailsRequest();
    message.Id = object.Id ?? "";
    message.questionId = object.questionId ?? undefined;
    message.title = object.title ?? undefined;
    message.description = object.description ?? undefined;
    message.difficulty = object.difficulty ?? undefined;
    message.active = object.active ?? undefined;
    message.tags = object.tags?.map((e) => e) || [];
    message.constraints = object.constraints?.map((e) => e) || [];
    message.examples = object.examples?.map((e) => Example.fromPartial(e)) || [];
    message.starterCodes = object.starterCodes?.map((e) => StarterCode.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAddTestCaseRequest(): AddTestCaseRequest {
  return { Id: "", testCaseCollectionType: 0, testCase: undefined };
}

export const AddTestCaseRequest: MessageFns<AddTestCaseRequest> = {
  encode(message: AddTestCaseRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.Id !== "") {
      writer.uint32(10).string(message.Id);
    }
    if (message.testCaseCollectionType !== 0) {
      writer.uint32(16).int32(message.testCaseCollectionType);
    }
    if (message.testCase !== undefined) {
      TestCase.encode(message.testCase, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddTestCaseRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddTestCaseRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.Id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.testCaseCollectionType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.testCase = TestCase.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddTestCaseRequest {
    return {
      Id: isSet(object.Id) ? globalThis.String(object.Id) : "",
      testCaseCollectionType: isSet(object.testCaseCollectionType)
        ? testCaseCollectionTypeFromJSON(object.testCaseCollectionType)
        : 0,
      testCase: isSet(object.testCase) ? TestCase.fromJSON(object.testCase) : undefined,
    };
  },

  toJSON(message: AddTestCaseRequest): unknown {
    const obj: any = {};
    if (message.Id !== "") {
      obj.Id = message.Id;
    }
    if (message.testCaseCollectionType !== 0) {
      obj.testCaseCollectionType = testCaseCollectionTypeToJSON(message.testCaseCollectionType);
    }
    if (message.testCase !== undefined) {
      obj.testCase = TestCase.toJSON(message.testCase);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddTestCaseRequest>, I>>(base?: I): AddTestCaseRequest {
    return AddTestCaseRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddTestCaseRequest>, I>>(object: I): AddTestCaseRequest {
    const message = createBaseAddTestCaseRequest();
    message.Id = object.Id ?? "";
    message.testCaseCollectionType = object.testCaseCollectionType ?? 0;
    message.testCase = (object.testCase !== undefined && object.testCase !== null)
      ? TestCase.fromPartial(object.testCase)
      : undefined;
    return message;
  },
};

function createBaseBulkUploadTestCasesRequest(): BulkUploadTestCasesRequest {
  return { Id: "", testCaseCollectionType: 0, testCase: [] };
}

export const BulkUploadTestCasesRequest: MessageFns<BulkUploadTestCasesRequest> = {
  encode(message: BulkUploadTestCasesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.Id !== "") {
      writer.uint32(10).string(message.Id);
    }
    if (message.testCaseCollectionType !== 0) {
      writer.uint32(16).int32(message.testCaseCollectionType);
    }
    for (const v of message.testCase) {
      TestCase.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BulkUploadTestCasesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBulkUploadTestCasesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.Id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.testCaseCollectionType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.testCase.push(TestCase.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BulkUploadTestCasesRequest {
    return {
      Id: isSet(object.Id) ? globalThis.String(object.Id) : "",
      testCaseCollectionType: isSet(object.testCaseCollectionType)
        ? testCaseCollectionTypeFromJSON(object.testCaseCollectionType)
        : 0,
      testCase: globalThis.Array.isArray(object?.testCase) ? object.testCase.map((e: any) => TestCase.fromJSON(e)) : [],
    };
  },

  toJSON(message: BulkUploadTestCasesRequest): unknown {
    const obj: any = {};
    if (message.Id !== "") {
      obj.Id = message.Id;
    }
    if (message.testCaseCollectionType !== 0) {
      obj.testCaseCollectionType = testCaseCollectionTypeToJSON(message.testCaseCollectionType);
    }
    if (message.testCase?.length) {
      obj.testCase = message.testCase.map((e) => TestCase.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BulkUploadTestCasesRequest>, I>>(base?: I): BulkUploadTestCasesRequest {
    return BulkUploadTestCasesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BulkUploadTestCasesRequest>, I>>(object: I): BulkUploadTestCasesRequest {
    const message = createBaseBulkUploadTestCasesRequest();
    message.Id = object.Id ?? "";
    message.testCaseCollectionType = object.testCaseCollectionType ?? 0;
    message.testCase = object.testCase?.map((e) => TestCase.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRemoveTestCaseRequest(): RemoveTestCaseRequest {
  return { Id: "", testCaseId: "", testCaseCollectionType: 0 };
}

export const RemoveTestCaseRequest: MessageFns<RemoveTestCaseRequest> = {
  encode(message: RemoveTestCaseRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.Id !== "") {
      writer.uint32(10).string(message.Id);
    }
    if (message.testCaseId !== "") {
      writer.uint32(18).string(message.testCaseId);
    }
    if (message.testCaseCollectionType !== 0) {
      writer.uint32(24).int32(message.testCaseCollectionType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RemoveTestCaseRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveTestCaseRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.Id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.testCaseId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.testCaseCollectionType = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RemoveTestCaseRequest {
    return {
      Id: isSet(object.Id) ? globalThis.String(object.Id) : "",
      testCaseId: isSet(object.testCaseId) ? globalThis.String(object.testCaseId) : "",
      testCaseCollectionType: isSet(object.testCaseCollectionType)
        ? testCaseCollectionTypeFromJSON(object.testCaseCollectionType)
        : 0,
    };
  },

  toJSON(message: RemoveTestCaseRequest): unknown {
    const obj: any = {};
    if (message.Id !== "") {
      obj.Id = message.Id;
    }
    if (message.testCaseId !== "") {
      obj.testCaseId = message.testCaseId;
    }
    if (message.testCaseCollectionType !== 0) {
      obj.testCaseCollectionType = testCaseCollectionTypeToJSON(message.testCaseCollectionType);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RemoveTestCaseRequest>, I>>(base?: I): RemoveTestCaseRequest {
    return RemoveTestCaseRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RemoveTestCaseRequest>, I>>(object: I): RemoveTestCaseRequest {
    const message = createBaseRemoveTestCaseRequest();
    message.Id = object.Id ?? "";
    message.testCaseId = object.testCaseId ?? "";
    message.testCaseCollectionType = object.testCaseCollectionType ?? 0;
    return message;
  },
};

function createBaseAddSolutionCodeRequest(): AddSolutionCodeRequest {
  return { Id: "", solutionCode: undefined };
}

export const AddSolutionCodeRequest: MessageFns<AddSolutionCodeRequest> = {
  encode(message: AddSolutionCodeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.Id !== "") {
      writer.uint32(10).string(message.Id);
    }
    if (message.solutionCode !== undefined) {
      SolutionCode.encode(message.solutionCode, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddSolutionCodeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddSolutionCodeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.Id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.solutionCode = SolutionCode.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddSolutionCodeRequest {
    return {
      Id: isSet(object.Id) ? globalThis.String(object.Id) : "",
      solutionCode: isSet(object.solutionCode) ? SolutionCode.fromJSON(object.solutionCode) : undefined,
    };
  },

  toJSON(message: AddSolutionCodeRequest): unknown {
    const obj: any = {};
    if (message.Id !== "") {
      obj.Id = message.Id;
    }
    if (message.solutionCode !== undefined) {
      obj.solutionCode = SolutionCode.toJSON(message.solutionCode);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddSolutionCodeRequest>, I>>(base?: I): AddSolutionCodeRequest {
    return AddSolutionCodeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddSolutionCodeRequest>, I>>(object: I): AddSolutionCodeRequest {
    const message = createBaseAddSolutionCodeRequest();
    message.Id = object.Id ?? "";
    message.solutionCode = (object.solutionCode !== undefined && object.solutionCode !== null)
      ? SolutionCode.fromPartial(object.solutionCode)
      : undefined;
    return message;
  },
};

function createBaseUpdateSolutionCodeRequest(): UpdateSolutionCodeRequest {
  return { Id: "", solutionCodeId: "", solutionCode: undefined };
}

export const UpdateSolutionCodeRequest: MessageFns<UpdateSolutionCodeRequest> = {
  encode(message: UpdateSolutionCodeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.Id !== "") {
      writer.uint32(10).string(message.Id);
    }
    if (message.solutionCodeId !== "") {
      writer.uint32(18).string(message.solutionCodeId);
    }
    if (message.solutionCode !== undefined) {
      UpdateSolutionCode.encode(message.solutionCode, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateSolutionCodeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateSolutionCodeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.Id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.solutionCodeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.solutionCode = UpdateSolutionCode.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateSolutionCodeRequest {
    return {
      Id: isSet(object.Id) ? globalThis.String(object.Id) : "",
      solutionCodeId: isSet(object.solutionCodeId) ? globalThis.String(object.solutionCodeId) : "",
      solutionCode: isSet(object.solutionCode) ? UpdateSolutionCode.fromJSON(object.solutionCode) : undefined,
    };
  },

  toJSON(message: UpdateSolutionCodeRequest): unknown {
    const obj: any = {};
    if (message.Id !== "") {
      obj.Id = message.Id;
    }
    if (message.solutionCodeId !== "") {
      obj.solutionCodeId = message.solutionCodeId;
    }
    if (message.solutionCode !== undefined) {
      obj.solutionCode = UpdateSolutionCode.toJSON(message.solutionCode);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateSolutionCodeRequest>, I>>(base?: I): UpdateSolutionCodeRequest {
    return UpdateSolutionCodeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateSolutionCodeRequest>, I>>(object: I): UpdateSolutionCodeRequest {
    const message = createBaseUpdateSolutionCodeRequest();
    message.Id = object.Id ?? "";
    message.solutionCodeId = object.solutionCodeId ?? "";
    message.solutionCode = (object.solutionCode !== undefined && object.solutionCode !== null)
      ? UpdateSolutionCode.fromPartial(object.solutionCode)
      : undefined;
    return message;
  },
};

function createBaseRemoveSolutionCodeRequest(): RemoveSolutionCodeRequest {
  return { Id: "", solutionCodeId: "" };
}

export const RemoveSolutionCodeRequest: MessageFns<RemoveSolutionCodeRequest> = {
  encode(message: RemoveSolutionCodeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.Id !== "") {
      writer.uint32(10).string(message.Id);
    }
    if (message.solutionCodeId !== "") {
      writer.uint32(18).string(message.solutionCodeId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RemoveSolutionCodeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveSolutionCodeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.Id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.solutionCodeId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RemoveSolutionCodeRequest {
    return {
      Id: isSet(object.Id) ? globalThis.String(object.Id) : "",
      solutionCodeId: isSet(object.solutionCodeId) ? globalThis.String(object.solutionCodeId) : "",
    };
  },

  toJSON(message: RemoveSolutionCodeRequest): unknown {
    const obj: any = {};
    if (message.Id !== "") {
      obj.Id = message.Id;
    }
    if (message.solutionCodeId !== "") {
      obj.solutionCodeId = message.solutionCodeId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RemoveSolutionCodeRequest>, I>>(base?: I): RemoveSolutionCodeRequest {
    return RemoveSolutionCodeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RemoveSolutionCodeRequest>, I>>(object: I): RemoveSolutionCodeRequest {
    const message = createBaseRemoveSolutionCodeRequest();
    message.Id = object.Id ?? "";
    message.solutionCodeId = object.solutionCodeId ?? "";
    return message;
  },
};

function createBaseStats(): Stats {
  return { totalTestCase: 0, passedTestCase: 0, failedTestCase: 0 };
}

export const Stats: MessageFns<Stats> = {
  encode(message: Stats, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.totalTestCase !== 0) {
      writer.uint32(8).int32(message.totalTestCase);
    }
    if (message.passedTestCase !== 0) {
      writer.uint32(16).int32(message.passedTestCase);
    }
    if (message.failedTestCase !== 0) {
      writer.uint32(24).int32(message.failedTestCase);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Stats {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.totalTestCase = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.passedTestCase = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.failedTestCase = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Stats {
    return {
      totalTestCase: isSet(object.totalTestCase) ? globalThis.Number(object.totalTestCase) : 0,
      passedTestCase: isSet(object.passedTestCase) ? globalThis.Number(object.passedTestCase) : 0,
      failedTestCase: isSet(object.failedTestCase) ? globalThis.Number(object.failedTestCase) : 0,
    };
  },

  toJSON(message: Stats): unknown {
    const obj: any = {};
    if (message.totalTestCase !== 0) {
      obj.totalTestCase = Math.round(message.totalTestCase);
    }
    if (message.passedTestCase !== 0) {
      obj.passedTestCase = Math.round(message.passedTestCase);
    }
    if (message.failedTestCase !== 0) {
      obj.failedTestCase = Math.round(message.failedTestCase);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Stats>, I>>(base?: I): Stats {
    return Stats.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Stats>, I>>(object: I): Stats {
    const message = createBaseStats();
    message.totalTestCase = object.totalTestCase ?? 0;
    message.passedTestCase = object.passedTestCase ?? 0;
    message.failedTestCase = object.failedTestCase ?? 0;
    return message;
  },
};

function createBaseFailedTestCase(): FailedTestCase {
  return { index: 0, input: "", output: "", expectedOutput: "" };
}

export const FailedTestCase: MessageFns<FailedTestCase> = {
  encode(message: FailedTestCase, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.index !== 0) {
      writer.uint32(8).int32(message.index);
    }
    if (message.input !== "") {
      writer.uint32(18).string(message.input);
    }
    if (message.output !== "") {
      writer.uint32(26).string(message.output);
    }
    if (message.expectedOutput !== "") {
      writer.uint32(34).string(message.expectedOutput);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FailedTestCase {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFailedTestCase();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.index = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.input = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.output = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.expectedOutput = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FailedTestCase {
    return {
      index: isSet(object.index) ? globalThis.Number(object.index) : 0,
      input: isSet(object.input) ? globalThis.String(object.input) : "",
      output: isSet(object.output) ? globalThis.String(object.output) : "",
      expectedOutput: isSet(object.expectedOutput) ? globalThis.String(object.expectedOutput) : "",
    };
  },

  toJSON(message: FailedTestCase): unknown {
    const obj: any = {};
    if (message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    if (message.input !== "") {
      obj.input = message.input;
    }
    if (message.output !== "") {
      obj.output = message.output;
    }
    if (message.expectedOutput !== "") {
      obj.expectedOutput = message.expectedOutput;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FailedTestCase>, I>>(base?: I): FailedTestCase {
    return FailedTestCase.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FailedTestCase>, I>>(object: I): FailedTestCase {
    const message = createBaseFailedTestCase();
    message.index = object.index ?? 0;
    message.input = object.input ?? "";
    message.output = object.output ?? "";
    message.expectedOutput = object.expectedOutput ?? "";
    return message;
  },
};

function createBaseExecutionResult(): ExecutionResult {
  return { stats: undefined, failedTestCase: undefined };
}

export const ExecutionResult: MessageFns<ExecutionResult> = {
  encode(message: ExecutionResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.stats !== undefined) {
      Stats.encode(message.stats, writer.uint32(10).fork()).join();
    }
    if (message.failedTestCase !== undefined) {
      FailedTestCase.encode(message.failedTestCase, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExecutionResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecutionResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.stats = Stats.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.failedTestCase = FailedTestCase.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecutionResult {
    return {
      stats: isSet(object.stats) ? Stats.fromJSON(object.stats) : undefined,
      failedTestCase: isSet(object.failedTestCase) ? FailedTestCase.fromJSON(object.failedTestCase) : undefined,
    };
  },

  toJSON(message: ExecutionResult): unknown {
    const obj: any = {};
    if (message.stats !== undefined) {
      obj.stats = Stats.toJSON(message.stats);
    }
    if (message.failedTestCase !== undefined) {
      obj.failedTestCase = FailedTestCase.toJSON(message.failedTestCase);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExecutionResult>, I>>(base?: I): ExecutionResult {
    return ExecutionResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExecutionResult>, I>>(object: I): ExecutionResult {
    const message = createBaseExecutionResult();
    message.stats = (object.stats !== undefined && object.stats !== null) ? Stats.fromPartial(object.stats) : undefined;
    message.failedTestCase = (object.failedTestCase !== undefined && object.failedTestCase !== null)
      ? FailedTestCase.fromPartial(object.failedTestCase)
      : undefined;
    return message;
  },
};

function createBaseSubmission(): Submission {
  return {
    Id: "",
    problemId: "",
    userId: "",
    country: "",
    title: "",
    battleId: undefined,
    score: 0,
    language: 0,
    userCode: "",
    executionResult: undefined,
    executionTime: undefined,
    memoryUsage: undefined,
    difficulty: 0,
    isFirst: false,
    updatedAt: "",
    createdAt: "",
  };
}

export const Submission: MessageFns<Submission> = {
  encode(message: Submission, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.Id !== "") {
      writer.uint32(10).string(message.Id);
    }
    if (message.problemId !== "") {
      writer.uint32(18).string(message.problemId);
    }
    if (message.userId !== "") {
      writer.uint32(26).string(message.userId);
    }
    if (message.country !== "") {
      writer.uint32(34).string(message.country);
    }
    if (message.title !== "") {
      writer.uint32(42).string(message.title);
    }
    if (message.battleId !== undefined) {
      writer.uint32(50).string(message.battleId);
    }
    if (message.score !== 0) {
      writer.uint32(56).int32(message.score);
    }
    if (message.language !== 0) {
      writer.uint32(64).int32(message.language);
    }
    if (message.userCode !== "") {
      writer.uint32(74).string(message.userCode);
    }
    if (message.executionResult !== undefined) {
      ExecutionResult.encode(message.executionResult, writer.uint32(82).fork()).join();
    }
    if (message.executionTime !== undefined) {
      writer.uint32(88).int32(message.executionTime);
    }
    if (message.memoryUsage !== undefined) {
      writer.uint32(96).int32(message.memoryUsage);
    }
    if (message.difficulty !== 0) {
      writer.uint32(104).int32(message.difficulty);
    }
    if (message.isFirst !== false) {
      writer.uint32(112).bool(message.isFirst);
    }
    if (message.updatedAt !== "") {
      writer.uint32(122).string(message.updatedAt);
    }
    if (message.createdAt !== "") {
      writer.uint32(130).string(message.createdAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Submission {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubmission();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.Id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.problemId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.country = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.battleId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.score = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.language = reader.int32() as any;
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.userCode = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.executionResult = ExecutionResult.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.executionTime = reader.int32();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.memoryUsage = reader.int32();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.difficulty = reader.int32() as any;
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.isFirst = reader.bool();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Submission {
    return {
      Id: isSet(object.Id) ? globalThis.String(object.Id) : "",
      problemId: isSet(object.problemId) ? globalThis.String(object.problemId) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      country: isSet(object.country) ? globalThis.String(object.country) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      battleId: isSet(object.battleId) ? globalThis.String(object.battleId) : undefined,
      score: isSet(object.score) ? globalThis.Number(object.score) : 0,
      language: isSet(object.language) ? languageFromJSON(object.language) : 0,
      userCode: isSet(object.userCode) ? globalThis.String(object.userCode) : "",
      executionResult: isSet(object.executionResult) ? ExecutionResult.fromJSON(object.executionResult) : undefined,
      executionTime: isSet(object.executionTime) ? globalThis.Number(object.executionTime) : undefined,
      memoryUsage: isSet(object.memoryUsage) ? globalThis.Number(object.memoryUsage) : undefined,
      difficulty: isSet(object.difficulty) ? difficultyFromJSON(object.difficulty) : 0,
      isFirst: isSet(object.isFirst) ? globalThis.Boolean(object.isFirst) : false,
      updatedAt: isSet(object.updatedAt) ? globalThis.String(object.updatedAt) : "",
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
    };
  },

  toJSON(message: Submission): unknown {
    const obj: any = {};
    if (message.Id !== "") {
      obj.Id = message.Id;
    }
    if (message.problemId !== "") {
      obj.problemId = message.problemId;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.country !== "") {
      obj.country = message.country;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.battleId !== undefined) {
      obj.battleId = message.battleId;
    }
    if (message.score !== 0) {
      obj.score = Math.round(message.score);
    }
    if (message.language !== 0) {
      obj.language = languageToJSON(message.language);
    }
    if (message.userCode !== "") {
      obj.userCode = message.userCode;
    }
    if (message.executionResult !== undefined) {
      obj.executionResult = ExecutionResult.toJSON(message.executionResult);
    }
    if (message.executionTime !== undefined) {
      obj.executionTime = Math.round(message.executionTime);
    }
    if (message.memoryUsage !== undefined) {
      obj.memoryUsage = Math.round(message.memoryUsage);
    }
    if (message.difficulty !== 0) {
      obj.difficulty = difficultyToJSON(message.difficulty);
    }
    if (message.isFirst !== false) {
      obj.isFirst = message.isFirst;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Submission>, I>>(base?: I): Submission {
    return Submission.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Submission>, I>>(object: I): Submission {
    const message = createBaseSubmission();
    message.Id = object.Id ?? "";
    message.problemId = object.problemId ?? "";
    message.userId = object.userId ?? "";
    message.country = object.country ?? "";
    message.title = object.title ?? "";
    message.battleId = object.battleId ?? undefined;
    message.score = object.score ?? 0;
    message.language = object.language ?? 0;
    message.userCode = object.userCode ?? "";
    message.executionResult = (object.executionResult !== undefined && object.executionResult !== null)
      ? ExecutionResult.fromPartial(object.executionResult)
      : undefined;
    message.executionTime = object.executionTime ?? undefined;
    message.memoryUsage = object.memoryUsage ?? undefined;
    message.difficulty = object.difficulty ?? 0;
    message.isFirst = object.isFirst ?? false;
    message.updatedAt = object.updatedAt ?? "";
    message.createdAt = object.createdAt ?? "";
    return message;
  },
};

function createBaseCreateSubmissionRequest(): CreateSubmissionRequest {
  return {
    problemId: "",
    userId: "",
    battleId: undefined,
    country: undefined,
    title: "",
    language: 0,
    userCode: "",
    difficulty: 0,
  };
}

export const CreateSubmissionRequest: MessageFns<CreateSubmissionRequest> = {
  encode(message: CreateSubmissionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.problemId !== "") {
      writer.uint32(10).string(message.problemId);
    }
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    if (message.battleId !== undefined) {
      writer.uint32(26).string(message.battleId);
    }
    if (message.country !== undefined) {
      writer.uint32(34).string(message.country);
    }
    if (message.title !== "") {
      writer.uint32(42).string(message.title);
    }
    if (message.language !== 0) {
      writer.uint32(48).int32(message.language);
    }
    if (message.userCode !== "") {
      writer.uint32(58).string(message.userCode);
    }
    if (message.difficulty !== 0) {
      writer.uint32(64).int32(message.difficulty);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateSubmissionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateSubmissionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.problemId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.battleId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.country = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.language = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.userCode = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.difficulty = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateSubmissionRequest {
    return {
      problemId: isSet(object.problemId) ? globalThis.String(object.problemId) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      battleId: isSet(object.battleId) ? globalThis.String(object.battleId) : undefined,
      country: isSet(object.country) ? globalThis.String(object.country) : undefined,
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      language: isSet(object.language) ? languageFromJSON(object.language) : 0,
      userCode: isSet(object.userCode) ? globalThis.String(object.userCode) : "",
      difficulty: isSet(object.difficulty) ? difficultyFromJSON(object.difficulty) : 0,
    };
  },

  toJSON(message: CreateSubmissionRequest): unknown {
    const obj: any = {};
    if (message.problemId !== "") {
      obj.problemId = message.problemId;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.battleId !== undefined) {
      obj.battleId = message.battleId;
    }
    if (message.country !== undefined) {
      obj.country = message.country;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.language !== 0) {
      obj.language = languageToJSON(message.language);
    }
    if (message.userCode !== "") {
      obj.userCode = message.userCode;
    }
    if (message.difficulty !== 0) {
      obj.difficulty = difficultyToJSON(message.difficulty);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateSubmissionRequest>, I>>(base?: I): CreateSubmissionRequest {
    return CreateSubmissionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateSubmissionRequest>, I>>(object: I): CreateSubmissionRequest {
    const message = createBaseCreateSubmissionRequest();
    message.problemId = object.problemId ?? "";
    message.userId = object.userId ?? "";
    message.battleId = object.battleId ?? undefined;
    message.country = object.country ?? undefined;
    message.title = object.title ?? "";
    message.language = object.language ?? 0;
    message.userCode = object.userCode ?? "";
    message.difficulty = object.difficulty ?? 0;
    return message;
  },
};

function createBaseUpdateSubmissionRequest(): UpdateSubmissionRequest {
  return { Id: "", executionResult: undefined, executionTime: 0, memoryUsage: 0 };
}

export const UpdateSubmissionRequest: MessageFns<UpdateSubmissionRequest> = {
  encode(message: UpdateSubmissionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.Id !== "") {
      writer.uint32(10).string(message.Id);
    }
    if (message.executionResult !== undefined) {
      ExecutionResult.encode(message.executionResult, writer.uint32(18).fork()).join();
    }
    if (message.executionTime !== 0) {
      writer.uint32(24).int32(message.executionTime);
    }
    if (message.memoryUsage !== 0) {
      writer.uint32(32).int32(message.memoryUsage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateSubmissionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateSubmissionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.Id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.executionResult = ExecutionResult.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.executionTime = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.memoryUsage = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateSubmissionRequest {
    return {
      Id: isSet(object.Id) ? globalThis.String(object.Id) : "",
      executionResult: isSet(object.executionResult) ? ExecutionResult.fromJSON(object.executionResult) : undefined,
      executionTime: isSet(object.executionTime) ? globalThis.Number(object.executionTime) : 0,
      memoryUsage: isSet(object.memoryUsage) ? globalThis.Number(object.memoryUsage) : 0,
    };
  },

  toJSON(message: UpdateSubmissionRequest): unknown {
    const obj: any = {};
    if (message.Id !== "") {
      obj.Id = message.Id;
    }
    if (message.executionResult !== undefined) {
      obj.executionResult = ExecutionResult.toJSON(message.executionResult);
    }
    if (message.executionTime !== 0) {
      obj.executionTime = Math.round(message.executionTime);
    }
    if (message.memoryUsage !== 0) {
      obj.memoryUsage = Math.round(message.memoryUsage);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateSubmissionRequest>, I>>(base?: I): UpdateSubmissionRequest {
    return UpdateSubmissionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateSubmissionRequest>, I>>(object: I): UpdateSubmissionRequest {
    const message = createBaseUpdateSubmissionRequest();
    message.Id = object.Id ?? "";
    message.executionResult = (object.executionResult !== undefined && object.executionResult !== null)
      ? ExecutionResult.fromPartial(object.executionResult)
      : undefined;
    message.executionTime = object.executionTime ?? 0;
    message.memoryUsage = object.memoryUsage ?? 0;
    return message;
  },
};

function createBaseGetSubmissionsRequest(): GetSubmissionsRequest {
  return { page: 0, limit: 0, problemId: undefined, battleId: undefined, userId: undefined };
}

export const GetSubmissionsRequest: MessageFns<GetSubmissionsRequest> = {
  encode(message: GetSubmissionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.page !== 0) {
      writer.uint32(8).int32(message.page);
    }
    if (message.limit !== 0) {
      writer.uint32(16).int32(message.limit);
    }
    if (message.problemId !== undefined) {
      writer.uint32(26).string(message.problemId);
    }
    if (message.battleId !== undefined) {
      writer.uint32(34).string(message.battleId);
    }
    if (message.userId !== undefined) {
      writer.uint32(42).string(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSubmissionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSubmissionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.problemId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.battleId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSubmissionsRequest {
    return {
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
      problemId: isSet(object.problemId) ? globalThis.String(object.problemId) : undefined,
      battleId: isSet(object.battleId) ? globalThis.String(object.battleId) : undefined,
      userId: isSet(object.userId) ? globalThis.String(object.userId) : undefined,
    };
  },

  toJSON(message: GetSubmissionsRequest): unknown {
    const obj: any = {};
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    if (message.problemId !== undefined) {
      obj.problemId = message.problemId;
    }
    if (message.battleId !== undefined) {
      obj.battleId = message.battleId;
    }
    if (message.userId !== undefined) {
      obj.userId = message.userId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetSubmissionsRequest>, I>>(base?: I): GetSubmissionsRequest {
    return GetSubmissionsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSubmissionsRequest>, I>>(object: I): GetSubmissionsRequest {
    const message = createBaseGetSubmissionsRequest();
    message.page = object.page ?? 0;
    message.limit = object.limit ?? 0;
    message.problemId = object.problemId ?? undefined;
    message.battleId = object.battleId ?? undefined;
    message.userId = object.userId ?? undefined;
    return message;
  },
};

function createBaseGetSubmissionsResponse(): GetSubmissionsResponse {
  return { submissions: [], totalPage: 0, currentPage: 0, totalItems: 0 };
}

export const GetSubmissionsResponse: MessageFns<GetSubmissionsResponse> = {
  encode(message: GetSubmissionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.submissions) {
      Submission.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.totalPage !== 0) {
      writer.uint32(16).int32(message.totalPage);
    }
    if (message.currentPage !== 0) {
      writer.uint32(24).int32(message.currentPage);
    }
    if (message.totalItems !== 0) {
      writer.uint32(32).int32(message.totalItems);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSubmissionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSubmissionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.submissions.push(Submission.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.totalPage = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.currentPage = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.totalItems = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSubmissionsResponse {
    return {
      submissions: globalThis.Array.isArray(object?.submissions)
        ? object.submissions.map((e: any) => Submission.fromJSON(e))
        : [],
      totalPage: isSet(object.totalPage) ? globalThis.Number(object.totalPage) : 0,
      currentPage: isSet(object.currentPage) ? globalThis.Number(object.currentPage) : 0,
      totalItems: isSet(object.totalItems) ? globalThis.Number(object.totalItems) : 0,
    };
  },

  toJSON(message: GetSubmissionsResponse): unknown {
    const obj: any = {};
    if (message.submissions?.length) {
      obj.submissions = message.submissions.map((e) => Submission.toJSON(e));
    }
    if (message.totalPage !== 0) {
      obj.totalPage = Math.round(message.totalPage);
    }
    if (message.currentPage !== 0) {
      obj.currentPage = Math.round(message.currentPage);
    }
    if (message.totalItems !== 0) {
      obj.totalItems = Math.round(message.totalItems);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetSubmissionsResponse>, I>>(base?: I): GetSubmissionsResponse {
    return GetSubmissionsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSubmissionsResponse>, I>>(object: I): GetSubmissionsResponse {
    const message = createBaseGetSubmissionsResponse();
    message.submissions = object.submissions?.map((e) => Submission.fromPartial(e)) || [];
    message.totalPage = object.totalPage ?? 0;
    message.currentPage = object.currentPage ?? 0;
    message.totalItems = object.totalItems ?? 0;
    return message;
  },
};

export type ProblemServiceService = typeof ProblemServiceService;
export const ProblemServiceService = {
  createProblem: {
    path: "/problem.v1.ProblemService/CreateProblem",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateProblemRequest): Buffer => Buffer.from(CreateProblemRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateProblemRequest => CreateProblemRequest.decode(value),
    responseSerialize: (value: Problem): Buffer => Buffer.from(Problem.encode(value).finish()),
    responseDeserialize: (value: Buffer): Problem => Problem.decode(value),
  },
  getProblem: {
    path: "/problem.v1.ProblemService/GetProblem",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetProblemRequest): Buffer => Buffer.from(GetProblemRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetProblemRequest => GetProblemRequest.decode(value),
    responseSerialize: (value: Problem): Buffer => Buffer.from(Problem.encode(value).finish()),
    responseDeserialize: (value: Buffer): Problem => Problem.decode(value),
  },
  getProblemForPublic: {
    path: "/problem.v1.ProblemService/GetProblemForPublic",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetProblemRequest): Buffer => Buffer.from(GetProblemRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetProblemRequest => GetProblemRequest.decode(value),
    responseSerialize: (value: GetProblemPublicResponse): Buffer =>
      Buffer.from(GetProblemPublicResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetProblemPublicResponse => GetProblemPublicResponse.decode(value),
  },
  updateBasicProblemDetails: {
    path: "/problem.v1.ProblemService/UpdateBasicProblemDetails",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateBasicProblemDetailsRequest): Buffer =>
      Buffer.from(UpdateBasicProblemDetailsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateBasicProblemDetailsRequest =>
      UpdateBasicProblemDetailsRequest.decode(value),
    responseSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
  },
  listProblems: {
    path: "/problem.v1.ProblemService/ListProblems",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListProblemRequest): Buffer => Buffer.from(ListProblemRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListProblemRequest => ListProblemRequest.decode(value),
    responseSerialize: (value: ListProblemResponse): Buffer => Buffer.from(ListProblemResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListProblemResponse => ListProblemResponse.decode(value),
  },
  addTestCase: {
    path: "/problem.v1.ProblemService/AddTestCase",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: AddTestCaseRequest): Buffer => Buffer.from(AddTestCaseRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): AddTestCaseRequest => AddTestCaseRequest.decode(value),
    responseSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
  },
  bulkUploadTestCases: {
    path: "/problem.v1.ProblemService/BulkUploadTestCases",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BulkUploadTestCasesRequest): Buffer =>
      Buffer.from(BulkUploadTestCasesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): BulkUploadTestCasesRequest => BulkUploadTestCasesRequest.decode(value),
    responseSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
  },
  removeTestCase: {
    path: "/problem.v1.ProblemService/RemoveTestCase",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RemoveTestCaseRequest): Buffer =>
      Buffer.from(RemoveTestCaseRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): RemoveTestCaseRequest => RemoveTestCaseRequest.decode(value),
    responseSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
  },
  addSolutionCode: {
    path: "/problem.v1.ProblemService/AddSolutionCode",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: AddSolutionCodeRequest): Buffer =>
      Buffer.from(AddSolutionCodeRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): AddSolutionCodeRequest => AddSolutionCodeRequest.decode(value),
    responseSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
  },
  updateSolutionCode: {
    path: "/problem.v1.ProblemService/UpdateSolutionCode",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateSolutionCodeRequest): Buffer =>
      Buffer.from(UpdateSolutionCodeRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateSolutionCodeRequest => UpdateSolutionCodeRequest.decode(value),
    responseSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
  },
  removeSolutionCode: {
    path: "/problem.v1.ProblemService/RemoveSolutionCode",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RemoveSolutionCodeRequest): Buffer =>
      Buffer.from(RemoveSolutionCodeRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): RemoveSolutionCodeRequest => RemoveSolutionCodeRequest.decode(value),
    responseSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
  },
} as const;

export interface ProblemServiceServer extends UntypedServiceImplementation {
  createProblem: handleUnaryCall<CreateProblemRequest, Problem>;
  getProblem: handleUnaryCall<GetProblemRequest, Problem>;
  getProblemForPublic: handleUnaryCall<GetProblemRequest, GetProblemPublicResponse>;
  updateBasicProblemDetails: handleUnaryCall<UpdateBasicProblemDetailsRequest, Empty>;
  listProblems: handleUnaryCall<ListProblemRequest, ListProblemResponse>;
  addTestCase: handleUnaryCall<AddTestCaseRequest, Empty>;
  bulkUploadTestCases: handleUnaryCall<BulkUploadTestCasesRequest, Empty>;
  removeTestCase: handleUnaryCall<RemoveTestCaseRequest, Empty>;
  addSolutionCode: handleUnaryCall<AddSolutionCodeRequest, Empty>;
  updateSolutionCode: handleUnaryCall<UpdateSolutionCodeRequest, Empty>;
  removeSolutionCode: handleUnaryCall<RemoveSolutionCodeRequest, Empty>;
}

export interface ProblemServiceClient extends Client {
  createProblem(
    request: CreateProblemRequest,
    callback: (error: ServiceError | null, response: Problem) => void,
  ): ClientUnaryCall;
  createProblem(
    request: CreateProblemRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Problem) => void,
  ): ClientUnaryCall;
  createProblem(
    request: CreateProblemRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Problem) => void,
  ): ClientUnaryCall;
  getProblem(
    request: GetProblemRequest,
    callback: (error: ServiceError | null, response: Problem) => void,
  ): ClientUnaryCall;
  getProblem(
    request: GetProblemRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Problem) => void,
  ): ClientUnaryCall;
  getProblem(
    request: GetProblemRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Problem) => void,
  ): ClientUnaryCall;
  getProblemForPublic(
    request: GetProblemRequest,
    callback: (error: ServiceError | null, response: GetProblemPublicResponse) => void,
  ): ClientUnaryCall;
  getProblemForPublic(
    request: GetProblemRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetProblemPublicResponse) => void,
  ): ClientUnaryCall;
  getProblemForPublic(
    request: GetProblemRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetProblemPublicResponse) => void,
  ): ClientUnaryCall;
  updateBasicProblemDetails(
    request: UpdateBasicProblemDetailsRequest,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  updateBasicProblemDetails(
    request: UpdateBasicProblemDetailsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  updateBasicProblemDetails(
    request: UpdateBasicProblemDetailsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  listProblems(
    request: ListProblemRequest,
    callback: (error: ServiceError | null, response: ListProblemResponse) => void,
  ): ClientUnaryCall;
  listProblems(
    request: ListProblemRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListProblemResponse) => void,
  ): ClientUnaryCall;
  listProblems(
    request: ListProblemRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListProblemResponse) => void,
  ): ClientUnaryCall;
  addTestCase(
    request: AddTestCaseRequest,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  addTestCase(
    request: AddTestCaseRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  addTestCase(
    request: AddTestCaseRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  bulkUploadTestCases(
    request: BulkUploadTestCasesRequest,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  bulkUploadTestCases(
    request: BulkUploadTestCasesRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  bulkUploadTestCases(
    request: BulkUploadTestCasesRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  removeTestCase(
    request: RemoveTestCaseRequest,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  removeTestCase(
    request: RemoveTestCaseRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  removeTestCase(
    request: RemoveTestCaseRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  addSolutionCode(
    request: AddSolutionCodeRequest,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  addSolutionCode(
    request: AddSolutionCodeRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  addSolutionCode(
    request: AddSolutionCodeRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  updateSolutionCode(
    request: UpdateSolutionCodeRequest,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  updateSolutionCode(
    request: UpdateSolutionCodeRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  updateSolutionCode(
    request: UpdateSolutionCodeRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  removeSolutionCode(
    request: RemoveSolutionCodeRequest,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  removeSolutionCode(
    request: RemoveSolutionCodeRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  removeSolutionCode(
    request: RemoveSolutionCodeRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
}

export const ProblemServiceClient = makeGenericClientConstructor(
  ProblemServiceService,
  "problem.v1.ProblemService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): ProblemServiceClient;
  service: typeof ProblemServiceService;
  serviceName: string;
};

export type SubmissionServiceService = typeof SubmissionServiceService;
export const SubmissionServiceService = {
  createSubmission: {
    path: "/problem.v1.SubmissionService/CreateSubmission",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateSubmissionRequest): Buffer =>
      Buffer.from(CreateSubmissionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateSubmissionRequest => CreateSubmissionRequest.decode(value),
    responseSerialize: (value: Submission): Buffer => Buffer.from(Submission.encode(value).finish()),
    responseDeserialize: (value: Buffer): Submission => Submission.decode(value),
  },
  updateSubmission: {
    path: "/problem.v1.SubmissionService/UpdateSubmission",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateSubmissionRequest): Buffer =>
      Buffer.from(UpdateSubmissionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateSubmissionRequest => UpdateSubmissionRequest.decode(value),
    responseSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
  },
  getSubmissions: {
    path: "/problem.v1.SubmissionService/GetSubmissions",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetSubmissionsRequest): Buffer =>
      Buffer.from(GetSubmissionsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetSubmissionsRequest => GetSubmissionsRequest.decode(value),
    responseSerialize: (value: GetSubmissionsResponse): Buffer =>
      Buffer.from(GetSubmissionsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetSubmissionsResponse => GetSubmissionsResponse.decode(value),
  },
} as const;

export interface SubmissionServiceServer extends UntypedServiceImplementation {
  createSubmission: handleUnaryCall<CreateSubmissionRequest, Submission>;
  updateSubmission: handleUnaryCall<UpdateSubmissionRequest, Empty>;
  getSubmissions: handleUnaryCall<GetSubmissionsRequest, GetSubmissionsResponse>;
}

export interface SubmissionServiceClient extends Client {
  createSubmission(
    request: CreateSubmissionRequest,
    callback: (error: ServiceError | null, response: Submission) => void,
  ): ClientUnaryCall;
  createSubmission(
    request: CreateSubmissionRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Submission) => void,
  ): ClientUnaryCall;
  createSubmission(
    request: CreateSubmissionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Submission) => void,
  ): ClientUnaryCall;
  updateSubmission(
    request: UpdateSubmissionRequest,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  updateSubmission(
    request: UpdateSubmissionRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  updateSubmission(
    request: UpdateSubmissionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  getSubmissions(
    request: GetSubmissionsRequest,
    callback: (error: ServiceError | null, response: GetSubmissionsResponse) => void,
  ): ClientUnaryCall;
  getSubmissions(
    request: GetSubmissionsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetSubmissionsResponse) => void,
  ): ClientUnaryCall;
  getSubmissions(
    request: GetSubmissionsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetSubmissionsResponse) => void,
  ): ClientUnaryCall;
}

export const SubmissionServiceClient = makeGenericClientConstructor(
  SubmissionServiceService,
  "problem.v1.SubmissionService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): SubmissionServiceClient;
  service: typeof SubmissionServiceService;
  serviceName: string;
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
